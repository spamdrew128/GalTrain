/* automatically generated by rust-bindgen 0.69.4 */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
pub const _STDINT_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __GLIBC_USE_ISOC2X: u32 = 0;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __TIMESIZE: u32 = 64;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_SCANF: u32 = 0;
pub const __GLIBC_USE_C2X_STRTOL: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_60559_BFP__: u32 = 201404;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_IEC_60559_COMPLEX__: u32 = 201404;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 39;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI: u32 = 0;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 0;
pub const _BITS_TYPES_H: u32 = 1;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __STATFS_MATCHES_STATFS64: u32 = 1;
pub const __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const _BITS_TIME64_H: u32 = 1;
pub const _BITS_WCHAR_H: u32 = 1;
pub const _BITS_STDINT_INTN_H: u32 = 1;
pub const _BITS_STDINT_UINTN_H: u32 = 1;
pub const _BITS_STDINT_LEAST_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i64 = -9223372036854775808;
pub const INT_FAST32_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u64 = 9223372036854775807;
pub const INT_FAST32_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: i32 = -1;
pub const UINT_FAST32_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const _STDIO_H: u32 = 1;
pub const _____fpos_t_defined: u32 = 1;
pub const ____mbstate_t_defined: u32 = 1;
pub const _____fpos64_t_defined: u32 = 1;
pub const ____FILE_defined: u32 = 1;
pub const __FILE_defined: u32 = 1;
pub const __struct_FILE_defined: u32 = 1;
pub const _IO_EOF_SEEN: u32 = 16;
pub const _IO_ERR_SEEN: u32 = 32;
pub const _IO_USER_LOCK: u32 = 32768;
pub const __cookie_io_functions_t_defined: u32 = 1;
pub const _IOFBF: u32 = 0;
pub const _IOLBF: u32 = 1;
pub const _IONBF: u32 = 2;
pub const BUFSIZ: u32 = 8192;
pub const EOF: i32 = -1;
pub const SEEK_SET: u32 = 0;
pub const SEEK_CUR: u32 = 1;
pub const SEEK_END: u32 = 2;
pub const P_tmpdir: &[u8; 5] = b"/tmp\0";
pub const L_tmpnam: u32 = 20;
pub const TMP_MAX: u32 = 238328;
pub const _BITS_STDIO_LIM_H: u32 = 1;
pub const FILENAME_MAX: u32 = 4096;
pub const L_ctermid: u32 = 9;
pub const FOPEN_MAX: u32 = 16;
pub const __HAVE_FLOAT128: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT128: u32 = 0;
pub const __HAVE_FLOAT64X: u32 = 1;
pub const __HAVE_FLOAT64X_LONG_DOUBLE: u32 = 1;
pub const __HAVE_FLOAT16: u32 = 0;
pub const __HAVE_FLOAT32: u32 = 1;
pub const __HAVE_FLOAT64: u32 = 1;
pub const __HAVE_FLOAT32X: u32 = 1;
pub const __HAVE_FLOAT128X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT16: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT32: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT64: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT32X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT64X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT128X: u32 = 0;
pub const __HAVE_FLOATN_NOT_TYPEDEF: u32 = 0;
pub const _STDLIB_H: u32 = 1;
pub const WNOHANG: u32 = 1;
pub const WUNTRACED: u32 = 2;
pub const WSTOPPED: u32 = 2;
pub const WEXITED: u32 = 4;
pub const WCONTINUED: u32 = 8;
pub const WNOWAIT: u32 = 16777216;
pub const __WNOTHREAD: u32 = 536870912;
pub const __WALL: u32 = 1073741824;
pub const __WCLONE: u32 = 2147483648;
pub const __W_CONTINUED: u32 = 65535;
pub const __WCOREFLAG: u32 = 128;
pub const __ldiv_t_defined: u32 = 1;
pub const __lldiv_t_defined: u32 = 1;
pub const RAND_MAX: u32 = 2147483647;
pub const EXIT_FAILURE: u32 = 1;
pub const EXIT_SUCCESS: u32 = 0;
pub const _SYS_TYPES_H: u32 = 1;
pub const __clock_t_defined: u32 = 1;
pub const __clockid_t_defined: u32 = 1;
pub const __time_t_defined: u32 = 1;
pub const __timer_t_defined: u32 = 1;
pub const __BIT_TYPES_DEFINED__: u32 = 1;
pub const _ENDIAN_H: u32 = 1;
pub const _BITS_ENDIAN_H: u32 = 1;
pub const __LITTLE_ENDIAN: u32 = 1234;
pub const __BIG_ENDIAN: u32 = 4321;
pub const __PDP_ENDIAN: u32 = 3412;
pub const _BITS_ENDIANNESS_H: u32 = 1;
pub const __BYTE_ORDER: u32 = 1234;
pub const __FLOAT_WORD_ORDER: u32 = 1234;
pub const LITTLE_ENDIAN: u32 = 1234;
pub const BIG_ENDIAN: u32 = 4321;
pub const PDP_ENDIAN: u32 = 3412;
pub const BYTE_ORDER: u32 = 1234;
pub const _BITS_BYTESWAP_H: u32 = 1;
pub const _BITS_UINTN_IDENTITY_H: u32 = 1;
pub const _SYS_SELECT_H: u32 = 1;
pub const __sigset_t_defined: u32 = 1;
pub const __timeval_defined: u32 = 1;
pub const _STRUCT_TIMESPEC: u32 = 1;
pub const FD_SETSIZE: u32 = 1024;
pub const _BITS_PTHREADTYPES_COMMON_H: u32 = 1;
pub const _THREAD_SHARED_TYPES_H: u32 = 1;
pub const _BITS_PTHREADTYPES_ARCH_H: u32 = 1;
pub const __SIZEOF_PTHREAD_MUTEX_T: u32 = 40;
pub const __SIZEOF_PTHREAD_ATTR_T: u32 = 56;
pub const __SIZEOF_PTHREAD_RWLOCK_T: u32 = 56;
pub const __SIZEOF_PTHREAD_BARRIER_T: u32 = 32;
pub const __SIZEOF_PTHREAD_MUTEXATTR_T: u32 = 4;
pub const __SIZEOF_PTHREAD_COND_T: u32 = 48;
pub const __SIZEOF_PTHREAD_CONDATTR_T: u32 = 4;
pub const __SIZEOF_PTHREAD_RWLOCKATTR_T: u32 = 8;
pub const __SIZEOF_PTHREAD_BARRIERATTR_T: u32 = 4;
pub const _THREAD_MUTEX_INTERNAL_H: u32 = 1;
pub const __PTHREAD_MUTEX_HAVE_PREV: u32 = 1;
pub const __have_pthread_attr_t: u32 = 1;
pub const _ALLOCA_H: u32 = 1;
pub const _ASSERT_H: u32 = 1;
pub const HIP_VERSION_MAJOR: u32 = 6;
pub const HIP_VERSION_MINOR: u32 = 0;
pub const HIP_VERSION_PATCH: u32 = 32831;
pub const HIP_VERSION_GITHASH: &[u8; 1] = b"\0";
pub const HIP_VERSION_BUILD_ID: u32 = 0;
pub const HIP_VERSION_BUILD_NAME: &[u8; 1] = b"\0";
pub const HIP_VERSION: u32 = 60032831;
pub const __HIP_HAS_GET_PCH: u32 = 1;
pub const __HIP_ARCH_HAS_GLOBAL_INT32_ATOMICS__: u32 = 0;
pub const __HIP_ARCH_HAS_GLOBAL_FLOAT_ATOMIC_EXCH__: u32 = 0;
pub const __HIP_ARCH_HAS_SHARED_INT32_ATOMICS__: u32 = 0;
pub const __HIP_ARCH_HAS_SHARED_FLOAT_ATOMIC_EXCH__: u32 = 0;
pub const __HIP_ARCH_HAS_FLOAT_ATOMIC_ADD__: u32 = 0;
pub const __HIP_ARCH_HAS_GLOBAL_INT64_ATOMICS__: u32 = 0;
pub const __HIP_ARCH_HAS_SHARED_INT64_ATOMICS__: u32 = 0;
pub const __HIP_ARCH_HAS_DOUBLES__: u32 = 0;
pub const __HIP_ARCH_HAS_WARP_VOTE__: u32 = 0;
pub const __HIP_ARCH_HAS_WARP_BALLOT__: u32 = 0;
pub const __HIP_ARCH_HAS_WARP_SHUFFLE__: u32 = 0;
pub const __HIP_ARCH_HAS_WARP_FUNNEL_SHIFT__: u32 = 0;
pub const __HIP_ARCH_HAS_THREAD_FENCE_SYSTEM__: u32 = 0;
pub const __HIP_ARCH_HAS_SYNC_THREAD_EXT__: u32 = 0;
pub const __HIP_ARCH_HAS_SURFACE_FUNCS__: u32 = 0;
pub const __HIP_ARCH_HAS_3DGRID__: u32 = 0;
pub const __HIP_ARCH_HAS_DYNAMIC_PARALLEL__: u32 = 0;
pub const __HIP_CLANG_ONLY__: u32 = 0;
pub const _MATH_H: u32 = 1;
pub const _BITS_LIBM_SIMD_DECL_STUBS_H: u32 = 1;
pub const __FP_LOGB0_IS_MIN: u32 = 1;
pub const __FP_LOGBNAN_IS_MIN: u32 = 1;
pub const FP_ILOGB0: i32 = -2147483648;
pub const FP_ILOGBNAN: i32 = -2147483648;
pub const __MATH_DECLARING_DOUBLE: u32 = 1;
pub const __MATH_DECLARING_FLOATN: u32 = 0;
pub const __MATH_DECLARE_LDOUBLE: u32 = 1;
pub const FP_NAN: u32 = 0;
pub const FP_INFINITE: u32 = 1;
pub const FP_ZERO: u32 = 2;
pub const FP_SUBNORMAL: u32 = 3;
pub const FP_NORMAL: u32 = 4;
pub const MATH_ERRNO: u32 = 1;
pub const MATH_ERREXCEPT: u32 = 2;
pub const math_errhandling: u32 = 3;
pub const M_E: f64 = 2.718281828459045;
pub const M_LOG2E: f64 = 1.4426950408889634;
pub const M_LOG10E: f64 = 0.4342944819032518;
pub const M_LN2: f64 = 0.6931471805599453;
pub const M_LN10: f64 = 2.302585092994046;
pub const M_PI: f64 = 3.141592653589793;
pub const M_PI_2: f64 = 1.5707963267948966;
pub const M_PI_4: f64 = 0.7853981633974483;
pub const M_1_PI: f64 = 0.3183098861837907;
pub const M_2_PI: f64 = 0.6366197723675814;
pub const M_2_SQRTPI: f64 = 1.1283791670955126;
pub const M_SQRT2: f64 = 1.4142135623730951;
pub const M_SQRT1_2: f64 = 0.7071067811865476;
pub const _STRING_H: u32 = 1;
pub const _BITS_TYPES_LOCALE_T_H: u32 = 1;
pub const _BITS_TYPES___LOCALE_T_H: u32 = 1;
pub const _STRINGS_H: u32 = 1;
pub const GENERIC_GRID_LAUNCH: u32 = 1;
pub const __bool_true_false_are_defined: u32 = 1;
pub const true_: u32 = 1;
pub const false_: u32 = 0;
pub const HIP_TRSA_OVERRIDE_FORMAT: u32 = 1;
pub const HIP_TRSF_READ_AS_INTEGER: u32 = 1;
pub const HIP_TRSF_NORMALIZED_COORDINATES: u32 = 2;
pub const HIP_TRSF_SRGB: u32 = 16;
pub const _LIBC_LIMITS_H_: u32 = 1;
pub const MB_LEN_MAX: u32 = 16;
pub const _BITS_POSIX1_LIM_H: u32 = 1;
pub const _POSIX_AIO_LISTIO_MAX: u32 = 2;
pub const _POSIX_AIO_MAX: u32 = 1;
pub const _POSIX_ARG_MAX: u32 = 4096;
pub const _POSIX_CHILD_MAX: u32 = 25;
pub const _POSIX_DELAYTIMER_MAX: u32 = 32;
pub const _POSIX_HOST_NAME_MAX: u32 = 255;
pub const _POSIX_LINK_MAX: u32 = 8;
pub const _POSIX_LOGIN_NAME_MAX: u32 = 9;
pub const _POSIX_MAX_CANON: u32 = 255;
pub const _POSIX_MAX_INPUT: u32 = 255;
pub const _POSIX_MQ_OPEN_MAX: u32 = 8;
pub const _POSIX_MQ_PRIO_MAX: u32 = 32;
pub const _POSIX_NAME_MAX: u32 = 14;
pub const _POSIX_NGROUPS_MAX: u32 = 8;
pub const _POSIX_OPEN_MAX: u32 = 20;
pub const _POSIX_PATH_MAX: u32 = 256;
pub const _POSIX_PIPE_BUF: u32 = 512;
pub const _POSIX_RE_DUP_MAX: u32 = 255;
pub const _POSIX_RTSIG_MAX: u32 = 8;
pub const _POSIX_SEM_NSEMS_MAX: u32 = 256;
pub const _POSIX_SEM_VALUE_MAX: u32 = 32767;
pub const _POSIX_SIGQUEUE_MAX: u32 = 32;
pub const _POSIX_SSIZE_MAX: u32 = 32767;
pub const _POSIX_STREAM_MAX: u32 = 8;
pub const _POSIX_SYMLINK_MAX: u32 = 255;
pub const _POSIX_SYMLOOP_MAX: u32 = 8;
pub const _POSIX_TIMER_MAX: u32 = 32;
pub const _POSIX_TTY_NAME_MAX: u32 = 9;
pub const _POSIX_TZNAME_MAX: u32 = 6;
pub const _POSIX_CLOCKRES_MIN: u32 = 20000000;
pub const NR_OPEN: u32 = 1024;
pub const NGROUPS_MAX: u32 = 65536;
pub const ARG_MAX: u32 = 131072;
pub const LINK_MAX: u32 = 127;
pub const MAX_CANON: u32 = 255;
pub const MAX_INPUT: u32 = 255;
pub const NAME_MAX: u32 = 255;
pub const PATH_MAX: u32 = 4096;
pub const PIPE_BUF: u32 = 4096;
pub const XATTR_NAME_MAX: u32 = 255;
pub const XATTR_SIZE_MAX: u32 = 65536;
pub const XATTR_LIST_MAX: u32 = 65536;
pub const RTSIG_MAX: u32 = 32;
pub const _POSIX_THREAD_KEYS_MAX: u32 = 128;
pub const PTHREAD_KEYS_MAX: u32 = 1024;
pub const _POSIX_THREAD_DESTRUCTOR_ITERATIONS: u32 = 4;
pub const PTHREAD_DESTRUCTOR_ITERATIONS: u32 = 4;
pub const _POSIX_THREAD_THREADS_MAX: u32 = 64;
pub const AIO_PRIO_DELTA_MAX: u32 = 20;
pub const PTHREAD_STACK_MIN: u32 = 16384;
pub const DELAYTIMER_MAX: u32 = 2147483647;
pub const TTY_NAME_MAX: u32 = 32;
pub const LOGIN_NAME_MAX: u32 = 256;
pub const HOST_NAME_MAX: u32 = 64;
pub const MQ_PRIO_MAX: u32 = 32768;
pub const SEM_VALUE_MAX: u32 = 2147483647;
pub const _BITS_POSIX2_LIM_H: u32 = 1;
pub const _POSIX2_BC_BASE_MAX: u32 = 99;
pub const _POSIX2_BC_DIM_MAX: u32 = 2048;
pub const _POSIX2_BC_SCALE_MAX: u32 = 99;
pub const _POSIX2_BC_STRING_MAX: u32 = 1000;
pub const _POSIX2_COLL_WEIGHTS_MAX: u32 = 2;
pub const _POSIX2_EXPR_NEST_MAX: u32 = 32;
pub const _POSIX2_LINE_MAX: u32 = 2048;
pub const _POSIX2_RE_DUP_MAX: u32 = 255;
pub const _POSIX2_CHARCLASS_NAME_MAX: u32 = 14;
pub const BC_BASE_MAX: u32 = 99;
pub const BC_DIM_MAX: u32 = 2048;
pub const BC_SCALE_MAX: u32 = 99;
pub const BC_STRING_MAX: u32 = 1000;
pub const COLL_WEIGHTS_MAX: u32 = 255;
pub const EXPR_NEST_MAX: u32 = 32;
pub const LINE_MAX: u32 = 2048;
pub const CHARCLASS_NAME_MAX: u32 = 2048;
pub const RE_DUP_MAX: u32 = 32767;
pub const hipTextureType1D: u32 = 1;
pub const hipTextureType2D: u32 = 2;
pub const hipTextureType3D: u32 = 3;
pub const hipTextureTypeCubemap: u32 = 12;
pub const hipTextureType1DLayered: u32 = 241;
pub const hipTextureType2DLayered: u32 = 242;
pub const hipTextureTypeCubemapLayered: u32 = 252;
pub const HIP_IMAGE_OBJECT_SIZE_DWORD: u32 = 12;
pub const HIP_SAMPLER_OBJECT_SIZE_DWORD: u32 = 8;
pub const HIP_SAMPLER_OBJECT_OFFSET_DWORD: u32 = 12;
pub const HIP_TEXTURE_OBJECT_SIZE_DWORD: u32 = 20;
pub const DEPRECATED_MSG : & [u8 ; 205] = b"This API is marked as deprecated and may not be supported in future releases. For more details please refer https://github.com/ROCm-Developer-Tools/HIP/blob/master/docs/markdown/hip_deprecated_api_list.md\0" ;
pub const hipIpcMemLazyEnablePeerAccess: u32 = 1;
pub const HIP_IPC_HANDLE_SIZE: u32 = 64;
pub const hipStreamDefault: u32 = 0;
pub const hipStreamNonBlocking: u32 = 1;
pub const hipEventDefault: u32 = 0;
pub const hipEventBlockingSync: u32 = 1;
pub const hipEventDisableTiming: u32 = 2;
pub const hipEventInterprocess: u32 = 4;
pub const hipEventDisableSystemFence: u32 = 536870912;
pub const hipEventReleaseToDevice: u32 = 1073741824;
pub const hipEventReleaseToSystem: u32 = 2147483648;
pub const hipHostMallocDefault: u32 = 0;
pub const hipHostMallocPortable: u32 = 1;
pub const hipHostMallocMapped: u32 = 2;
pub const hipHostMallocWriteCombined: u32 = 4;
pub const hipHostMallocNumaUser: u32 = 536870912;
pub const hipHostMallocCoherent: u32 = 1073741824;
pub const hipHostMallocNonCoherent: u32 = 2147483648;
pub const hipMemAttachGlobal: u32 = 1;
pub const hipMemAttachHost: u32 = 2;
pub const hipMemAttachSingle: u32 = 4;
pub const hipDeviceMallocDefault: u32 = 0;
pub const hipDeviceMallocFinegrained: u32 = 1;
pub const hipMallocSignalMemory: u32 = 2;
pub const hipDeviceMallocUncached: u32 = 3;
pub const hipHostRegisterDefault: u32 = 0;
pub const hipHostRegisterPortable: u32 = 1;
pub const hipHostRegisterMapped: u32 = 2;
pub const hipHostRegisterIoMemory: u32 = 4;
pub const hipHostRegisterReadOnly: u32 = 8;
pub const hipExtHostRegisterCoarseGrained: u32 = 8;
pub const hipDeviceScheduleAuto: u32 = 0;
pub const hipDeviceScheduleSpin: u32 = 1;
pub const hipDeviceScheduleYield: u32 = 2;
pub const hipDeviceScheduleBlockingSync: u32 = 4;
pub const hipDeviceScheduleMask: u32 = 7;
pub const hipDeviceMapHost: u32 = 8;
pub const hipDeviceLmemResizeToMax: u32 = 16;
pub const hipArrayDefault: u32 = 0;
pub const hipArrayLayered: u32 = 1;
pub const hipArraySurfaceLoadStore: u32 = 2;
pub const hipArrayCubemap: u32 = 4;
pub const hipArrayTextureGather: u32 = 8;
pub const hipOccupancyDefault: u32 = 0;
pub const hipOccupancyDisableCachingOverride: u32 = 1;
pub const hipCooperativeLaunchMultiDeviceNoPreSync: u32 = 1;
pub const hipCooperativeLaunchMultiDeviceNoPostSync: u32 = 2;
pub const hipExtAnyOrderLaunch: u32 = 1;
pub const hipStreamWaitValueGte: u32 = 0;
pub const hipStreamWaitValueEq: u32 = 1;
pub const hipStreamWaitValueAnd: u32 = 2;
pub const hipStreamWaitValueNor: u32 = 3;
pub const hipExternalMemoryDedicated: u32 = 1;
pub const USE_PEER_NON_UNIFIED: u32 = 1;
pub const hipblasVersionMajor: u32 = 2;
pub const hipblaseVersionMinor: u32 = 0;
pub const hipblasVersionMinor: u32 = 0;
pub const hipblasVersionPatch: u32 = 0;
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __int_least8_t = __int8_t;
pub type __uint_least8_t = __uint8_t;
pub type __int_least16_t = __int16_t;
pub type __uint_least16_t = __uint16_t;
pub type __int_least32_t = __int32_t;
pub type __uint_least32_t = __uint32_t;
pub type __int_least64_t = __int64_t;
pub type __uint_least64_t = __uint64_t;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __intmax_t = ::std::os::raw::c_long;
pub type __uintmax_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __fsid_t {
    pub __val: [::std::os::raw::c_int; 2usize],
}
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __suseconds64_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
pub type __sig_atomic_t = ::std::os::raw::c_int;
pub type int_least8_t = __int_least8_t;
pub type int_least16_t = __int_least16_t;
pub type int_least32_t = __int_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least8_t = __uint_least8_t;
pub type uint_least16_t = __uint_least16_t;
pub type uint_least32_t = __uint_least32_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_long;
pub type int_fast32_t = ::std::os::raw::c_long;
pub type int_fast64_t = ::std::os::raw::c_long;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_ulong;
pub type uint_fast32_t = ::std::os::raw::c_ulong;
pub type uint_fast64_t = ::std::os::raw::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
pub type __gnuc_va_list = __builtin_va_list;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __mbstate_t {
    pub __count: ::std::os::raw::c_int,
    pub __value: __mbstate_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __mbstate_t__bindgen_ty_1 {
    pub __wch: ::std::os::raw::c_uint,
    pub __wchb: [::std::os::raw::c_char; 4usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _G_fpos_t {
    pub __pos: __off_t,
    pub __state: __mbstate_t,
}
pub type __fpos_t = _G_fpos_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _G_fpos64_t {
    pub __pos: __off64_t,
    pub __state: __mbstate_t,
}
pub type __fpos64_t = _G_fpos64_t;
pub type __FILE = _IO_FILE;
pub type FILE = _IO_FILE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_marker {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_codecvt {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_wide_data {
    _unused: [u8; 0],
}
pub type _IO_lock_t = ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_FILE {
    pub _flags: ::std::os::raw::c_int,
    pub _IO_read_ptr: *mut ::std::os::raw::c_char,
    pub _IO_read_end: *mut ::std::os::raw::c_char,
    pub _IO_read_base: *mut ::std::os::raw::c_char,
    pub _IO_write_base: *mut ::std::os::raw::c_char,
    pub _IO_write_ptr: *mut ::std::os::raw::c_char,
    pub _IO_write_end: *mut ::std::os::raw::c_char,
    pub _IO_buf_base: *mut ::std::os::raw::c_char,
    pub _IO_buf_end: *mut ::std::os::raw::c_char,
    pub _IO_save_base: *mut ::std::os::raw::c_char,
    pub _IO_backup_base: *mut ::std::os::raw::c_char,
    pub _IO_save_end: *mut ::std::os::raw::c_char,
    pub _markers: *mut _IO_marker,
    pub _chain: *mut _IO_FILE,
    pub _fileno: ::std::os::raw::c_int,
    pub _flags2: ::std::os::raw::c_int,
    pub _old_offset: __off_t,
    pub _cur_column: ::std::os::raw::c_ushort,
    pub _vtable_offset: ::std::os::raw::c_schar,
    pub _shortbuf: [::std::os::raw::c_char; 1usize],
    pub _lock: *mut _IO_lock_t,
    pub _offset: __off64_t,
    pub _codecvt: *mut _IO_codecvt,
    pub _wide_data: *mut _IO_wide_data,
    pub _freeres_list: *mut _IO_FILE,
    pub _freeres_buf: *mut ::std::os::raw::c_void,
    pub __pad5: usize,
    pub _mode: ::std::os::raw::c_int,
    pub _unused2: [::std::os::raw::c_char; 20usize],
}
pub type cookie_read_function_t = ::std::option::Option<
    unsafe extern "C" fn(
        __cookie: *mut ::std::os::raw::c_void,
        __buf: *mut ::std::os::raw::c_char,
        __nbytes: usize,
    ) -> __ssize_t,
>;
pub type cookie_write_function_t = ::std::option::Option<
    unsafe extern "C" fn(
        __cookie: *mut ::std::os::raw::c_void,
        __buf: *const ::std::os::raw::c_char,
        __nbytes: usize,
    ) -> __ssize_t,
>;
pub type cookie_seek_function_t = ::std::option::Option<
    unsafe extern "C" fn(
        __cookie: *mut ::std::os::raw::c_void,
        __pos: *mut __off64_t,
        __w: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int,
>;
pub type cookie_close_function_t = ::std::option::Option<
    unsafe extern "C" fn(__cookie: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_cookie_io_functions_t {
    pub read: cookie_read_function_t,
    pub write: cookie_write_function_t,
    pub seek: cookie_seek_function_t,
    pub close: cookie_close_function_t,
}
pub type cookie_io_functions_t = _IO_cookie_io_functions_t;
pub type va_list = __gnuc_va_list;
pub type off_t = __off_t;
pub type fpos_t = __fpos_t;
extern "C" {
    pub static mut stdin: *mut FILE;
}
extern "C" {
    pub static mut stdout: *mut FILE;
}
extern "C" {
    pub static mut stderr: *mut FILE;
}
extern "C" {
    pub fn remove(__filename: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rename(
        __old: *const ::std::os::raw::c_char,
        __new: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn renameat(
        __oldfd: ::std::os::raw::c_int,
        __old: *const ::std::os::raw::c_char,
        __newfd: ::std::os::raw::c_int,
        __new: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fclose(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tmpfile() -> *mut FILE;
}
extern "C" {
    pub fn tmpnam(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn tmpnam_r(__s: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn tempnam(
        __dir: *const ::std::os::raw::c_char,
        __pfx: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fflush(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fflush_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fopen(
        __filename: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn freopen(
        __filename: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
        __stream: *mut FILE,
    ) -> *mut FILE;
}
extern "C" {
    pub fn fdopen(__fd: ::std::os::raw::c_int, __modes: *const ::std::os::raw::c_char)
        -> *mut FILE;
}
extern "C" {
    pub fn fopencookie(
        __magic_cookie: *mut ::std::os::raw::c_void,
        __modes: *const ::std::os::raw::c_char,
        __io_funcs: cookie_io_functions_t,
    ) -> *mut FILE;
}
extern "C" {
    pub fn fmemopen(
        __s: *mut ::std::os::raw::c_void,
        __len: usize,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn open_memstream(
        __bufloc: *mut *mut ::std::os::raw::c_char,
        __sizeloc: *mut usize,
    ) -> *mut FILE;
}
extern "C" {
    pub fn setbuf(__stream: *mut FILE, __buf: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn setvbuf(
        __stream: *mut FILE,
        __buf: *mut ::std::os::raw::c_char,
        __modes: ::std::os::raw::c_int,
        __n: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setbuffer(__stream: *mut FILE, __buf: *mut ::std::os::raw::c_char, __size: usize);
}
extern "C" {
    pub fn setlinebuf(__stream: *mut FILE);
}
extern "C" {
    pub fn fprintf(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn printf(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sprintf(
        __s: *mut ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfprintf(
        __s: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vprintf(
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsprintf(
        __s: *mut ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn snprintf(
        __s: *mut ::std::os::raw::c_char,
        __maxlen: ::std::os::raw::c_ulong,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsnprintf(
        __s: *mut ::std::os::raw::c_char,
        __maxlen: ::std::os::raw::c_ulong,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vasprintf(
        __ptr: *mut *mut ::std::os::raw::c_char,
        __f: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __asprintf(
        __ptr: *mut *mut ::std::os::raw::c_char,
        __fmt: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn asprintf(
        __ptr: *mut *mut ::std::os::raw::c_char,
        __fmt: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vdprintf(
        __fd: ::std::os::raw::c_int,
        __fmt: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dprintf(
        __fd: ::std::os::raw::c_int,
        __fmt: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fscanf(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scanf(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sscanf(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
pub type _Float32 = f32;
pub type _Float64 = f64;
pub type _Float32x = f64;
pub type _Float64x = u128;
extern "C" {
    #[link_name = "\u{1}__isoc99_fscanf"]
    pub fn fscanf1(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_scanf"]
    pub fn scanf1(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_sscanf"]
    pub fn sscanf1(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfscanf(
        __s: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vscanf(
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsscanf(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_vfscanf"]
    pub fn vfscanf1(
        __s: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_vscanf"]
    pub fn vscanf1(
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_vsscanf"]
    pub fn vsscanf1(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetc(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getc(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getc_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar_unlocked() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetc_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputc_unlocked(__c: ::std::os::raw::c_int, __stream: *mut FILE)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putc_unlocked(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar_unlocked(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getw(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putw(__w: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgets(
        __s: *mut ::std::os::raw::c_char,
        __n: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __getdelim(
        __lineptr: *mut *mut ::std::os::raw::c_char,
        __n: *mut usize,
        __delimiter: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    pub fn getdelim(
        __lineptr: *mut *mut ::std::os::raw::c_char,
        __n: *mut usize,
        __delimiter: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    pub fn getline(
        __lineptr: *mut *mut ::std::os::raw::c_char,
        __n: *mut usize,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    pub fn fputs(__s: *const ::std::os::raw::c_char, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn puts(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ungetc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fread(
        __ptr: *mut ::std::os::raw::c_void,
        __size: ::std::os::raw::c_ulong,
        __n: ::std::os::raw::c_ulong,
        __stream: *mut FILE,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn fwrite(
        __ptr: *const ::std::os::raw::c_void,
        __size: ::std::os::raw::c_ulong,
        __n: ::std::os::raw::c_ulong,
        __s: *mut FILE,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn fread_unlocked(
        __ptr: *mut ::std::os::raw::c_void,
        __size: usize,
        __n: usize,
        __stream: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn fwrite_unlocked(
        __ptr: *const ::std::os::raw::c_void,
        __size: usize,
        __n: usize,
        __stream: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn fseek(
        __stream: *mut FILE,
        __off: ::std::os::raw::c_long,
        __whence: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftell(__stream: *mut FILE) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn rewind(__stream: *mut FILE);
}
extern "C" {
    pub fn fseeko(
        __stream: *mut FILE,
        __off: __off_t,
        __whence: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftello(__stream: *mut FILE) -> __off_t;
}
extern "C" {
    pub fn fgetpos(__stream: *mut FILE, __pos: *mut fpos_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fsetpos(__stream: *mut FILE, __pos: *const fpos_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clearerr(__stream: *mut FILE);
}
extern "C" {
    pub fn feof(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ferror(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clearerr_unlocked(__stream: *mut FILE);
}
extern "C" {
    pub fn feof_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ferror_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn perror(__s: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn fileno(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fileno_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pclose(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn popen(
        __command: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn ctermid(__s: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn flockfile(__stream: *mut FILE);
}
extern "C" {
    pub fn ftrylockfile(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn funlockfile(__stream: *mut FILE);
}
extern "C" {
    pub fn __uflow(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __overflow(arg1: *mut FILE, arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
pub type wchar_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct div_t {
    pub quot: ::std::os::raw::c_int,
    pub rem: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ldiv_t {
    pub quot: ::std::os::raw::c_long,
    pub rem: ::std::os::raw::c_long,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lldiv_t {
    pub quot: ::std::os::raw::c_longlong,
    pub rem: ::std::os::raw::c_longlong,
}
extern "C" {
    pub fn __ctype_get_mb_cur_max() -> usize;
}
extern "C" {
    pub fn atof(__nptr: *const ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn atoi(__nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn atol(__nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn atoll(__nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtod(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
    ) -> f64;
}
extern "C" {
    pub fn strtof(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
    ) -> f32;
}
extern "C" {
    pub fn strtold(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
    ) -> u128;
}
extern "C" {
    pub fn strtol(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn strtoul(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strtoq(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtouq(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn strtoll(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtoull(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn l64a(__n: ::std::os::raw::c_long) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn a64l(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
pub type u_char = __u_char;
pub type u_short = __u_short;
pub type u_int = __u_int;
pub type u_long = __u_long;
pub type quad_t = __quad_t;
pub type u_quad_t = __u_quad_t;
pub type fsid_t = __fsid_t;
pub type loff_t = __loff_t;
pub type ino_t = __ino_t;
pub type dev_t = __dev_t;
pub type gid_t = __gid_t;
pub type mode_t = __mode_t;
pub type nlink_t = __nlink_t;
pub type uid_t = __uid_t;
pub type pid_t = __pid_t;
pub type id_t = __id_t;
pub type daddr_t = __daddr_t;
pub type caddr_t = __caddr_t;
pub type key_t = __key_t;
pub type clock_t = __clock_t;
pub type clockid_t = __clockid_t;
pub type time_t = __time_t;
pub type timer_t = __timer_t;
pub type ulong = ::std::os::raw::c_ulong;
pub type ushort = ::std::os::raw::c_ushort;
pub type uint = ::std::os::raw::c_uint;
pub type u_int8_t = __uint8_t;
pub type u_int16_t = __uint16_t;
pub type u_int32_t = __uint32_t;
pub type u_int64_t = __uint64_t;
pub type register_t = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sigset_t {
    pub __val: [::std::os::raw::c_ulong; 16usize],
}
pub type sigset_t = __sigset_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timeval {
    pub tv_sec: __time_t,
    pub tv_usec: __suseconds_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timespec {
    pub tv_sec: __time_t,
    pub tv_nsec: __syscall_slong_t,
}
pub type suseconds_t = __suseconds_t;
pub type __fd_mask = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fd_set {
    pub __fds_bits: [__fd_mask; 16usize],
}
pub type fd_mask = __fd_mask;
extern "C" {
    pub fn select(
        __nfds: ::std::os::raw::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *mut timeval,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pselect(
        __nfds: ::std::os::raw::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *const timespec,
        __sigmask: *const __sigset_t,
    ) -> ::std::os::raw::c_int;
}
pub type blksize_t = __blksize_t;
pub type blkcnt_t = __blkcnt_t;
pub type fsblkcnt_t = __fsblkcnt_t;
pub type fsfilcnt_t = __fsfilcnt_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub union __atomic_wide_counter {
    pub __value64: ::std::os::raw::c_ulonglong,
    pub __value32: __atomic_wide_counter__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __atomic_wide_counter__bindgen_ty_1 {
    pub __low: ::std::os::raw::c_uint,
    pub __high: ::std::os::raw::c_uint,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_internal_list {
    pub __prev: *mut __pthread_internal_list,
    pub __next: *mut __pthread_internal_list,
}
pub type __pthread_list_t = __pthread_internal_list;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_internal_slist {
    pub __next: *mut __pthread_internal_slist,
}
pub type __pthread_slist_t = __pthread_internal_slist;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_mutex_s {
    pub __lock: ::std::os::raw::c_int,
    pub __count: ::std::os::raw::c_uint,
    pub __owner: ::std::os::raw::c_int,
    pub __nusers: ::std::os::raw::c_uint,
    pub __kind: ::std::os::raw::c_int,
    pub __spins: ::std::os::raw::c_short,
    pub __elision: ::std::os::raw::c_short,
    pub __list: __pthread_list_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_rwlock_arch_t {
    pub __readers: ::std::os::raw::c_uint,
    pub __writers: ::std::os::raw::c_uint,
    pub __wrphase_futex: ::std::os::raw::c_uint,
    pub __writers_futex: ::std::os::raw::c_uint,
    pub __pad3: ::std::os::raw::c_uint,
    pub __pad4: ::std::os::raw::c_uint,
    pub __cur_writer: ::std::os::raw::c_int,
    pub __shared: ::std::os::raw::c_int,
    pub __rwelision: ::std::os::raw::c_schar,
    pub __pad1: [::std::os::raw::c_uchar; 7usize],
    pub __pad2: ::std::os::raw::c_ulong,
    pub __flags: ::std::os::raw::c_uint,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __pthread_cond_s {
    pub __wseq: __atomic_wide_counter,
    pub __g1_start: __atomic_wide_counter,
    pub __g_refs: [::std::os::raw::c_uint; 2usize],
    pub __g_size: [::std::os::raw::c_uint; 2usize],
    pub __g1_orig_size: ::std::os::raw::c_uint,
    pub __wrefs: ::std::os::raw::c_uint,
    pub __g_signals: [::std::os::raw::c_uint; 2usize],
}
pub type __tss_t = ::std::os::raw::c_uint;
pub type __thrd_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __once_flag {
    pub __data: ::std::os::raw::c_int,
}
pub type pthread_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutexattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_condattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
}
pub type pthread_key_t = ::std::os::raw::c_uint;
pub type pthread_once_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_attr_t {
    pub __size: [::std::os::raw::c_char; 56usize],
    pub __align: ::std::os::raw::c_long,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutex_t {
    pub __data: __pthread_mutex_s,
    pub __size: [::std::os::raw::c_char; 40usize],
    pub __align: ::std::os::raw::c_long,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_cond_t {
    pub __data: __pthread_cond_s,
    pub __size: [::std::os::raw::c_char; 48usize],
    pub __align: ::std::os::raw::c_longlong,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlock_t {
    pub __data: __pthread_rwlock_arch_t,
    pub __size: [::std::os::raw::c_char; 56usize],
    pub __align: ::std::os::raw::c_long,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlockattr_t {
    pub __size: [::std::os::raw::c_char; 8usize],
    pub __align: ::std::os::raw::c_long,
}
pub type pthread_spinlock_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_barrier_t {
    pub __size: [::std::os::raw::c_char; 32usize],
    pub __align: ::std::os::raw::c_long,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_barrierattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
}
extern "C" {
    pub fn random() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn srandom(__seed: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn initstate(
        __seed: ::std::os::raw::c_uint,
        __statebuf: *mut ::std::os::raw::c_char,
        __statelen: usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn setstate(__statebuf: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct random_data {
    pub fptr: *mut i32,
    pub rptr: *mut i32,
    pub state: *mut i32,
    pub rand_type: ::std::os::raw::c_int,
    pub rand_deg: ::std::os::raw::c_int,
    pub rand_sep: ::std::os::raw::c_int,
    pub end_ptr: *mut i32,
}
extern "C" {
    pub fn random_r(__buf: *mut random_data, __result: *mut i32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn srandom_r(
        __seed: ::std::os::raw::c_uint,
        __buf: *mut random_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn initstate_r(
        __seed: ::std::os::raw::c_uint,
        __statebuf: *mut ::std::os::raw::c_char,
        __statelen: usize,
        __buf: *mut random_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setstate_r(
        __statebuf: *mut ::std::os::raw::c_char,
        __buf: *mut random_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rand() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn srand(__seed: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn rand_r(__seed: *mut ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn drand48() -> f64;
}
extern "C" {
    pub fn erand48(__xsubi: *mut ::std::os::raw::c_ushort) -> f64;
}
extern "C" {
    pub fn lrand48() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn nrand48(__xsubi: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn mrand48() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn jrand48(__xsubi: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn srand48(__seedval: ::std::os::raw::c_long);
}
extern "C" {
    pub fn seed48(__seed16v: *mut ::std::os::raw::c_ushort) -> *mut ::std::os::raw::c_ushort;
}
extern "C" {
    pub fn lcong48(__param: *mut ::std::os::raw::c_ushort);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct drand48_data {
    pub __x: [::std::os::raw::c_ushort; 3usize],
    pub __old_x: [::std::os::raw::c_ushort; 3usize],
    pub __c: ::std::os::raw::c_ushort,
    pub __init: ::std::os::raw::c_ushort,
    pub __a: ::std::os::raw::c_ulonglong,
}
extern "C" {
    pub fn drand48_r(__buffer: *mut drand48_data, __result: *mut f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn erand48_r(
        __xsubi: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lrand48_r(
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nrand48_r(
        __xsubi: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mrand48_r(
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn jrand48_r(
        __xsubi: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn srand48_r(
        __seedval: ::std::os::raw::c_long,
        __buffer: *mut drand48_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn seed48_r(
        __seed16v: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lcong48_r(
        __param: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn arc4random() -> __uint32_t;
}
extern "C" {
    pub fn arc4random_buf(__buf: *mut ::std::os::raw::c_void, __size: usize);
}
extern "C" {
    pub fn arc4random_uniform(__upper_bound: __uint32_t) -> __uint32_t;
}
extern "C" {
    pub fn malloc(__size: ::std::os::raw::c_ulong) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn calloc(
        __nmemb: ::std::os::raw::c_ulong,
        __size: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn realloc(
        __ptr: *mut ::std::os::raw::c_void,
        __size: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn free(__ptr: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn reallocarray(
        __ptr: *mut ::std::os::raw::c_void,
        __nmemb: usize,
        __size: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn alloca(__size: ::std::os::raw::c_ulong) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn valloc(__size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn posix_memalign(
        __memptr: *mut *mut ::std::os::raw::c_void,
        __alignment: usize,
        __size: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aligned_alloc(
        __alignment: ::std::os::raw::c_ulong,
        __size: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn abort() -> !;
}
extern "C" {
    pub fn atexit(__func: ::std::option::Option<unsafe extern "C" fn()>) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn at_quick_exit(
        __func: ::std::option::Option<unsafe extern "C" fn()>,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn on_exit(
        __func: ::std::option::Option<
            unsafe extern "C" fn(
                __status: ::std::os::raw::c_int,
                __arg: *mut ::std::os::raw::c_void,
            ),
        >,
        __arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn exit(__status: ::std::os::raw::c_int) -> !;
}
extern "C" {
    pub fn quick_exit(__status: ::std::os::raw::c_int) -> !;
}
extern "C" {
    pub fn _Exit(__status: ::std::os::raw::c_int) -> !;
}
extern "C" {
    pub fn getenv(__name: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn putenv(__string: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setenv(
        __name: *const ::std::os::raw::c_char,
        __value: *const ::std::os::raw::c_char,
        __replace: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn unsetenv(__name: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clearenv() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mktemp(__template: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn mkstemp(__template: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkstemps(
        __template: *mut ::std::os::raw::c_char,
        __suffixlen: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkdtemp(__template: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn system(__command: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn realpath(
        __name: *const ::std::os::raw::c_char,
        __resolved: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
pub type __compar_fn_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *const ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn bsearch(
        __key: *const ::std::os::raw::c_void,
        __base: *const ::std::os::raw::c_void,
        __nmemb: usize,
        __size: usize,
        __compar: __compar_fn_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn qsort(
        __base: *mut ::std::os::raw::c_void,
        __nmemb: usize,
        __size: usize,
        __compar: __compar_fn_t,
    );
}
extern "C" {
    pub fn abs(__x: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn labs(__x: ::std::os::raw::c_long) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llabs(__x: ::std::os::raw::c_longlong) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn div(__numer: ::std::os::raw::c_int, __denom: ::std::os::raw::c_int) -> div_t;
}
extern "C" {
    pub fn ldiv(__numer: ::std::os::raw::c_long, __denom: ::std::os::raw::c_long) -> ldiv_t;
}
extern "C" {
    pub fn lldiv(
        __numer: ::std::os::raw::c_longlong,
        __denom: ::std::os::raw::c_longlong,
    ) -> lldiv_t;
}
extern "C" {
    pub fn ecvt(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fcvt(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn gcvt(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn qecvt(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn qfcvt(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn qgcvt(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ecvt_r(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fcvt_r(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn qecvt_r(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn qfcvt_r(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mblen(__s: *const ::std::os::raw::c_char, __n: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mbtowc(
        __pwc: *mut wchar_t,
        __s: *const ::std::os::raw::c_char,
        __n: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wctomb(__s: *mut ::std::os::raw::c_char, __wchar: wchar_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mbstowcs(__pwcs: *mut wchar_t, __s: *const ::std::os::raw::c_char, __n: usize) -> usize;
}
extern "C" {
    pub fn wcstombs(__s: *mut ::std::os::raw::c_char, __pwcs: *const wchar_t, __n: usize) -> usize;
}
extern "C" {
    pub fn rpmatch(__response: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getsubopt(
        __optionp: *mut *mut ::std::os::raw::c_char,
        __tokens: *const *mut ::std::os::raw::c_char,
        __valuep: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getloadavg(__loadavg: *mut f64, __nelem: ::std::os::raw::c_int)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __assert_fail(
        __assertion: *const ::std::os::raw::c_char,
        __file: *const ::std::os::raw::c_char,
        __line: ::std::os::raw::c_uint,
        __function: *const ::std::os::raw::c_char,
    ) -> !;
}
extern "C" {
    pub fn __assert_perror_fail(
        __errnum: ::std::os::raw::c_int,
        __file: *const ::std::os::raw::c_char,
        __line: ::std::os::raw::c_uint,
        __function: *const ::std::os::raw::c_char,
    ) -> !;
}
extern "C" {
    pub fn __assert(
        __assertion: *const ::std::os::raw::c_char,
        __file: *const ::std::os::raw::c_char,
        __line: ::std::os::raw::c_int,
    ) -> !;
}
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: ::std::os::raw::c_longlong,
    pub __bindgen_padding_0: u64,
    pub __clang_max_align_nonce2: u128,
}
extern "C" {
    #[doc = " @brief Query the installed library build name.\n\n This function can be used even when the library is not initialized.\n\n @returns Returns a string describing the build version of the library.  The\n string is owned by the library."]
    pub fn amd_dbgapi_get_build_name() -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @brief Query the installed library git hash.\n\n This function can be used even when the library is not initialized.\n\n @returns Returns git hash of the library."]
    pub fn amd_dbgapi_get_git_hash() -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @brief Query the installed library build ID.\n\n This function can be used even when the library is not initialized.\n\n @returns Returns build ID of the library."]
    pub fn amd_dbgapi_get_build_id() -> usize;
}
pub type float_t = f32;
pub type double_t = f64;
extern "C" {
    pub fn __fpclassify(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __signbit(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __isinf(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __finite(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __isnan(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __iseqsig(__x: f64, __y: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __issignaling(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn acos(__x: f64) -> f64;
}
extern "C" {
    pub fn __acos(__x: f64) -> f64;
}
extern "C" {
    pub fn asin(__x: f64) -> f64;
}
extern "C" {
    pub fn __asin(__x: f64) -> f64;
}
extern "C" {
    pub fn atan(__x: f64) -> f64;
}
extern "C" {
    pub fn __atan(__x: f64) -> f64;
}
extern "C" {
    pub fn atan2(__y: f64, __x: f64) -> f64;
}
extern "C" {
    pub fn __atan2(__y: f64, __x: f64) -> f64;
}
extern "C" {
    pub fn cos(__x: f64) -> f64;
}
extern "C" {
    pub fn __cos(__x: f64) -> f64;
}
extern "C" {
    pub fn sin(__x: f64) -> f64;
}
extern "C" {
    pub fn __sin(__x: f64) -> f64;
}
extern "C" {
    pub fn tan(__x: f64) -> f64;
}
extern "C" {
    pub fn __tan(__x: f64) -> f64;
}
extern "C" {
    pub fn cosh(__x: f64) -> f64;
}
extern "C" {
    pub fn __cosh(__x: f64) -> f64;
}
extern "C" {
    pub fn sinh(__x: f64) -> f64;
}
extern "C" {
    pub fn __sinh(__x: f64) -> f64;
}
extern "C" {
    pub fn tanh(__x: f64) -> f64;
}
extern "C" {
    pub fn __tanh(__x: f64) -> f64;
}
extern "C" {
    pub fn acosh(__x: f64) -> f64;
}
extern "C" {
    pub fn __acosh(__x: f64) -> f64;
}
extern "C" {
    pub fn asinh(__x: f64) -> f64;
}
extern "C" {
    pub fn __asinh(__x: f64) -> f64;
}
extern "C" {
    pub fn atanh(__x: f64) -> f64;
}
extern "C" {
    pub fn __atanh(__x: f64) -> f64;
}
extern "C" {
    pub fn exp(__x: f64) -> f64;
}
extern "C" {
    pub fn __exp(__x: f64) -> f64;
}
extern "C" {
    pub fn frexp(__x: f64, __exponent: *mut ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn __frexp(__x: f64, __exponent: *mut ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn ldexp(__x: f64, __exponent: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn __ldexp(__x: f64, __exponent: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn log(__x: f64) -> f64;
}
extern "C" {
    pub fn __log(__x: f64) -> f64;
}
extern "C" {
    pub fn log10(__x: f64) -> f64;
}
extern "C" {
    pub fn __log10(__x: f64) -> f64;
}
extern "C" {
    pub fn modf(__x: f64, __iptr: *mut f64) -> f64;
}
extern "C" {
    pub fn __modf(__x: f64, __iptr: *mut f64) -> f64;
}
extern "C" {
    pub fn expm1(__x: f64) -> f64;
}
extern "C" {
    pub fn __expm1(__x: f64) -> f64;
}
extern "C" {
    pub fn log1p(__x: f64) -> f64;
}
extern "C" {
    pub fn __log1p(__x: f64) -> f64;
}
extern "C" {
    pub fn logb(__x: f64) -> f64;
}
extern "C" {
    pub fn __logb(__x: f64) -> f64;
}
extern "C" {
    pub fn exp2(__x: f64) -> f64;
}
extern "C" {
    pub fn __exp2(__x: f64) -> f64;
}
extern "C" {
    pub fn log2(__x: f64) -> f64;
}
extern "C" {
    pub fn __log2(__x: f64) -> f64;
}
extern "C" {
    pub fn pow(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __pow(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn sqrt(__x: f64) -> f64;
}
extern "C" {
    pub fn __sqrt(__x: f64) -> f64;
}
extern "C" {
    pub fn hypot(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __hypot(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn cbrt(__x: f64) -> f64;
}
extern "C" {
    pub fn __cbrt(__x: f64) -> f64;
}
extern "C" {
    pub fn ceil(__x: f64) -> f64;
}
extern "C" {
    pub fn __ceil(__x: f64) -> f64;
}
extern "C" {
    pub fn fabs(__x: f64) -> f64;
}
extern "C" {
    pub fn __fabs(__x: f64) -> f64;
}
extern "C" {
    pub fn floor(__x: f64) -> f64;
}
extern "C" {
    pub fn __floor(__x: f64) -> f64;
}
extern "C" {
    pub fn fmod(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __fmod(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn isinf(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn finite(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn drem(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __drem(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn significand(__x: f64) -> f64;
}
extern "C" {
    pub fn __significand(__x: f64) -> f64;
}
extern "C" {
    pub fn copysign(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __copysign(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn nan(__tagb: *const ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn __nan(__tagb: *const ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn isnan(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn j0(arg1: f64) -> f64;
}
extern "C" {
    pub fn __j0(arg1: f64) -> f64;
}
extern "C" {
    pub fn j1(arg1: f64) -> f64;
}
extern "C" {
    pub fn __j1(arg1: f64) -> f64;
}
extern "C" {
    pub fn jn(arg1: ::std::os::raw::c_int, arg2: f64) -> f64;
}
extern "C" {
    pub fn __jn(arg1: ::std::os::raw::c_int, arg2: f64) -> f64;
}
extern "C" {
    pub fn y0(arg1: f64) -> f64;
}
extern "C" {
    pub fn __y0(arg1: f64) -> f64;
}
extern "C" {
    pub fn y1(arg1: f64) -> f64;
}
extern "C" {
    pub fn __y1(arg1: f64) -> f64;
}
extern "C" {
    pub fn yn(arg1: ::std::os::raw::c_int, arg2: f64) -> f64;
}
extern "C" {
    pub fn __yn(arg1: ::std::os::raw::c_int, arg2: f64) -> f64;
}
extern "C" {
    pub fn erf(arg1: f64) -> f64;
}
extern "C" {
    pub fn __erf(arg1: f64) -> f64;
}
extern "C" {
    pub fn erfc(arg1: f64) -> f64;
}
extern "C" {
    pub fn __erfc(arg1: f64) -> f64;
}
extern "C" {
    pub fn lgamma(arg1: f64) -> f64;
}
extern "C" {
    pub fn __lgamma(arg1: f64) -> f64;
}
extern "C" {
    pub fn tgamma(arg1: f64) -> f64;
}
extern "C" {
    pub fn __tgamma(arg1: f64) -> f64;
}
extern "C" {
    pub fn gamma(arg1: f64) -> f64;
}
extern "C" {
    pub fn __gamma(arg1: f64) -> f64;
}
extern "C" {
    pub fn lgamma_r(arg1: f64, __signgamp: *mut ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn __lgamma_r(arg1: f64, __signgamp: *mut ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn rint(__x: f64) -> f64;
}
extern "C" {
    pub fn __rint(__x: f64) -> f64;
}
extern "C" {
    pub fn nextafter(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __nextafter(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn nexttoward(__x: f64, __y: u128) -> f64;
}
extern "C" {
    pub fn __nexttoward(__x: f64, __y: u128) -> f64;
}
extern "C" {
    pub fn remainder(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __remainder(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn scalbn(__x: f64, __n: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn __scalbn(__x: f64, __n: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn ilogb(__x: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __ilogb(__x: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scalbln(__x: f64, __n: ::std::os::raw::c_long) -> f64;
}
extern "C" {
    pub fn __scalbln(__x: f64, __n: ::std::os::raw::c_long) -> f64;
}
extern "C" {
    pub fn nearbyint(__x: f64) -> f64;
}
extern "C" {
    pub fn __nearbyint(__x: f64) -> f64;
}
extern "C" {
    pub fn round(__x: f64) -> f64;
}
extern "C" {
    pub fn __round(__x: f64) -> f64;
}
extern "C" {
    pub fn trunc(__x: f64) -> f64;
}
extern "C" {
    pub fn __trunc(__x: f64) -> f64;
}
extern "C" {
    pub fn remquo(__x: f64, __y: f64, __quo: *mut ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn __remquo(__x: f64, __y: f64, __quo: *mut ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn lrint(__x: f64) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn __lrint(__x: f64) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llrint(__x: f64) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn __llrint(__x: f64) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn lround(__x: f64) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn __lround(__x: f64) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llround(__x: f64) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn __llround(__x: f64) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn fdim(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __fdim(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn fmax(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __fmax(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn fmin(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __fmin(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn fma(__x: f64, __y: f64, __z: f64) -> f64;
}
extern "C" {
    pub fn __fma(__x: f64, __y: f64, __z: f64) -> f64;
}
extern "C" {
    pub fn scalb(__x: f64, __n: f64) -> f64;
}
extern "C" {
    pub fn __scalb(__x: f64, __n: f64) -> f64;
}
extern "C" {
    pub fn __fpclassifyf(__value: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __signbitf(__value: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __isinff(__value: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __finitef(__value: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __isnanf(__value: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __iseqsigf(__x: f32, __y: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __issignalingf(__value: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn acosf(__x: f32) -> f32;
}
extern "C" {
    pub fn __acosf(__x: f32) -> f32;
}
extern "C" {
    pub fn asinf(__x: f32) -> f32;
}
extern "C" {
    pub fn __asinf(__x: f32) -> f32;
}
extern "C" {
    pub fn atanf(__x: f32) -> f32;
}
extern "C" {
    pub fn __atanf(__x: f32) -> f32;
}
extern "C" {
    pub fn atan2f(__y: f32, __x: f32) -> f32;
}
extern "C" {
    pub fn __atan2f(__y: f32, __x: f32) -> f32;
}
extern "C" {
    pub fn cosf(__x: f32) -> f32;
}
extern "C" {
    pub fn __cosf(__x: f32) -> f32;
}
extern "C" {
    pub fn sinf(__x: f32) -> f32;
}
extern "C" {
    pub fn __sinf(__x: f32) -> f32;
}
extern "C" {
    pub fn tanf(__x: f32) -> f32;
}
extern "C" {
    pub fn __tanf(__x: f32) -> f32;
}
extern "C" {
    pub fn coshf(__x: f32) -> f32;
}
extern "C" {
    pub fn __coshf(__x: f32) -> f32;
}
extern "C" {
    pub fn sinhf(__x: f32) -> f32;
}
extern "C" {
    pub fn __sinhf(__x: f32) -> f32;
}
extern "C" {
    pub fn tanhf(__x: f32) -> f32;
}
extern "C" {
    pub fn __tanhf(__x: f32) -> f32;
}
extern "C" {
    pub fn acoshf(__x: f32) -> f32;
}
extern "C" {
    pub fn __acoshf(__x: f32) -> f32;
}
extern "C" {
    pub fn asinhf(__x: f32) -> f32;
}
extern "C" {
    pub fn __asinhf(__x: f32) -> f32;
}
extern "C" {
    pub fn atanhf(__x: f32) -> f32;
}
extern "C" {
    pub fn __atanhf(__x: f32) -> f32;
}
extern "C" {
    pub fn expf(__x: f32) -> f32;
}
extern "C" {
    pub fn __expf(__x: f32) -> f32;
}
extern "C" {
    pub fn frexpf(__x: f32, __exponent: *mut ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn __frexpf(__x: f32, __exponent: *mut ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn ldexpf(__x: f32, __exponent: ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn __ldexpf(__x: f32, __exponent: ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn logf(__x: f32) -> f32;
}
extern "C" {
    pub fn __logf(__x: f32) -> f32;
}
extern "C" {
    pub fn log10f(__x: f32) -> f32;
}
extern "C" {
    pub fn __log10f(__x: f32) -> f32;
}
extern "C" {
    pub fn modff(__x: f32, __iptr: *mut f32) -> f32;
}
extern "C" {
    pub fn __modff(__x: f32, __iptr: *mut f32) -> f32;
}
extern "C" {
    pub fn expm1f(__x: f32) -> f32;
}
extern "C" {
    pub fn __expm1f(__x: f32) -> f32;
}
extern "C" {
    pub fn log1pf(__x: f32) -> f32;
}
extern "C" {
    pub fn __log1pf(__x: f32) -> f32;
}
extern "C" {
    pub fn logbf(__x: f32) -> f32;
}
extern "C" {
    pub fn __logbf(__x: f32) -> f32;
}
extern "C" {
    pub fn exp2f(__x: f32) -> f32;
}
extern "C" {
    pub fn __exp2f(__x: f32) -> f32;
}
extern "C" {
    pub fn log2f(__x: f32) -> f32;
}
extern "C" {
    pub fn __log2f(__x: f32) -> f32;
}
extern "C" {
    pub fn powf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __powf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn sqrtf(__x: f32) -> f32;
}
extern "C" {
    pub fn __sqrtf(__x: f32) -> f32;
}
extern "C" {
    pub fn hypotf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __hypotf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn cbrtf(__x: f32) -> f32;
}
extern "C" {
    pub fn __cbrtf(__x: f32) -> f32;
}
extern "C" {
    pub fn ceilf(__x: f32) -> f32;
}
extern "C" {
    pub fn __ceilf(__x: f32) -> f32;
}
extern "C" {
    pub fn fabsf(__x: f32) -> f32;
}
extern "C" {
    pub fn __fabsf(__x: f32) -> f32;
}
extern "C" {
    pub fn floorf(__x: f32) -> f32;
}
extern "C" {
    pub fn __floorf(__x: f32) -> f32;
}
extern "C" {
    pub fn fmodf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __fmodf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn isinff(__value: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn finitef(__value: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dremf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __dremf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn significandf(__x: f32) -> f32;
}
extern "C" {
    pub fn __significandf(__x: f32) -> f32;
}
extern "C" {
    pub fn copysignf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __copysignf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn nanf(__tagb: *const ::std::os::raw::c_char) -> f32;
}
extern "C" {
    pub fn __nanf(__tagb: *const ::std::os::raw::c_char) -> f32;
}
extern "C" {
    pub fn isnanf(__value: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn j0f(arg1: f32) -> f32;
}
extern "C" {
    pub fn __j0f(arg1: f32) -> f32;
}
extern "C" {
    pub fn j1f(arg1: f32) -> f32;
}
extern "C" {
    pub fn __j1f(arg1: f32) -> f32;
}
extern "C" {
    pub fn jnf(arg1: ::std::os::raw::c_int, arg2: f32) -> f32;
}
extern "C" {
    pub fn __jnf(arg1: ::std::os::raw::c_int, arg2: f32) -> f32;
}
extern "C" {
    pub fn y0f(arg1: f32) -> f32;
}
extern "C" {
    pub fn __y0f(arg1: f32) -> f32;
}
extern "C" {
    pub fn y1f(arg1: f32) -> f32;
}
extern "C" {
    pub fn __y1f(arg1: f32) -> f32;
}
extern "C" {
    pub fn ynf(arg1: ::std::os::raw::c_int, arg2: f32) -> f32;
}
extern "C" {
    pub fn __ynf(arg1: ::std::os::raw::c_int, arg2: f32) -> f32;
}
extern "C" {
    pub fn erff(arg1: f32) -> f32;
}
extern "C" {
    pub fn __erff(arg1: f32) -> f32;
}
extern "C" {
    pub fn erfcf(arg1: f32) -> f32;
}
extern "C" {
    pub fn __erfcf(arg1: f32) -> f32;
}
extern "C" {
    pub fn lgammaf(arg1: f32) -> f32;
}
extern "C" {
    pub fn __lgammaf(arg1: f32) -> f32;
}
extern "C" {
    pub fn tgammaf(arg1: f32) -> f32;
}
extern "C" {
    pub fn __tgammaf(arg1: f32) -> f32;
}
extern "C" {
    pub fn gammaf(arg1: f32) -> f32;
}
extern "C" {
    pub fn __gammaf(arg1: f32) -> f32;
}
extern "C" {
    pub fn lgammaf_r(arg1: f32, __signgamp: *mut ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn __lgammaf_r(arg1: f32, __signgamp: *mut ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn rintf(__x: f32) -> f32;
}
extern "C" {
    pub fn __rintf(__x: f32) -> f32;
}
extern "C" {
    pub fn nextafterf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __nextafterf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn nexttowardf(__x: f32, __y: u128) -> f32;
}
extern "C" {
    pub fn __nexttowardf(__x: f32, __y: u128) -> f32;
}
extern "C" {
    pub fn remainderf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __remainderf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn scalbnf(__x: f32, __n: ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn __scalbnf(__x: f32, __n: ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn ilogbf(__x: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __ilogbf(__x: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scalblnf(__x: f32, __n: ::std::os::raw::c_long) -> f32;
}
extern "C" {
    pub fn __scalblnf(__x: f32, __n: ::std::os::raw::c_long) -> f32;
}
extern "C" {
    pub fn nearbyintf(__x: f32) -> f32;
}
extern "C" {
    pub fn __nearbyintf(__x: f32) -> f32;
}
extern "C" {
    pub fn roundf(__x: f32) -> f32;
}
extern "C" {
    pub fn __roundf(__x: f32) -> f32;
}
extern "C" {
    pub fn truncf(__x: f32) -> f32;
}
extern "C" {
    pub fn __truncf(__x: f32) -> f32;
}
extern "C" {
    pub fn remquof(__x: f32, __y: f32, __quo: *mut ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn __remquof(__x: f32, __y: f32, __quo: *mut ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn lrintf(__x: f32) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn __lrintf(__x: f32) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llrintf(__x: f32) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn __llrintf(__x: f32) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn lroundf(__x: f32) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn __lroundf(__x: f32) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llroundf(__x: f32) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn __llroundf(__x: f32) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn fdimf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __fdimf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn fmaxf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __fmaxf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn fminf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __fminf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn fmaf(__x: f32, __y: f32, __z: f32) -> f32;
}
extern "C" {
    pub fn __fmaf(__x: f32, __y: f32, __z: f32) -> f32;
}
extern "C" {
    pub fn scalbf(__x: f32, __n: f32) -> f32;
}
extern "C" {
    pub fn __scalbf(__x: f32, __n: f32) -> f32;
}
extern "C" {
    pub fn __fpclassifyl(__value: u128) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __signbitl(__value: u128) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __isinfl(__value: u128) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __finitel(__value: u128) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __isnanl(__value: u128) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __iseqsigl(__x: u128, __y: u128) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __issignalingl(__value: u128) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn acosl(__x: u128) -> u128;
}
extern "C" {
    pub fn __acosl(__x: u128) -> u128;
}
extern "C" {
    pub fn asinl(__x: u128) -> u128;
}
extern "C" {
    pub fn __asinl(__x: u128) -> u128;
}
extern "C" {
    pub fn atanl(__x: u128) -> u128;
}
extern "C" {
    pub fn __atanl(__x: u128) -> u128;
}
extern "C" {
    pub fn atan2l(__y: u128, __x: u128) -> u128;
}
extern "C" {
    pub fn __atan2l(__y: u128, __x: u128) -> u128;
}
extern "C" {
    pub fn cosl(__x: u128) -> u128;
}
extern "C" {
    pub fn __cosl(__x: u128) -> u128;
}
extern "C" {
    pub fn sinl(__x: u128) -> u128;
}
extern "C" {
    pub fn __sinl(__x: u128) -> u128;
}
extern "C" {
    pub fn tanl(__x: u128) -> u128;
}
extern "C" {
    pub fn __tanl(__x: u128) -> u128;
}
extern "C" {
    pub fn coshl(__x: u128) -> u128;
}
extern "C" {
    pub fn __coshl(__x: u128) -> u128;
}
extern "C" {
    pub fn sinhl(__x: u128) -> u128;
}
extern "C" {
    pub fn __sinhl(__x: u128) -> u128;
}
extern "C" {
    pub fn tanhl(__x: u128) -> u128;
}
extern "C" {
    pub fn __tanhl(__x: u128) -> u128;
}
extern "C" {
    pub fn acoshl(__x: u128) -> u128;
}
extern "C" {
    pub fn __acoshl(__x: u128) -> u128;
}
extern "C" {
    pub fn asinhl(__x: u128) -> u128;
}
extern "C" {
    pub fn __asinhl(__x: u128) -> u128;
}
extern "C" {
    pub fn atanhl(__x: u128) -> u128;
}
extern "C" {
    pub fn __atanhl(__x: u128) -> u128;
}
extern "C" {
    pub fn expl(__x: u128) -> u128;
}
extern "C" {
    pub fn __expl(__x: u128) -> u128;
}
extern "C" {
    pub fn frexpl(__x: u128, __exponent: *mut ::std::os::raw::c_int) -> u128;
}
extern "C" {
    pub fn __frexpl(__x: u128, __exponent: *mut ::std::os::raw::c_int) -> u128;
}
extern "C" {
    pub fn ldexpl(__x: u128, __exponent: ::std::os::raw::c_int) -> u128;
}
extern "C" {
    pub fn __ldexpl(__x: u128, __exponent: ::std::os::raw::c_int) -> u128;
}
extern "C" {
    pub fn logl(__x: u128) -> u128;
}
extern "C" {
    pub fn __logl(__x: u128) -> u128;
}
extern "C" {
    pub fn log10l(__x: u128) -> u128;
}
extern "C" {
    pub fn __log10l(__x: u128) -> u128;
}
extern "C" {
    pub fn modfl(__x: u128, __iptr: *mut u128) -> u128;
}
extern "C" {
    pub fn __modfl(__x: u128, __iptr: *mut u128) -> u128;
}
extern "C" {
    pub fn expm1l(__x: u128) -> u128;
}
extern "C" {
    pub fn __expm1l(__x: u128) -> u128;
}
extern "C" {
    pub fn log1pl(__x: u128) -> u128;
}
extern "C" {
    pub fn __log1pl(__x: u128) -> u128;
}
extern "C" {
    pub fn logbl(__x: u128) -> u128;
}
extern "C" {
    pub fn __logbl(__x: u128) -> u128;
}
extern "C" {
    pub fn exp2l(__x: u128) -> u128;
}
extern "C" {
    pub fn __exp2l(__x: u128) -> u128;
}
extern "C" {
    pub fn log2l(__x: u128) -> u128;
}
extern "C" {
    pub fn __log2l(__x: u128) -> u128;
}
extern "C" {
    pub fn powl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn __powl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn sqrtl(__x: u128) -> u128;
}
extern "C" {
    pub fn __sqrtl(__x: u128) -> u128;
}
extern "C" {
    pub fn hypotl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn __hypotl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn cbrtl(__x: u128) -> u128;
}
extern "C" {
    pub fn __cbrtl(__x: u128) -> u128;
}
extern "C" {
    pub fn ceill(__x: u128) -> u128;
}
extern "C" {
    pub fn __ceill(__x: u128) -> u128;
}
extern "C" {
    pub fn fabsl(__x: u128) -> u128;
}
extern "C" {
    pub fn __fabsl(__x: u128) -> u128;
}
extern "C" {
    pub fn floorl(__x: u128) -> u128;
}
extern "C" {
    pub fn __floorl(__x: u128) -> u128;
}
extern "C" {
    pub fn fmodl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn __fmodl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn isinfl(__value: u128) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn finitel(__value: u128) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dreml(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn __dreml(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn significandl(__x: u128) -> u128;
}
extern "C" {
    pub fn __significandl(__x: u128) -> u128;
}
extern "C" {
    pub fn copysignl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn __copysignl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn nanl(__tagb: *const ::std::os::raw::c_char) -> u128;
}
extern "C" {
    pub fn __nanl(__tagb: *const ::std::os::raw::c_char) -> u128;
}
extern "C" {
    pub fn isnanl(__value: u128) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn j0l(arg1: u128) -> u128;
}
extern "C" {
    pub fn __j0l(arg1: u128) -> u128;
}
extern "C" {
    pub fn j1l(arg1: u128) -> u128;
}
extern "C" {
    pub fn __j1l(arg1: u128) -> u128;
}
extern "C" {
    pub fn jnl(arg1: ::std::os::raw::c_int, arg2: u128) -> u128;
}
extern "C" {
    pub fn __jnl(arg1: ::std::os::raw::c_int, arg2: u128) -> u128;
}
extern "C" {
    pub fn y0l(arg1: u128) -> u128;
}
extern "C" {
    pub fn __y0l(arg1: u128) -> u128;
}
extern "C" {
    pub fn y1l(arg1: u128) -> u128;
}
extern "C" {
    pub fn __y1l(arg1: u128) -> u128;
}
extern "C" {
    pub fn ynl(arg1: ::std::os::raw::c_int, arg2: u128) -> u128;
}
extern "C" {
    pub fn __ynl(arg1: ::std::os::raw::c_int, arg2: u128) -> u128;
}
extern "C" {
    pub fn erfl(arg1: u128) -> u128;
}
extern "C" {
    pub fn __erfl(arg1: u128) -> u128;
}
extern "C" {
    pub fn erfcl(arg1: u128) -> u128;
}
extern "C" {
    pub fn __erfcl(arg1: u128) -> u128;
}
extern "C" {
    pub fn lgammal(arg1: u128) -> u128;
}
extern "C" {
    pub fn __lgammal(arg1: u128) -> u128;
}
extern "C" {
    pub fn tgammal(arg1: u128) -> u128;
}
extern "C" {
    pub fn __tgammal(arg1: u128) -> u128;
}
extern "C" {
    pub fn gammal(arg1: u128) -> u128;
}
extern "C" {
    pub fn __gammal(arg1: u128) -> u128;
}
extern "C" {
    pub fn lgammal_r(arg1: u128, __signgamp: *mut ::std::os::raw::c_int) -> u128;
}
extern "C" {
    pub fn __lgammal_r(arg1: u128, __signgamp: *mut ::std::os::raw::c_int) -> u128;
}
extern "C" {
    pub fn rintl(__x: u128) -> u128;
}
extern "C" {
    pub fn __rintl(__x: u128) -> u128;
}
extern "C" {
    pub fn nextafterl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn __nextafterl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn nexttowardl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn __nexttowardl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn remainderl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn __remainderl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn scalbnl(__x: u128, __n: ::std::os::raw::c_int) -> u128;
}
extern "C" {
    pub fn __scalbnl(__x: u128, __n: ::std::os::raw::c_int) -> u128;
}
extern "C" {
    pub fn ilogbl(__x: u128) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __ilogbl(__x: u128) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scalblnl(__x: u128, __n: ::std::os::raw::c_long) -> u128;
}
extern "C" {
    pub fn __scalblnl(__x: u128, __n: ::std::os::raw::c_long) -> u128;
}
extern "C" {
    pub fn nearbyintl(__x: u128) -> u128;
}
extern "C" {
    pub fn __nearbyintl(__x: u128) -> u128;
}
extern "C" {
    pub fn roundl(__x: u128) -> u128;
}
extern "C" {
    pub fn __roundl(__x: u128) -> u128;
}
extern "C" {
    pub fn truncl(__x: u128) -> u128;
}
extern "C" {
    pub fn __truncl(__x: u128) -> u128;
}
extern "C" {
    pub fn remquol(__x: u128, __y: u128, __quo: *mut ::std::os::raw::c_int) -> u128;
}
extern "C" {
    pub fn __remquol(__x: u128, __y: u128, __quo: *mut ::std::os::raw::c_int) -> u128;
}
extern "C" {
    pub fn lrintl(__x: u128) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn __lrintl(__x: u128) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llrintl(__x: u128) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn __llrintl(__x: u128) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn lroundl(__x: u128) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn __lroundl(__x: u128) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llroundl(__x: u128) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn __llroundl(__x: u128) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn fdiml(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn __fdiml(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn fmaxl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn __fmaxl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn fminl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn __fminl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn fmal(__x: u128, __y: u128, __z: u128) -> u128;
}
extern "C" {
    pub fn __fmal(__x: u128, __y: u128, __z: u128) -> u128;
}
extern "C" {
    pub fn scalbl(__x: u128, __n: u128) -> u128;
}
extern "C" {
    pub fn __scalbl(__x: u128, __n: u128) -> u128;
}
extern "C" {
    pub static mut signgam: ::std::os::raw::c_int;
}
pub const FP_NAN: _bindgen_ty_1 = _bindgen_ty_1::FP_NAN;
pub const FP_INFINITE: _bindgen_ty_1 = _bindgen_ty_1::FP_INFINITE;
pub const FP_ZERO: _bindgen_ty_1 = _bindgen_ty_1::FP_ZERO;
pub const FP_SUBNORMAL: _bindgen_ty_1 = _bindgen_ty_1::FP_SUBNORMAL;
pub const FP_NORMAL: _bindgen_ty_1 = _bindgen_ty_1::FP_NORMAL;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _bindgen_ty_1 {
    FP_NAN = 0,
    FP_INFINITE = 1,
    FP_ZERO = 2,
    FP_SUBNORMAL = 3,
    FP_NORMAL = 4,
}
extern "C" {
    pub fn memcpy(
        __dest: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memmove(
        __dest: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memccpy(
        __dest: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memset(
        __s: *mut ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memcmp(
        __s1: *const ::std::os::raw::c_void,
        __s2: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __memcmpeq(
        __s1: *const ::std::os::raw::c_void,
        __s2: *const ::std::os::raw::c_void,
        __n: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn memchr(
        __s: *const ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn strcpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strncpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcat(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strncat(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strncmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcoll(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strxfrm(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_struct {
    pub __locales: [*mut __locale_data; 13usize],
    pub __ctype_b: *const ::std::os::raw::c_ushort,
    pub __ctype_tolower: *const ::std::os::raw::c_int,
    pub __ctype_toupper: *const ::std::os::raw::c_int,
    pub __names: [*const ::std::os::raw::c_char; 13usize],
}
pub type __locale_t = *mut __locale_struct;
pub type locale_t = __locale_t;
extern "C" {
    pub fn strcoll_l(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __l: locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strxfrm_l(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: usize,
        __l: locale_t,
    ) -> usize;
}
extern "C" {
    pub fn strdup(__s: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strndup(
        __string: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strchr(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strrchr(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strchrnul(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcspn(
        __s: *const ::std::os::raw::c_char,
        __reject: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strspn(
        __s: *const ::std::os::raw::c_char,
        __accept: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strpbrk(
        __s: *const ::std::os::raw::c_char,
        __accept: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strstr(
        __haystack: *const ::std::os::raw::c_char,
        __needle: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strtok(
        __s: *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __strtok_r(
        __s: *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
        __save_ptr: *mut *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strtok_r(
        __s: *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
        __save_ptr: *mut *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcasestr(
        __haystack: *const ::std::os::raw::c_char,
        __needle: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn memmem(
        __haystack: *const ::std::os::raw::c_void,
        __haystacklen: usize,
        __needle: *const ::std::os::raw::c_void,
        __needlelen: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn __mempcpy(
        __dest: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __n: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn mempcpy(
        __dest: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn strlen(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strnlen(__string: *const ::std::os::raw::c_char, __maxlen: usize) -> usize;
}
extern "C" {
    pub fn strerror(__errnum: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}__xpg_strerror_r"]
    pub fn strerror_r(
        __errnum: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __buflen: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strerror_l(
        __errnum: ::std::os::raw::c_int,
        __l: locale_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn bcmp(
        __s1: *const ::std::os::raw::c_void,
        __s2: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bcopy(
        __src: *const ::std::os::raw::c_void,
        __dest: *mut ::std::os::raw::c_void,
        __n: usize,
    );
}
extern "C" {
    pub fn bzero(__s: *mut ::std::os::raw::c_void, __n: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn index(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn rindex(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ffs(__i: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ffsl(__l: ::std::os::raw::c_long) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ffsll(__ll: ::std::os::raw::c_longlong) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcasecmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strncasecmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcasecmp_l(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __loc: locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strncasecmp_l(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __n: usize,
        __loc: locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn explicit_bzero(__s: *mut ::std::os::raw::c_void, __n: usize);
}
extern "C" {
    pub fn strsep(
        __stringp: *mut *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strsignal(__sig: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __stpcpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn stpcpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __stpncpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn stpncpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strlcpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strlcat(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
pub const HIP_SUCCESS: _bindgen_ty_2 = _bindgen_ty_2::HIP_SUCCESS;
pub const HIP_ERROR_INVALID_VALUE: _bindgen_ty_2 = _bindgen_ty_2::HIP_ERROR_INVALID_VALUE;
pub const HIP_ERROR_NOT_INITIALIZED: _bindgen_ty_2 = _bindgen_ty_2::HIP_ERROR_NOT_INITIALIZED;
pub const HIP_ERROR_LAUNCH_OUT_OF_RESOURCES: _bindgen_ty_2 =
    _bindgen_ty_2::HIP_ERROR_LAUNCH_OUT_OF_RESOURCES;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _bindgen_ty_2 {
    HIP_SUCCESS = 0,
    HIP_ERROR_INVALID_VALUE = 1,
    HIP_ERROR_NOT_INITIALIZED = 2,
    HIP_ERROR_LAUNCH_OUT_OF_RESOURCES = 3,
}
#[doc = " @defgroup GlobalDefs Global enum and defines\n @{\n\n/\n/**\n hipDeviceArch_t\n"]
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct hipDeviceArch_t {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 3usize]>,
    pub __bindgen_padding_0: u8,
}
impl hipDeviceArch_t {
    #[inline]
    pub fn hasGlobalInt32Atomics(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hasGlobalInt32Atomics(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hasGlobalFloatAtomicExch(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hasGlobalFloatAtomicExch(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hasSharedInt32Atomics(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hasSharedInt32Atomics(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hasSharedFloatAtomicExch(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hasSharedFloatAtomicExch(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hasFloatAtomicAdd(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hasFloatAtomicAdd(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hasGlobalInt64Atomics(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hasGlobalInt64Atomics(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hasSharedInt64Atomics(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hasSharedInt64Atomics(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hasDoubles(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hasDoubles(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hasWarpVote(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hasWarpVote(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hasWarpBallot(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hasWarpBallot(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hasWarpShuffle(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hasWarpShuffle(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hasFunnelShift(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hasFunnelShift(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hasThreadFenceSystem(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hasThreadFenceSystem(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hasSyncThreadsExt(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hasSyncThreadsExt(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hasSurfaceFuncs(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hasSurfaceFuncs(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn has3dGrid(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_has3dGrid(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hasDynamicParallelism(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hasDynamicParallelism(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        hasGlobalInt32Atomics: ::std::os::raw::c_uint,
        hasGlobalFloatAtomicExch: ::std::os::raw::c_uint,
        hasSharedInt32Atomics: ::std::os::raw::c_uint,
        hasSharedFloatAtomicExch: ::std::os::raw::c_uint,
        hasFloatAtomicAdd: ::std::os::raw::c_uint,
        hasGlobalInt64Atomics: ::std::os::raw::c_uint,
        hasSharedInt64Atomics: ::std::os::raw::c_uint,
        hasDoubles: ::std::os::raw::c_uint,
        hasWarpVote: ::std::os::raw::c_uint,
        hasWarpBallot: ::std::os::raw::c_uint,
        hasWarpShuffle: ::std::os::raw::c_uint,
        hasFunnelShift: ::std::os::raw::c_uint,
        hasThreadFenceSystem: ::std::os::raw::c_uint,
        hasSyncThreadsExt: ::std::os::raw::c_uint,
        hasSurfaceFuncs: ::std::os::raw::c_uint,
        has3dGrid: ::std::os::raw::c_uint,
        hasDynamicParallelism: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 3usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 3usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let hasGlobalInt32Atomics: u32 =
                unsafe { ::std::mem::transmute(hasGlobalInt32Atomics) };
            hasGlobalInt32Atomics as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let hasGlobalFloatAtomicExch: u32 =
                unsafe { ::std::mem::transmute(hasGlobalFloatAtomicExch) };
            hasGlobalFloatAtomicExch as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let hasSharedInt32Atomics: u32 =
                unsafe { ::std::mem::transmute(hasSharedInt32Atomics) };
            hasSharedInt32Atomics as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let hasSharedFloatAtomicExch: u32 =
                unsafe { ::std::mem::transmute(hasSharedFloatAtomicExch) };
            hasSharedFloatAtomicExch as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let hasFloatAtomicAdd: u32 = unsafe { ::std::mem::transmute(hasFloatAtomicAdd) };
            hasFloatAtomicAdd as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let hasGlobalInt64Atomics: u32 =
                unsafe { ::std::mem::transmute(hasGlobalInt64Atomics) };
            hasGlobalInt64Atomics as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let hasSharedInt64Atomics: u32 =
                unsafe { ::std::mem::transmute(hasSharedInt64Atomics) };
            hasSharedInt64Atomics as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let hasDoubles: u32 = unsafe { ::std::mem::transmute(hasDoubles) };
            hasDoubles as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let hasWarpVote: u32 = unsafe { ::std::mem::transmute(hasWarpVote) };
            hasWarpVote as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let hasWarpBallot: u32 = unsafe { ::std::mem::transmute(hasWarpBallot) };
            hasWarpBallot as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let hasWarpShuffle: u32 = unsafe { ::std::mem::transmute(hasWarpShuffle) };
            hasWarpShuffle as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let hasFunnelShift: u32 = unsafe { ::std::mem::transmute(hasFunnelShift) };
            hasFunnelShift as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let hasThreadFenceSystem: u32 = unsafe { ::std::mem::transmute(hasThreadFenceSystem) };
            hasThreadFenceSystem as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let hasSyncThreadsExt: u32 = unsafe { ::std::mem::transmute(hasSyncThreadsExt) };
            hasSyncThreadsExt as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let hasSurfaceFuncs: u32 = unsafe { ::std::mem::transmute(hasSurfaceFuncs) };
            hasSurfaceFuncs as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let has3dGrid: u32 = unsafe { ::std::mem::transmute(has3dGrid) };
            has3dGrid as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let hasDynamicParallelism: u32 =
                unsafe { ::std::mem::transmute(hasDynamicParallelism) };
            hasDynamicParallelism as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hipUUID_t {
    pub bytes: [::std::os::raw::c_char; 16usize],
}
pub type hipUUID = hipUUID_t;
#[doc = " hipDeviceProp\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hipDeviceProp_tR0600 {
    #[doc = "< Device name."]
    pub name: [::std::os::raw::c_char; 256usize],
    #[doc = "< UUID of a device"]
    pub uuid: hipUUID,
    #[doc = "< 8-byte unique identifier. Only valid on windows"]
    pub luid: [::std::os::raw::c_char; 8usize],
    #[doc = "< LUID node mask"]
    pub luidDeviceNodeMask: ::std::os::raw::c_uint,
    #[doc = "< Size of global memory region (in bytes)."]
    pub totalGlobalMem: usize,
    #[doc = "< Size of shared memory region (in bytes)."]
    pub sharedMemPerBlock: usize,
    #[doc = "< Registers per block."]
    pub regsPerBlock: ::std::os::raw::c_int,
    #[doc = "< Warp size."]
    pub warpSize: ::std::os::raw::c_int,
    #[doc = "< Maximum pitch in bytes allowed by memory copies\n< pitched memory"]
    pub memPitch: usize,
    #[doc = "< Max work items per work group or workgroup max size."]
    pub maxThreadsPerBlock: ::std::os::raw::c_int,
    #[doc = "< Max number of threads in each dimension (XYZ) of a block."]
    pub maxThreadsDim: [::std::os::raw::c_int; 3usize],
    #[doc = "< Max grid dimensions (XYZ)."]
    pub maxGridSize: [::std::os::raw::c_int; 3usize],
    #[doc = "< Max clock frequency of the multiProcessors in khz."]
    pub clockRate: ::std::os::raw::c_int,
    #[doc = "< Size of shared memory region (in bytes)."]
    pub totalConstMem: usize,
    #[doc = "< Major compute capability.  On HCC, this is an approximation and features may\n< differ from CUDA CC.  See the arch feature flags for portable ways to query\n< feature caps."]
    pub major: ::std::os::raw::c_int,
    #[doc = "< Minor compute capability.  On HCC, this is an approximation and features may\n< differ from CUDA CC.  See the arch feature flags for portable ways to query\n< feature caps."]
    pub minor: ::std::os::raw::c_int,
    #[doc = "< Alignment requirement for textures"]
    pub textureAlignment: usize,
    #[doc = "< Pitch alignment requirement for texture references bound to"]
    pub texturePitchAlignment: usize,
    #[doc = "< Deprecated. Use asyncEngineCount instead"]
    pub deviceOverlap: ::std::os::raw::c_int,
    #[doc = "< Number of multi-processors (compute units)."]
    pub multiProcessorCount: ::std::os::raw::c_int,
    #[doc = "< Run time limit for kernels executed on the device"]
    pub kernelExecTimeoutEnabled: ::std::os::raw::c_int,
    #[doc = "< APU vs dGPU"]
    pub integrated: ::std::os::raw::c_int,
    #[doc = "< Check whether HIP can map host memory"]
    pub canMapHostMemory: ::std::os::raw::c_int,
    #[doc = "< Compute mode."]
    pub computeMode: ::std::os::raw::c_int,
    #[doc = "< Maximum number of elements in 1D images"]
    pub maxTexture1D: ::std::os::raw::c_int,
    #[doc = "< Maximum 1D mipmap texture size"]
    pub maxTexture1DMipmap: ::std::os::raw::c_int,
    #[doc = "< Maximum size for 1D textures bound to linear memory"]
    pub maxTexture1DLinear: ::std::os::raw::c_int,
    #[doc = "< Maximum dimensions (width, height) of 2D images, in image elements"]
    pub maxTexture2D: [::std::os::raw::c_int; 2usize],
    #[doc = "< Maximum number of elements in 2D array mipmap of images"]
    pub maxTexture2DMipmap: [::std::os::raw::c_int; 2usize],
    #[doc = "< Maximum 2D tex dimensions if tex are bound to pitched memory"]
    pub maxTexture2DLinear: [::std::os::raw::c_int; 3usize],
    #[doc = "< Maximum 2D tex dimensions if gather has to be performed"]
    pub maxTexture2DGather: [::std::os::raw::c_int; 2usize],
    #[doc = "< Maximum dimensions (width, height, depth) of 3D images, in image\n< elements"]
    pub maxTexture3D: [::std::os::raw::c_int; 3usize],
    #[doc = "< Maximum alternate 3D texture dims"]
    pub maxTexture3DAlt: [::std::os::raw::c_int; 3usize],
    #[doc = "< Maximum cubemap texture dims"]
    pub maxTextureCubemap: ::std::os::raw::c_int,
    #[doc = "< Maximum number of elements in 1D array images"]
    pub maxTexture1DLayered: [::std::os::raw::c_int; 2usize],
    #[doc = "< Maximum number of elements in 2D array images"]
    pub maxTexture2DLayered: [::std::os::raw::c_int; 3usize],
    #[doc = "< Maximum cubemaps layered texture dims"]
    pub maxTextureCubemapLayered: [::std::os::raw::c_int; 2usize],
    #[doc = "< Maximum 1D surface size"]
    pub maxSurface1D: ::std::os::raw::c_int,
    #[doc = "< Maximum 2D surface size"]
    pub maxSurface2D: [::std::os::raw::c_int; 2usize],
    #[doc = "< Maximum 3D surface size"]
    pub maxSurface3D: [::std::os::raw::c_int; 3usize],
    #[doc = "< Maximum 1D layered surface size"]
    pub maxSurface1DLayered: [::std::os::raw::c_int; 2usize],
    #[doc = "< Maximum 2D layared surface size"]
    pub maxSurface2DLayered: [::std::os::raw::c_int; 3usize],
    #[doc = "< Maximum cubemap surface size"]
    pub maxSurfaceCubemap: ::std::os::raw::c_int,
    #[doc = "< Maximum cubemap layered surface size"]
    pub maxSurfaceCubemapLayered: [::std::os::raw::c_int; 2usize],
    #[doc = "< Alignment requirement for surface"]
    pub surfaceAlignment: usize,
    #[doc = "< Device can possibly execute multiple kernels concurrently."]
    pub concurrentKernels: ::std::os::raw::c_int,
    #[doc = "< Device has ECC support enabled"]
    pub ECCEnabled: ::std::os::raw::c_int,
    #[doc = "< PCI Bus ID."]
    pub pciBusID: ::std::os::raw::c_int,
    #[doc = "< PCI Device ID."]
    pub pciDeviceID: ::std::os::raw::c_int,
    #[doc = "< PCI Domain ID"]
    pub pciDomainID: ::std::os::raw::c_int,
    #[doc = "< 1:If device is Tesla device using TCC driver, else 0"]
    pub tccDriver: ::std::os::raw::c_int,
    #[doc = "< Number of async engines"]
    pub asyncEngineCount: ::std::os::raw::c_int,
    #[doc = "< Does device and host share unified address space"]
    pub unifiedAddressing: ::std::os::raw::c_int,
    #[doc = "< Max global memory clock frequency in khz."]
    pub memoryClockRate: ::std::os::raw::c_int,
    #[doc = "< Global memory bus width in bits."]
    pub memoryBusWidth: ::std::os::raw::c_int,
    #[doc = "< L2 cache size."]
    pub l2CacheSize: ::std::os::raw::c_int,
    #[doc = "< Device's max L2 persisting lines in bytes"]
    pub persistingL2CacheMaxSize: ::std::os::raw::c_int,
    #[doc = "< Maximum resident threads per multi-processor."]
    pub maxThreadsPerMultiProcessor: ::std::os::raw::c_int,
    #[doc = "< Device supports stream priority"]
    pub streamPrioritiesSupported: ::std::os::raw::c_int,
    #[doc = "< Indicates globals are cached in L1"]
    pub globalL1CacheSupported: ::std::os::raw::c_int,
    #[doc = "< Locals are cahced in L1"]
    pub localL1CacheSupported: ::std::os::raw::c_int,
    #[doc = "< Amount of shared memory available per multiprocessor."]
    pub sharedMemPerMultiprocessor: usize,
    #[doc = "< registers available per multiprocessor"]
    pub regsPerMultiprocessor: ::std::os::raw::c_int,
    #[doc = "< Device supports allocating managed memory on this system"]
    pub managedMemory: ::std::os::raw::c_int,
    #[doc = "< 1 if device is on a multi-GPU board, 0 if not."]
    pub isMultiGpuBoard: ::std::os::raw::c_int,
    #[doc = "< Unique identifier for a group of devices on same multiboard GPU"]
    pub multiGpuBoardGroupID: ::std::os::raw::c_int,
    #[doc = "< Link between host and device supports native atomics"]
    pub hostNativeAtomicSupported: ::std::os::raw::c_int,
    #[doc = "< Deprecated. CUDA only."]
    pub singleToDoublePrecisionPerfRatio: ::std::os::raw::c_int,
    #[doc = "< Device supports coherently accessing pageable memory\n< without calling hipHostRegister on it"]
    pub pageableMemoryAccess: ::std::os::raw::c_int,
    #[doc = "< Device can coherently access managed memory concurrently with\n< the CPU"]
    pub concurrentManagedAccess: ::std::os::raw::c_int,
    #[doc = "< Is compute preemption supported on the device"]
    pub computePreemptionSupported: ::std::os::raw::c_int,
    #[doc = "< Device can access host registered memory with same\n< address as the host"]
    pub canUseHostPointerForRegisteredMem: ::std::os::raw::c_int,
    #[doc = "< HIP device supports cooperative launch"]
    pub cooperativeLaunch: ::std::os::raw::c_int,
    #[doc = "< HIP device supports cooperative launch on multiple\n< devices"]
    pub cooperativeMultiDeviceLaunch: ::std::os::raw::c_int,
    #[doc = "< Per device m ax shared mem per block usable by special opt in"]
    pub sharedMemPerBlockOptin: usize,
    #[doc = "< Device accesses pageable memory via the host's\n< page tables"]
    pub pageableMemoryAccessUsesHostPageTables: ::std::os::raw::c_int,
    #[doc = "< Host can directly access managed memory on the device\n< without migration"]
    pub directManagedMemAccessFromHost: ::std::os::raw::c_int,
    #[doc = "< Max number of blocks on CU"]
    pub maxBlocksPerMultiProcessor: ::std::os::raw::c_int,
    #[doc = "< Max value of access policy window"]
    pub accessPolicyMaxWindowSize: ::std::os::raw::c_int,
    #[doc = "< Shared memory reserved by driver per block"]
    pub reservedSharedMemPerBlock: usize,
    #[doc = "< Device supports hipHostRegister"]
    pub hostRegisterSupported: ::std::os::raw::c_int,
    #[doc = "< Indicates if device supports sparse hip arrays"]
    pub sparseHipArraySupported: ::std::os::raw::c_int,
    #[doc = "< Device supports using the hipHostRegisterReadOnly flag\n< with hipHostRegistger"]
    pub hostRegisterReadOnlySupported: ::std::os::raw::c_int,
    #[doc = "< Indicates external timeline semaphore support"]
    pub timelineSemaphoreInteropSupported: ::std::os::raw::c_int,
    #[doc = "< Indicates if device supports hipMallocAsync and hipMemPool APIs"]
    pub memoryPoolsSupported: ::std::os::raw::c_int,
    #[doc = "< Indicates device support of RDMA APIs"]
    pub gpuDirectRDMASupported: ::std::os::raw::c_int,
    #[doc = "< Bitmask to be interpreted according to\n< hipFlushGPUDirectRDMAWritesOptions"]
    pub gpuDirectRDMAFlushWritesOptions: ::std::os::raw::c_uint,
    #[doc = "< value of hipGPUDirectRDMAWritesOrdering"]
    pub gpuDirectRDMAWritesOrdering: ::std::os::raw::c_int,
    #[doc = "< Bitmask of handle types support with mempool based IPC"]
    pub memoryPoolSupportedHandleTypes: ::std::os::raw::c_uint,
    #[doc = "< Device supports deferred mapping HIP arrays and HIP\n< mipmapped arrays"]
    pub deferredMappingHipArraySupported: ::std::os::raw::c_int,
    #[doc = "< Device supports IPC events"]
    pub ipcEventSupported: ::std::os::raw::c_int,
    #[doc = "< Device supports cluster launch"]
    pub clusterLaunch: ::std::os::raw::c_int,
    #[doc = "< Indicates device supports unified function pointers"]
    pub unifiedFunctionPointers: ::std::os::raw::c_int,
    #[doc = "< CUDA Reserved."]
    pub reserved: [::std::os::raw::c_int; 63usize],
    #[doc = "< Reserved for adding new entries for HIP/CUDA."]
    pub hipReserved: [::std::os::raw::c_int; 32usize],
    #[doc = "< AMD GCN Arch Name. HIP Only."]
    pub gcnArchName: [::std::os::raw::c_char; 256usize],
    #[doc = "< Maximum Shared Memory Per CU. HIP Only."]
    pub maxSharedMemoryPerMultiProcessor: usize,
    #[doc = "< Frequency in khz of the timer used by the device-side \"clock*\"\n< instructions.  New for HIP."]
    pub clockInstructionRate: ::std::os::raw::c_int,
    #[doc = "< Architectural feature flags.  New for HIP."]
    pub arch: hipDeviceArch_t,
    #[doc = "< Addres of HDP_MEM_COHERENCY_FLUSH_CNTL register"]
    pub hdpMemFlushCntl: *mut ::std::os::raw::c_uint,
    #[doc = "< Addres of HDP_REG_COHERENCY_FLUSH_CNTL register"]
    pub hdpRegFlushCntl: *mut ::std::os::raw::c_uint,
    #[doc = "< HIP device supports cooperative launch on\n< multiple"]
    pub cooperativeMultiDeviceUnmatchedFunc: ::std::os::raw::c_int,
    #[doc = "< HIP device supports cooperative launch on\n< multiple"]
    pub cooperativeMultiDeviceUnmatchedGridDim: ::std::os::raw::c_int,
    #[doc = "< HIP device supports cooperative launch on\n< multiple"]
    pub cooperativeMultiDeviceUnmatchedBlockDim: ::std::os::raw::c_int,
    #[doc = "< HIP device supports cooperative launch on\n< multiple"]
    pub cooperativeMultiDeviceUnmatchedSharedMem: ::std::os::raw::c_int,
    #[doc = "< 1: if it is a large PCI bar device, else 0"]
    pub isLargeBar: ::std::os::raw::c_int,
    #[doc = "< Revision of the GPU in this device"]
    pub asicRevision: ::std::os::raw::c_int,
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " hipMemoryType (for pointer attributes)\n\n @note hipMemoryType enum values are combination of cudaMemoryType and cuMemoryType and AMD specific enum values.\n"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum hipMemoryType {
    #[doc = "< Unregistered memory"]
    hipMemoryTypeUnregistered = 0,
    #[doc = "< Memory is physically located on host"]
    hipMemoryTypeHost = 1,
    #[doc = "< Memory is physically located on device. (see deviceId for\n< specific device)"]
    hipMemoryTypeDevice = 2,
    #[doc = "< Managed memory, automaticallly managed by the unified\n< memory system\n< place holder for new values."]
    hipMemoryTypeManaged = 3,
    #[doc = "< Array memory, physically located on device. (see deviceId for\n< specific device)"]
    hipMemoryTypeArray = 10,
    #[doc = "< unified address space"]
    hipMemoryTypeUnified = 11,
}
#[doc = " Pointer attributes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hipPointerAttribute_t {
    pub type_: hipMemoryType,
    pub device: ::std::os::raw::c_int,
    pub devicePointer: *mut ::std::os::raw::c_void,
    pub hostPointer: *mut ::std::os::raw::c_void,
    pub isManaged: ::std::os::raw::c_int,
    pub allocationFlags: ::std::os::raw::c_uint,
}
impl hipError_t {
    pub const hipErrorMemoryAllocation: hipError_t = hipError_t::hipErrorOutOfMemory;
}
impl hipError_t {
    pub const hipErrorInitializationError: hipError_t = hipError_t::hipErrorNotInitialized;
}
impl hipError_t {
    pub const hipErrorMapBufferObjectFailed: hipError_t = hipError_t::hipErrorMapFailed;
}
impl hipError_t {
    pub const hipErrorInvalidResourceHandle: hipError_t = hipError_t::hipErrorInvalidHandle;
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " HIP error type\n"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum hipError_t {
    #[doc = "< Successful completion."]
    hipSuccess = 0,
    #[doc = "< One or more of the parameters passed to the API call is NULL\n< or not in an acceptable range."]
    hipErrorInvalidValue = 1,
    #[doc = "< out of memory range."]
    hipErrorOutOfMemory = 2,
    #[doc = "< Invalid not initialized"]
    hipErrorNotInitialized = 3,
    #[doc = "< Deinitialized"]
    hipErrorDeinitialized = 4,
    hipErrorProfilerDisabled = 5,
    hipErrorProfilerNotInitialized = 6,
    hipErrorProfilerAlreadyStarted = 7,
    hipErrorProfilerAlreadyStopped = 8,
    #[doc = "< Invalide configuration"]
    hipErrorInvalidConfiguration = 9,
    #[doc = "< Invalid pitch value"]
    hipErrorInvalidPitchValue = 12,
    #[doc = "< Invalid symbol"]
    hipErrorInvalidSymbol = 13,
    #[doc = "< Invalid Device Pointer"]
    hipErrorInvalidDevicePointer = 17,
    #[doc = "< Invalid memory copy direction"]
    hipErrorInvalidMemcpyDirection = 21,
    hipErrorInsufficientDriver = 35,
    hipErrorMissingConfiguration = 52,
    hipErrorPriorLaunchFailure = 53,
    #[doc = "< Invalid device function"]
    hipErrorInvalidDeviceFunction = 98,
    #[doc = "< Call to hipGetDeviceCount returned 0 devices"]
    hipErrorNoDevice = 100,
    #[doc = "< DeviceID must be in range from 0 to compute-devices."]
    hipErrorInvalidDevice = 101,
    #[doc = "< Invalid image"]
    hipErrorInvalidImage = 200,
    #[doc = "< Produced when input context is invalid."]
    hipErrorInvalidContext = 201,
    hipErrorContextAlreadyCurrent = 202,
    hipErrorMapFailed = 205,
    hipErrorUnmapFailed = 206,
    hipErrorArrayIsMapped = 207,
    hipErrorAlreadyMapped = 208,
    hipErrorNoBinaryForGpu = 209,
    hipErrorAlreadyAcquired = 210,
    hipErrorNotMapped = 211,
    hipErrorNotMappedAsArray = 212,
    hipErrorNotMappedAsPointer = 213,
    hipErrorECCNotCorrectable = 214,
    #[doc = "< Unsupported limit"]
    hipErrorUnsupportedLimit = 215,
    #[doc = "< The context is already in use"]
    hipErrorContextAlreadyInUse = 216,
    hipErrorPeerAccessUnsupported = 217,
    #[doc = "< In CUDA DRV, it is CUDA_ERROR_INVALID_PTX"]
    hipErrorInvalidKernelFile = 218,
    hipErrorInvalidGraphicsContext = 219,
    #[doc = "< Invalid source."]
    hipErrorInvalidSource = 300,
    #[doc = "< the file is not found."]
    hipErrorFileNotFound = 301,
    hipErrorSharedObjectSymbolNotFound = 302,
    #[doc = "< Failed to initialize shared object."]
    hipErrorSharedObjectInitFailed = 303,
    #[doc = "< Not the correct operating system"]
    hipErrorOperatingSystem = 304,
    #[doc = "< Invalide handle"]
    hipErrorInvalidHandle = 400,
    #[doc = "< Resource required is not in a valid state to perform operation."]
    hipErrorIllegalState = 401,
    #[doc = "< Not found"]
    hipErrorNotFound = 500,
    #[doc = "< Indicates that asynchronous operations enqueued earlier are not\n< ready.  This is not actually an error, but is used to distinguish\n< from hipSuccess (which indicates completion).  APIs that return\n< this error include hipEventQuery and hipStreamQuery."]
    hipErrorNotReady = 600,
    hipErrorIllegalAddress = 700,
    #[doc = "< Out of resources error."]
    hipErrorLaunchOutOfResources = 701,
    #[doc = "< Timeout for the launch."]
    hipErrorLaunchTimeOut = 702,
    hipErrorPeerAccessAlreadyEnabled = 704,
    hipErrorPeerAccessNotEnabled = 705,
    #[doc = "< The process is active."]
    hipErrorSetOnActiveProcess = 708,
    #[doc = "< The context is already destroyed"]
    hipErrorContextIsDestroyed = 709,
    #[doc = "< Produced when the kernel calls assert."]
    hipErrorAssert = 710,
    hipErrorHostMemoryAlreadyRegistered = 712,
    hipErrorHostMemoryNotRegistered = 713,
    hipErrorLaunchFailure = 719,
    hipErrorCooperativeLaunchTooLarge = 720,
    #[doc = "< Produced when the hip API is not supported/implemented"]
    hipErrorNotSupported = 801,
    #[doc = "< The operation is not permitted when the stream\n< is capturing."]
    hipErrorStreamCaptureUnsupported = 900,
    #[doc = "< The current capture sequence on the stream\n< has been invalidated due to a previous error."]
    hipErrorStreamCaptureInvalidated = 901,
    #[doc = "< The operation would have resulted in a merge of\n< two independent capture sequences."]
    hipErrorStreamCaptureMerge = 902,
    #[doc = "< The capture was not initiated in this stream."]
    hipErrorStreamCaptureUnmatched = 903,
    #[doc = "< The capture sequence contains a fork that was not\n< joined to the primary stream."]
    hipErrorStreamCaptureUnjoined = 904,
    #[doc = "< A dependency would have been created which crosses\n< the capture sequence boundary. Only implicit\n< in-stream ordering dependencies  are allowed\n< to cross the boundary"]
    hipErrorStreamCaptureIsolation = 905,
    #[doc = "< The operation would have resulted in a disallowed\n< implicit dependency on a current capture sequence\n< from hipStreamLegacy."]
    hipErrorStreamCaptureImplicit = 906,
    #[doc = "< The operation is not permitted on an event which was last\n< recorded in a capturing stream."]
    hipErrorCapturedEvent = 907,
    #[doc = "< A stream capture sequence not initiated with\n< the hipStreamCaptureModeRelaxed argument to\n< hipStreamBeginCapture was passed to\n< hipStreamEndCapture in a different thread."]
    hipErrorStreamCaptureWrongThread = 908,
    #[doc = "< This error indicates that the graph update\n< not performed because it included changes which\n< violated constraintsspecific to instantiated graph\n< update."]
    hipErrorGraphExecUpdateFailure = 910,
    #[doc = "< Unknown error."]
    hipErrorUnknown = 999,
    #[doc = "< HSA runtime memory call returned error.  Typically not seen\n< in production systems."]
    hipErrorRuntimeMemory = 1052,
    #[doc = "< HSA runtime call other than memory returned error.  Typically\n< not seen in production systems."]
    hipErrorRuntimeOther = 1053,
    #[doc = "< Marker that more error codes are needed."]
    hipErrorTbd = 1054,
}
impl hipDeviceAttribute_t {
    pub const hipDeviceAttributeEccEnabled: hipDeviceAttribute_t =
        hipDeviceAttribute_t::hipDeviceAttributeCudaCompatibleBegin;
}
impl hipDeviceAttribute_t {
    pub const hipDeviceAttributeClockInstructionRate: hipDeviceAttribute_t =
        hipDeviceAttribute_t::hipDeviceAttributeAmdSpecificBegin;
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " hipDeviceAttribute_t\n hipDeviceAttributeUnused number: 5"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum hipDeviceAttribute_t {
    hipDeviceAttributeCudaCompatibleBegin = 0,
    #[doc = "< Cuda only. The maximum size of the window policy in bytes."]
    hipDeviceAttributeAccessPolicyMaxWindowSize = 1,
    #[doc = "< Asynchronous engines number."]
    hipDeviceAttributeAsyncEngineCount = 2,
    #[doc = "< Whether host memory can be mapped into device address space"]
    hipDeviceAttributeCanMapHostMemory = 3,
    #[doc = "< Device can access host registered memory\n< at the same virtual address as the CPU"]
    hipDeviceAttributeCanUseHostPointerForRegisteredMem = 4,
    #[doc = "< Peak clock frequency in kilohertz."]
    hipDeviceAttributeClockRate = 5,
    #[doc = "< Compute mode that device is currently in."]
    hipDeviceAttributeComputeMode = 6,
    #[doc = "< Device supports Compute Preemption."]
    hipDeviceAttributeComputePreemptionSupported = 7,
    #[doc = "< Device can possibly execute multiple kernels concurrently."]
    hipDeviceAttributeConcurrentKernels = 8,
    #[doc = "< Device can coherently access managed memory concurrently with the CPU"]
    hipDeviceAttributeConcurrentManagedAccess = 9,
    #[doc = "< Support cooperative launch"]
    hipDeviceAttributeCooperativeLaunch = 10,
    #[doc = "< Support cooperative launch on multiple devices"]
    hipDeviceAttributeCooperativeMultiDeviceLaunch = 11,
    #[doc = "< Device can concurrently copy memory and execute a kernel.\n< Deprecated. Use instead asyncEngineCount."]
    hipDeviceAttributeDeviceOverlap = 12,
    #[doc = "< Host can directly access managed memory on\n< the device without migration"]
    hipDeviceAttributeDirectManagedMemAccessFromHost = 13,
    #[doc = "< Device supports caching globals in L1"]
    hipDeviceAttributeGlobalL1CacheSupported = 14,
    #[doc = "< Link between the device and the host supports native atomic operations"]
    hipDeviceAttributeHostNativeAtomicSupported = 15,
    #[doc = "< Device is integrated GPU"]
    hipDeviceAttributeIntegrated = 16,
    #[doc = "< Multiple GPU devices."]
    hipDeviceAttributeIsMultiGpuBoard = 17,
    #[doc = "< Run time limit for kernels executed on the device"]
    hipDeviceAttributeKernelExecTimeout = 18,
    #[doc = "< Size of L2 cache in bytes. 0 if the device doesn't have L2 cache."]
    hipDeviceAttributeL2CacheSize = 19,
    #[doc = "< caching locals in L1 is supported"]
    hipDeviceAttributeLocalL1CacheSupported = 20,
    #[doc = "< 8-byte locally unique identifier in 8 bytes. Undefined on TCC and non-Windows platforms"]
    hipDeviceAttributeLuid = 21,
    #[doc = "< Luid device node mask. Undefined on TCC and non-Windows platforms"]
    hipDeviceAttributeLuidDeviceNodeMask = 22,
    #[doc = "< Major compute capability version number."]
    hipDeviceAttributeComputeCapabilityMajor = 23,
    #[doc = "< Device supports allocating managed memory on this system"]
    hipDeviceAttributeManagedMemory = 24,
    #[doc = "< Max block size per multiprocessor"]
    hipDeviceAttributeMaxBlocksPerMultiProcessor = 25,
    #[doc = "< Max block size in width."]
    hipDeviceAttributeMaxBlockDimX = 26,
    #[doc = "< Max block size in height."]
    hipDeviceAttributeMaxBlockDimY = 27,
    #[doc = "< Max block size in depth."]
    hipDeviceAttributeMaxBlockDimZ = 28,
    #[doc = "< Max grid size  in width."]
    hipDeviceAttributeMaxGridDimX = 29,
    #[doc = "< Max grid size  in height."]
    hipDeviceAttributeMaxGridDimY = 30,
    #[doc = "< Max grid size  in depth."]
    hipDeviceAttributeMaxGridDimZ = 31,
    #[doc = "< Maximum size of 1D surface."]
    hipDeviceAttributeMaxSurface1D = 32,
    #[doc = "< Cuda only. Maximum dimensions of 1D layered surface."]
    hipDeviceAttributeMaxSurface1DLayered = 33,
    #[doc = "< Maximum dimension (width, height) of 2D surface."]
    hipDeviceAttributeMaxSurface2D = 34,
    #[doc = "< Cuda only. Maximum dimensions of 2D layered surface."]
    hipDeviceAttributeMaxSurface2DLayered = 35,
    #[doc = "< Maximum dimension (width, height, depth) of 3D surface."]
    hipDeviceAttributeMaxSurface3D = 36,
    #[doc = "< Cuda only. Maximum dimensions of Cubemap surface."]
    hipDeviceAttributeMaxSurfaceCubemap = 37,
    #[doc = "< Cuda only. Maximum dimension of Cubemap layered surface."]
    hipDeviceAttributeMaxSurfaceCubemapLayered = 38,
    #[doc = "< Maximum size of 1D texture."]
    hipDeviceAttributeMaxTexture1DWidth = 39,
    #[doc = "< Maximum dimensions of 1D layered texture."]
    hipDeviceAttributeMaxTexture1DLayered = 40,
    #[doc = "< Maximum number of elements allocatable in a 1D linear texture.\n< Use cudaDeviceGetTexture1DLinearMaxWidth() instead on Cuda."]
    hipDeviceAttributeMaxTexture1DLinear = 41,
    #[doc = "< Maximum size of 1D mipmapped texture."]
    hipDeviceAttributeMaxTexture1DMipmap = 42,
    #[doc = "< Maximum dimension width of 2D texture."]
    hipDeviceAttributeMaxTexture2DWidth = 43,
    #[doc = "< Maximum dimension hight of 2D texture."]
    hipDeviceAttributeMaxTexture2DHeight = 44,
    #[doc = "< Maximum dimensions of 2D texture if gather operations  performed."]
    hipDeviceAttributeMaxTexture2DGather = 45,
    #[doc = "< Maximum dimensions of 2D layered texture."]
    hipDeviceAttributeMaxTexture2DLayered = 46,
    #[doc = "< Maximum dimensions (width, height, pitch) of 2D textures bound to pitched memory."]
    hipDeviceAttributeMaxTexture2DLinear = 47,
    #[doc = "< Maximum dimensions of 2D mipmapped texture."]
    hipDeviceAttributeMaxTexture2DMipmap = 48,
    #[doc = "< Maximum dimension width of 3D texture."]
    hipDeviceAttributeMaxTexture3DWidth = 49,
    #[doc = "< Maximum dimension height of 3D texture."]
    hipDeviceAttributeMaxTexture3DHeight = 50,
    #[doc = "< Maximum dimension depth of 3D texture."]
    hipDeviceAttributeMaxTexture3DDepth = 51,
    #[doc = "< Maximum dimensions of alternate 3D texture."]
    hipDeviceAttributeMaxTexture3DAlt = 52,
    #[doc = "< Maximum dimensions of Cubemap texture"]
    hipDeviceAttributeMaxTextureCubemap = 53,
    #[doc = "< Maximum dimensions of Cubemap layered texture."]
    hipDeviceAttributeMaxTextureCubemapLayered = 54,
    #[doc = "< Maximum dimension of a block"]
    hipDeviceAttributeMaxThreadsDim = 55,
    #[doc = "< Maximum number of threads per block."]
    hipDeviceAttributeMaxThreadsPerBlock = 56,
    #[doc = "< Maximum resident threads per multiprocessor."]
    hipDeviceAttributeMaxThreadsPerMultiProcessor = 57,
    #[doc = "< Maximum pitch in bytes allowed by memory copies"]
    hipDeviceAttributeMaxPitch = 58,
    #[doc = "< Global memory bus width in bits."]
    hipDeviceAttributeMemoryBusWidth = 59,
    #[doc = "< Peak memory clock frequency in kilohertz."]
    hipDeviceAttributeMemoryClockRate = 60,
    #[doc = "< Minor compute capability version number."]
    hipDeviceAttributeComputeCapabilityMinor = 61,
    #[doc = "< Unique ID of device group on the same multi-GPU board"]
    hipDeviceAttributeMultiGpuBoardGroupID = 62,
    #[doc = "< Number of multiprocessors on the device."]
    hipDeviceAttributeMultiprocessorCount = 63,
    #[doc = "< Previously hipDeviceAttributeName"]
    hipDeviceAttributeUnused1 = 64,
    #[doc = "< Device supports coherently accessing pageable memory\n< without calling hipHostRegister on it"]
    hipDeviceAttributePageableMemoryAccess = 65,
    #[doc = "< Device accesses pageable memory via the host's page tables"]
    hipDeviceAttributePageableMemoryAccessUsesHostPageTables = 66,
    #[doc = "< PCI Bus ID."]
    hipDeviceAttributePciBusId = 67,
    #[doc = "< PCI Device ID."]
    hipDeviceAttributePciDeviceId = 68,
    #[doc = "< PCI Domain ID."]
    hipDeviceAttributePciDomainID = 69,
    #[doc = "< Maximum l2 persisting lines capacity in bytes"]
    hipDeviceAttributePersistingL2CacheMaxSize = 70,
    #[doc = "< 32-bit registers available to a thread block. This number is shared\n< by all thread blocks simultaneously resident on a multiprocessor."]
    hipDeviceAttributeMaxRegistersPerBlock = 71,
    #[doc = "< 32-bit registers available per block."]
    hipDeviceAttributeMaxRegistersPerMultiprocessor = 72,
    #[doc = "< Shared memory reserved by CUDA driver per block."]
    hipDeviceAttributeReservedSharedMemPerBlock = 73,
    #[doc = "< Maximum shared memory available per block in bytes."]
    hipDeviceAttributeMaxSharedMemoryPerBlock = 74,
    #[doc = "< Maximum shared memory per block usable by special opt in."]
    hipDeviceAttributeSharedMemPerBlockOptin = 75,
    #[doc = "< Shared memory available per multiprocessor."]
    hipDeviceAttributeSharedMemPerMultiprocessor = 76,
    #[doc = "< Cuda only. Performance ratio of single precision to double precision."]
    hipDeviceAttributeSingleToDoublePrecisionPerfRatio = 77,
    #[doc = "< Whether to support stream priorities."]
    hipDeviceAttributeStreamPrioritiesSupported = 78,
    #[doc = "< Alignment requirement for surfaces"]
    hipDeviceAttributeSurfaceAlignment = 79,
    #[doc = "< Cuda only. Whether device is a Tesla device using TCC driver"]
    hipDeviceAttributeTccDriver = 80,
    #[doc = "< Alignment requirement for textures"]
    hipDeviceAttributeTextureAlignment = 81,
    #[doc = "< Pitch alignment requirement for 2D texture references bound to pitched memory;"]
    hipDeviceAttributeTexturePitchAlignment = 82,
    #[doc = "< Constant memory size in bytes."]
    hipDeviceAttributeTotalConstantMemory = 83,
    #[doc = "< Global memory available on devicice."]
    hipDeviceAttributeTotalGlobalMem = 84,
    #[doc = "< Cuda only. An unified address space shared with the host."]
    hipDeviceAttributeUnifiedAddressing = 85,
    #[doc = "< Previously hipDeviceAttributeUuid"]
    hipDeviceAttributeUnused2 = 86,
    #[doc = "< Warp size in threads."]
    hipDeviceAttributeWarpSize = 87,
    #[doc = "< Device supports HIP Stream Ordered Memory Allocator"]
    hipDeviceAttributeMemoryPoolsSupported = 88,
    #[doc = "< Device supports HIP virtual memory management"]
    hipDeviceAttributeVirtualMemoryManagementSupported = 89,
    #[doc = "< Can device support host memory registration via hipHostRegister"]
    hipDeviceAttributeHostRegisterSupported = 90,
    hipDeviceAttributeCudaCompatibleEnd = 9999,
    hipDeviceAttributeAmdSpecificBegin = 10000,
    #[doc = "< Previously hipDeviceAttributeArch"]
    hipDeviceAttributeUnused3 = 10001,
    #[doc = "< Maximum Shared Memory PerMultiprocessor."]
    hipDeviceAttributeMaxSharedMemoryPerMultiprocessor = 10002,
    #[doc = "< Previously hipDeviceAttributeGcnArch"]
    hipDeviceAttributeUnused4 = 10003,
    #[doc = "< Previously hipDeviceAttributeGcnArchName"]
    hipDeviceAttributeUnused5 = 10004,
    #[doc = "< Address of the HDP_MEM_COHERENCY_FLUSH_CNTL register"]
    hipDeviceAttributeHdpMemFlushCntl = 10005,
    #[doc = "< Address of the HDP_REG_COHERENCY_FLUSH_CNTL register"]
    hipDeviceAttributeHdpRegFlushCntl = 10006,
    #[doc = "< Supports cooperative launch on multiple\n< devices with unmatched functions"]
    hipDeviceAttributeCooperativeMultiDeviceUnmatchedFunc = 10007,
    #[doc = "< Supports cooperative launch on multiple\n< devices with unmatched grid dimensions"]
    hipDeviceAttributeCooperativeMultiDeviceUnmatchedGridDim = 10008,
    #[doc = "< Supports cooperative launch on multiple\n< devices with unmatched block dimensions"]
    hipDeviceAttributeCooperativeMultiDeviceUnmatchedBlockDim = 10009,
    #[doc = "< Supports cooperative launch on multiple\n< devices with unmatched shared memories"]
    hipDeviceAttributeCooperativeMultiDeviceUnmatchedSharedMem = 10010,
    #[doc = "< Whether it is LargeBar"]
    hipDeviceAttributeIsLargeBar = 10011,
    #[doc = "< Revision of the GPU in this device"]
    hipDeviceAttributeAsicRevision = 10012,
    #[doc = "< '1' if Device supports hipStreamWaitValue32() and\n< hipStreamWaitValue64(), '0' otherwise."]
    hipDeviceAttributeCanUseStreamWaitValue = 10013,
    #[doc = "< '1' if Device supports image, '0' otherwise."]
    hipDeviceAttributeImageSupport = 10014,
    #[doc = "< All available physical compute\n< units for the device"]
    hipDeviceAttributePhysicalMultiProcessorCount = 10015,
    #[doc = "< '1' if Device supports fine grain, '0' otherwise"]
    hipDeviceAttributeFineGrainSupport = 10016,
    #[doc = "< Constant frequency of wall clock in kilohertz."]
    hipDeviceAttributeWallClockRate = 10017,
    hipDeviceAttributeAmdSpecificEnd = 19999,
    hipDeviceAttributeVendorSpecificBegin = 20000,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum hipComputeMode {
    hipComputeModeDefault = 0,
    hipComputeModeExclusive = 1,
    hipComputeModeProhibited = 2,
    hipComputeModeExclusiveProcess = 3,
}
pub type hipDeviceptr_t = *mut ::std::os::raw::c_void;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum hipChannelFormatKind {
    hipChannelFormatKindSigned = 0,
    hipChannelFormatKindUnsigned = 1,
    hipChannelFormatKindFloat = 2,
    hipChannelFormatKindNone = 3,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hipChannelFormatDesc {
    pub x: ::std::os::raw::c_int,
    pub y: ::std::os::raw::c_int,
    pub z: ::std::os::raw::c_int,
    pub w: ::std::os::raw::c_int,
    pub f: hipChannelFormatKind,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hipArray {
    _unused: [u8; 0],
}
pub type hipArray_t = *mut hipArray;
pub type hipArray_const_t = *const hipArray;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum hipArray_Format {
    HIP_AD_FORMAT_UNSIGNED_INT8 = 1,
    HIP_AD_FORMAT_UNSIGNED_INT16 = 2,
    HIP_AD_FORMAT_UNSIGNED_INT32 = 3,
    HIP_AD_FORMAT_SIGNED_INT8 = 8,
    HIP_AD_FORMAT_SIGNED_INT16 = 9,
    HIP_AD_FORMAT_SIGNED_INT32 = 10,
    HIP_AD_FORMAT_HALF = 16,
    HIP_AD_FORMAT_FLOAT = 32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HIP_ARRAY_DESCRIPTOR {
    pub Width: usize,
    pub Height: usize,
    pub Format: hipArray_Format,
    pub NumChannels: ::std::os::raw::c_uint,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HIP_ARRAY3D_DESCRIPTOR {
    pub Width: usize,
    pub Height: usize,
    pub Depth: usize,
    pub Format: hipArray_Format,
    pub NumChannels: ::std::os::raw::c_uint,
    pub Flags: ::std::os::raw::c_uint,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hip_Memcpy2D {
    pub srcXInBytes: usize,
    pub srcY: usize,
    pub srcMemoryType: hipMemoryType,
    pub srcHost: *const ::std::os::raw::c_void,
    pub srcDevice: hipDeviceptr_t,
    pub srcArray: hipArray_t,
    pub srcPitch: usize,
    pub dstXInBytes: usize,
    pub dstY: usize,
    pub dstMemoryType: hipMemoryType,
    pub dstHost: *mut ::std::os::raw::c_void,
    pub dstDevice: hipDeviceptr_t,
    pub dstArray: hipArray_t,
    pub dstPitch: usize,
    pub WidthInBytes: usize,
    pub Height: usize,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hipMipmappedArray {
    pub data: *mut ::std::os::raw::c_void,
    pub desc: hipChannelFormatDesc,
    pub type_: ::std::os::raw::c_uint,
    pub width: ::std::os::raw::c_uint,
    pub height: ::std::os::raw::c_uint,
    pub depth: ::std::os::raw::c_uint,
    pub min_mipmap_level: ::std::os::raw::c_uint,
    pub max_mipmap_level: ::std::os::raw::c_uint,
    pub flags: ::std::os::raw::c_uint,
    pub format: hipArray_Format,
    pub num_channels: ::std::os::raw::c_uint,
}
pub type hipMipmappedArray_t = *mut hipMipmappedArray;
pub type hipmipmappedArray = hipMipmappedArray_t;
pub type hipMipmappedArray_const_t = *const hipMipmappedArray;
#[repr(u32)]
#[non_exhaustive]
#[doc = " hip resource types"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum hipResourceType {
    hipResourceTypeArray = 0,
    hipResourceTypeMipmappedArray = 1,
    hipResourceTypeLinear = 2,
    hipResourceTypePitch2D = 3,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum HIPresourcetype_enum {
    #[doc = "< Array resoure"]
    HIP_RESOURCE_TYPE_ARRAY = 0,
    #[doc = "< Mipmapped array resource"]
    HIP_RESOURCE_TYPE_MIPMAPPED_ARRAY = 1,
    #[doc = "< Linear resource"]
    HIP_RESOURCE_TYPE_LINEAR = 2,
    #[doc = "< Pitch 2D resource"]
    HIP_RESOURCE_TYPE_PITCH2D = 3,
}
pub use self::HIPresourcetype_enum as HIPresourcetype;
pub use self::HIPresourcetype_enum as hipResourcetype;
#[repr(u32)]
#[non_exhaustive]
#[doc = " hip address modes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum HIPaddress_mode_enum {
    HIP_TR_ADDRESS_MODE_WRAP = 0,
    HIP_TR_ADDRESS_MODE_CLAMP = 1,
    HIP_TR_ADDRESS_MODE_MIRROR = 2,
    HIP_TR_ADDRESS_MODE_BORDER = 3,
}
#[doc = " hip address modes"]
pub use self::HIPaddress_mode_enum as HIPaddress_mode;
#[repr(u32)]
#[non_exhaustive]
#[doc = " hip filter modes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum HIPfilter_mode_enum {
    HIP_TR_FILTER_MODE_POINT = 0,
    HIP_TR_FILTER_MODE_LINEAR = 1,
}
#[doc = " hip filter modes"]
pub use self::HIPfilter_mode_enum as HIPfilter_mode;
#[doc = " Texture descriptor"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HIP_TEXTURE_DESC_st {
    #[doc = "< Address modes"]
    pub addressMode: [HIPaddress_mode; 3usize],
    #[doc = "< Filter mode"]
    pub filterMode: HIPfilter_mode,
    #[doc = "< Flags"]
    pub flags: ::std::os::raw::c_uint,
    #[doc = "< Maximum anisotropy ratio"]
    pub maxAnisotropy: ::std::os::raw::c_uint,
    #[doc = "< Mipmap filter mode"]
    pub mipmapFilterMode: HIPfilter_mode,
    #[doc = "< Mipmap level bias"]
    pub mipmapLevelBias: f32,
    #[doc = "< Mipmap minimum level clamp"]
    pub minMipmapLevelClamp: f32,
    #[doc = "< Mipmap maximum level clamp"]
    pub maxMipmapLevelClamp: f32,
    #[doc = "< Border Color"]
    pub borderColor: [f32; 4usize],
    pub reserved: [::std::os::raw::c_int; 12usize],
}
#[doc = " Texture descriptor"]
pub type HIP_TEXTURE_DESC = HIP_TEXTURE_DESC_st;
#[repr(u32)]
#[non_exhaustive]
#[doc = " hip texture resource view formats"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum hipResourceViewFormat {
    hipResViewFormatNone = 0,
    hipResViewFormatUnsignedChar1 = 1,
    hipResViewFormatUnsignedChar2 = 2,
    hipResViewFormatUnsignedChar4 = 3,
    hipResViewFormatSignedChar1 = 4,
    hipResViewFormatSignedChar2 = 5,
    hipResViewFormatSignedChar4 = 6,
    hipResViewFormatUnsignedShort1 = 7,
    hipResViewFormatUnsignedShort2 = 8,
    hipResViewFormatUnsignedShort4 = 9,
    hipResViewFormatSignedShort1 = 10,
    hipResViewFormatSignedShort2 = 11,
    hipResViewFormatSignedShort4 = 12,
    hipResViewFormatUnsignedInt1 = 13,
    hipResViewFormatUnsignedInt2 = 14,
    hipResViewFormatUnsignedInt4 = 15,
    hipResViewFormatSignedInt1 = 16,
    hipResViewFormatSignedInt2 = 17,
    hipResViewFormatSignedInt4 = 18,
    hipResViewFormatHalf1 = 19,
    hipResViewFormatHalf2 = 20,
    hipResViewFormatHalf4 = 21,
    hipResViewFormatFloat1 = 22,
    hipResViewFormatFloat2 = 23,
    hipResViewFormatFloat4 = 24,
    hipResViewFormatUnsignedBlockCompressed1 = 25,
    hipResViewFormatUnsignedBlockCompressed2 = 26,
    hipResViewFormatUnsignedBlockCompressed3 = 27,
    hipResViewFormatUnsignedBlockCompressed4 = 28,
    hipResViewFormatSignedBlockCompressed4 = 29,
    hipResViewFormatUnsignedBlockCompressed5 = 30,
    hipResViewFormatSignedBlockCompressed5 = 31,
    hipResViewFormatUnsignedBlockCompressed6H = 32,
    hipResViewFormatSignedBlockCompressed6H = 33,
    hipResViewFormatUnsignedBlockCompressed7 = 34,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum HIPresourceViewFormat_enum {
    #[doc = "< No resource view format (use underlying resource format)"]
    HIP_RES_VIEW_FORMAT_NONE = 0,
    #[doc = "< 1 channel unsigned 8-bit integers"]
    HIP_RES_VIEW_FORMAT_UINT_1X8 = 1,
    #[doc = "< 2 channel unsigned 8-bit integers"]
    HIP_RES_VIEW_FORMAT_UINT_2X8 = 2,
    #[doc = "< 4 channel unsigned 8-bit integers"]
    HIP_RES_VIEW_FORMAT_UINT_4X8 = 3,
    #[doc = "< 1 channel signed 8-bit integers"]
    HIP_RES_VIEW_FORMAT_SINT_1X8 = 4,
    #[doc = "< 2 channel signed 8-bit integers"]
    HIP_RES_VIEW_FORMAT_SINT_2X8 = 5,
    #[doc = "< 4 channel signed 8-bit integers"]
    HIP_RES_VIEW_FORMAT_SINT_4X8 = 6,
    #[doc = "< 1 channel unsigned 16-bit integers"]
    HIP_RES_VIEW_FORMAT_UINT_1X16 = 7,
    #[doc = "< 2 channel unsigned 16-bit integers"]
    HIP_RES_VIEW_FORMAT_UINT_2X16 = 8,
    #[doc = "< 4 channel unsigned 16-bit integers"]
    HIP_RES_VIEW_FORMAT_UINT_4X16 = 9,
    #[doc = "< 1 channel signed 16-bit integers"]
    HIP_RES_VIEW_FORMAT_SINT_1X16 = 10,
    #[doc = "< 2 channel signed 16-bit integers"]
    HIP_RES_VIEW_FORMAT_SINT_2X16 = 11,
    #[doc = "< 4 channel signed 16-bit integers"]
    HIP_RES_VIEW_FORMAT_SINT_4X16 = 12,
    #[doc = "< 1 channel unsigned 32-bit integers"]
    HIP_RES_VIEW_FORMAT_UINT_1X32 = 13,
    #[doc = "< 2 channel unsigned 32-bit integers"]
    HIP_RES_VIEW_FORMAT_UINT_2X32 = 14,
    #[doc = "< 4 channel unsigned 32-bit integers"]
    HIP_RES_VIEW_FORMAT_UINT_4X32 = 15,
    #[doc = "< 1 channel signed 32-bit integers"]
    HIP_RES_VIEW_FORMAT_SINT_1X32 = 16,
    #[doc = "< 2 channel signed 32-bit integers"]
    HIP_RES_VIEW_FORMAT_SINT_2X32 = 17,
    #[doc = "< 4 channel signed 32-bit integers"]
    HIP_RES_VIEW_FORMAT_SINT_4X32 = 18,
    #[doc = "< 1 channel 16-bit floating point"]
    HIP_RES_VIEW_FORMAT_FLOAT_1X16 = 19,
    #[doc = "< 2 channel 16-bit floating point"]
    HIP_RES_VIEW_FORMAT_FLOAT_2X16 = 20,
    #[doc = "< 4 channel 16-bit floating point"]
    HIP_RES_VIEW_FORMAT_FLOAT_4X16 = 21,
    #[doc = "< 1 channel 32-bit floating point"]
    HIP_RES_VIEW_FORMAT_FLOAT_1X32 = 22,
    #[doc = "< 2 channel 32-bit floating point"]
    HIP_RES_VIEW_FORMAT_FLOAT_2X32 = 23,
    #[doc = "< 4 channel 32-bit floating point"]
    HIP_RES_VIEW_FORMAT_FLOAT_4X32 = 24,
    #[doc = "< Block compressed 1"]
    HIP_RES_VIEW_FORMAT_UNSIGNED_BC1 = 25,
    #[doc = "< Block compressed 2"]
    HIP_RES_VIEW_FORMAT_UNSIGNED_BC2 = 26,
    #[doc = "< Block compressed 3"]
    HIP_RES_VIEW_FORMAT_UNSIGNED_BC3 = 27,
    #[doc = "< Block compressed 4 unsigned"]
    HIP_RES_VIEW_FORMAT_UNSIGNED_BC4 = 28,
    #[doc = "< Block compressed 4 signed"]
    HIP_RES_VIEW_FORMAT_SIGNED_BC4 = 29,
    #[doc = "< Block compressed 5 unsigned"]
    HIP_RES_VIEW_FORMAT_UNSIGNED_BC5 = 30,
    #[doc = "< Block compressed 5 signed"]
    HIP_RES_VIEW_FORMAT_SIGNED_BC5 = 31,
    #[doc = "< Block compressed 6 unsigned half-float"]
    HIP_RES_VIEW_FORMAT_UNSIGNED_BC6H = 32,
    #[doc = "< Block compressed 6 signed half-float"]
    HIP_RES_VIEW_FORMAT_SIGNED_BC6H = 33,
    #[doc = "< Block compressed 7"]
    HIP_RES_VIEW_FORMAT_UNSIGNED_BC7 = 34,
}
pub use self::HIPresourceViewFormat_enum as HIPresourceViewFormat;
#[doc = " HIP resource descriptor"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct hipResourceDesc {
    pub resType: hipResourceType,
    pub res: hipResourceDesc__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union hipResourceDesc__bindgen_ty_1 {
    pub array: hipResourceDesc__bindgen_ty_1__bindgen_ty_1,
    pub mipmap: hipResourceDesc__bindgen_ty_1__bindgen_ty_2,
    pub linear: hipResourceDesc__bindgen_ty_1__bindgen_ty_3,
    pub pitch2D: hipResourceDesc__bindgen_ty_1__bindgen_ty_4,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hipResourceDesc__bindgen_ty_1__bindgen_ty_1 {
    pub array: hipArray_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hipResourceDesc__bindgen_ty_1__bindgen_ty_2 {
    pub mipmap: hipMipmappedArray_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hipResourceDesc__bindgen_ty_1__bindgen_ty_3 {
    pub devPtr: *mut ::std::os::raw::c_void,
    pub desc: hipChannelFormatDesc,
    pub sizeInBytes: usize,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hipResourceDesc__bindgen_ty_1__bindgen_ty_4 {
    pub devPtr: *mut ::std::os::raw::c_void,
    pub desc: hipChannelFormatDesc,
    pub width: usize,
    pub height: usize,
    pub pitchInBytes: usize,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct HIP_RESOURCE_DESC_st {
    #[doc = "< Resource type"]
    pub resType: HIPresourcetype,
    pub res: HIP_RESOURCE_DESC_st__bindgen_ty_1,
    #[doc = "< Flags (must be zero)"]
    pub flags: ::std::os::raw::c_uint,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union HIP_RESOURCE_DESC_st__bindgen_ty_1 {
    pub array: HIP_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_1,
    pub mipmap: HIP_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_2,
    pub linear: HIP_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_3,
    pub pitch2D: HIP_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_4,
    pub reserved: HIP_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_5,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HIP_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_1 {
    #[doc = "< HIP array"]
    pub hArray: hipArray_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HIP_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_2 {
    #[doc = "< HIP mipmapped array"]
    pub hMipmappedArray: hipMipmappedArray_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HIP_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_3 {
    #[doc = "< Device pointer"]
    pub devPtr: hipDeviceptr_t,
    #[doc = "< Array format"]
    pub format: hipArray_Format,
    #[doc = "< Channels per array element"]
    pub numChannels: ::std::os::raw::c_uint,
    #[doc = "< Size in bytes"]
    pub sizeInBytes: usize,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HIP_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_4 {
    #[doc = "< Device pointer"]
    pub devPtr: hipDeviceptr_t,
    #[doc = "< Array format"]
    pub format: hipArray_Format,
    #[doc = "< Channels per array element"]
    pub numChannels: ::std::os::raw::c_uint,
    #[doc = "< Width of the array in elements"]
    pub width: usize,
    #[doc = "< Height of the array in elements"]
    pub height: usize,
    #[doc = "< Pitch between two rows in bytes"]
    pub pitchInBytes: usize,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HIP_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_5 {
    pub reserved: [::std::os::raw::c_int; 32usize],
}
pub type HIP_RESOURCE_DESC = HIP_RESOURCE_DESC_st;
#[doc = " hip resource view descriptor"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hipResourceViewDesc {
    pub format: hipResourceViewFormat,
    pub width: usize,
    pub height: usize,
    pub depth: usize,
    pub firstMipmapLevel: ::std::os::raw::c_uint,
    pub lastMipmapLevel: ::std::os::raw::c_uint,
    pub firstLayer: ::std::os::raw::c_uint,
    pub lastLayer: ::std::os::raw::c_uint,
}
#[doc = " Resource view descriptor"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HIP_RESOURCE_VIEW_DESC_st {
    #[doc = "< Resource view format"]
    pub format: HIPresourceViewFormat,
    #[doc = "< Width of the resource view"]
    pub width: usize,
    #[doc = "< Height of the resource view"]
    pub height: usize,
    #[doc = "< Depth of the resource view"]
    pub depth: usize,
    #[doc = "< First defined mipmap level"]
    pub firstMipmapLevel: ::std::os::raw::c_uint,
    #[doc = "< Last defined mipmap level"]
    pub lastMipmapLevel: ::std::os::raw::c_uint,
    #[doc = "< First layer index"]
    pub firstLayer: ::std::os::raw::c_uint,
    #[doc = "< Last layer index"]
    pub lastLayer: ::std::os::raw::c_uint,
    pub reserved: [::std::os::raw::c_uint; 16usize],
}
#[doc = " Resource view descriptor"]
pub type HIP_RESOURCE_VIEW_DESC = HIP_RESOURCE_VIEW_DESC_st;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum hipMemcpyKind {
    #[doc = "< Host-to-Host Copy"]
    hipMemcpyHostToHost = 0,
    #[doc = "< Host-to-Device Copy"]
    hipMemcpyHostToDevice = 1,
    #[doc = "< Device-to-Host Copy"]
    hipMemcpyDeviceToHost = 2,
    #[doc = "< Device-to-Device Copy"]
    hipMemcpyDeviceToDevice = 3,
    hipMemcpyDefault = 4,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hipPitchedPtr {
    pub ptr: *mut ::std::os::raw::c_void,
    pub pitch: usize,
    pub xsize: usize,
    pub ysize: usize,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hipExtent {
    pub width: usize,
    pub height: usize,
    pub depth: usize,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hipPos {
    pub x: usize,
    pub y: usize,
    pub z: usize,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hipMemcpy3DParms {
    pub srcArray: hipArray_t,
    pub srcPos: hipPos,
    pub srcPtr: hipPitchedPtr,
    pub dstArray: hipArray_t,
    pub dstPos: hipPos,
    pub dstPtr: hipPitchedPtr,
    pub extent: hipExtent,
    pub kind: hipMemcpyKind,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HIP_MEMCPY3D {
    pub srcXInBytes: usize,
    pub srcY: usize,
    pub srcZ: usize,
    pub srcLOD: usize,
    pub srcMemoryType: hipMemoryType,
    pub srcHost: *const ::std::os::raw::c_void,
    pub srcDevice: hipDeviceptr_t,
    pub srcArray: hipArray_t,
    pub srcPitch: usize,
    pub srcHeight: usize,
    pub dstXInBytes: usize,
    pub dstY: usize,
    pub dstZ: usize,
    pub dstLOD: usize,
    pub dstMemoryType: hipMemoryType,
    pub dstHost: *mut ::std::os::raw::c_void,
    pub dstDevice: hipDeviceptr_t,
    pub dstArray: hipArray_t,
    pub dstPitch: usize,
    pub dstHeight: usize,
    pub WidthInBytes: usize,
    pub Height: usize,
    pub Depth: usize,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum hipFunction_attribute {
    HIP_FUNC_ATTRIBUTE_MAX_THREADS_PER_BLOCK = 0,
    HIP_FUNC_ATTRIBUTE_SHARED_SIZE_BYTES = 1,
    HIP_FUNC_ATTRIBUTE_CONST_SIZE_BYTES = 2,
    HIP_FUNC_ATTRIBUTE_LOCAL_SIZE_BYTES = 3,
    HIP_FUNC_ATTRIBUTE_NUM_REGS = 4,
    HIP_FUNC_ATTRIBUTE_PTX_VERSION = 5,
    HIP_FUNC_ATTRIBUTE_BINARY_VERSION = 6,
    HIP_FUNC_ATTRIBUTE_CACHE_MODE_CA = 7,
    HIP_FUNC_ATTRIBUTE_MAX_DYNAMIC_SHARED_SIZE_BYTES = 8,
    HIP_FUNC_ATTRIBUTE_PREFERRED_SHARED_MEMORY_CARVEOUT = 9,
    HIP_FUNC_ATTRIBUTE_MAX = 10,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum hipPointer_attribute {
    #[doc = "< The context on which a pointer was allocated\n< @warning - not supported in HIP"]
    HIP_POINTER_ATTRIBUTE_CONTEXT = 1,
    #[doc = "< memory type describing location of a pointer"]
    HIP_POINTER_ATTRIBUTE_MEMORY_TYPE = 2,
    #[doc = "< address at which the pointer is allocated on device"]
    HIP_POINTER_ATTRIBUTE_DEVICE_POINTER = 3,
    #[doc = "< address at which the pointer is allocated on host"]
    HIP_POINTER_ATTRIBUTE_HOST_POINTER = 4,
    #[doc = "< A pair of tokens for use with linux kernel interface\n< @warning - not supported in HIP"]
    HIP_POINTER_ATTRIBUTE_P2P_TOKENS = 5,
    #[doc = "< Synchronize every synchronous memory operation\n< initiated on this region"]
    HIP_POINTER_ATTRIBUTE_SYNC_MEMOPS = 6,
    #[doc = "< Unique ID for an allocated memory region"]
    HIP_POINTER_ATTRIBUTE_BUFFER_ID = 7,
    #[doc = "< Indicates if the pointer points to managed memory"]
    HIP_POINTER_ATTRIBUTE_IS_MANAGED = 8,
    #[doc = "< device ordinal of a device on which a pointer\n< was allocated or registered"]
    HIP_POINTER_ATTRIBUTE_DEVICE_ORDINAL = 9,
    #[doc = "< if this pointer maps to an allocation\n< that is suitable for hipIpcGetMemHandle\n< @warning - not supported in HIP"]
    HIP_POINTER_ATTRIBUTE_IS_LEGACY_HIP_IPC_CAPABLE = 10,
    #[doc = "< Starting address for this requested pointer"]
    HIP_POINTER_ATTRIBUTE_RANGE_START_ADDR = 11,
    #[doc = "< Size of the address range for this requested pointer"]
    HIP_POINTER_ATTRIBUTE_RANGE_SIZE = 12,
    #[doc = "< tells if this pointer is in a valid address range\n< that is mapped to a backing allocation"]
    HIP_POINTER_ATTRIBUTE_MAPPED = 13,
    #[doc = "< Bitmask of allowed hipmemAllocationHandleType\n< for this allocation @warning - not supported in HIP"]
    HIP_POINTER_ATTRIBUTE_ALLOWED_HANDLE_TYPES = 14,
    #[doc = "< returns if the memory referenced by\n< this pointer can be used with the GPUDirect RDMA API\n< @warning - not supported in HIP"]
    HIP_POINTER_ATTRIBUTE_IS_GPU_DIRECT_RDMA_CAPABLE = 15,
    #[doc = "< Returns the access flags the device associated with\n< for the corresponding memory referenced by the ptr"]
    HIP_POINTER_ATTRIBUTE_ACCESS_FLAGS = 16,
    #[doc = "< Returns the mempool handle for the allocation if\n< it was allocated from a mempool\n< @warning - not supported in HIP"]
    HIP_POINTER_ATTRIBUTE_MEMPOOL_HANDLE = 17,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uchar1 {
    pub x: ::std::os::raw::c_uchar,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uchar2 {
    pub x: ::std::os::raw::c_uchar,
    pub y: ::std::os::raw::c_uchar,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uchar3 {
    pub x: ::std::os::raw::c_uchar,
    pub y: ::std::os::raw::c_uchar,
    pub z: ::std::os::raw::c_uchar,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uchar4 {
    pub x: ::std::os::raw::c_uchar,
    pub y: ::std::os::raw::c_uchar,
    pub z: ::std::os::raw::c_uchar,
    pub w: ::std::os::raw::c_uchar,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct char1 {
    pub x: ::std::os::raw::c_char,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct char2 {
    pub x: ::std::os::raw::c_char,
    pub y: ::std::os::raw::c_char,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct char3 {
    pub x: ::std::os::raw::c_char,
    pub y: ::std::os::raw::c_char,
    pub z: ::std::os::raw::c_char,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct char4 {
    pub x: ::std::os::raw::c_char,
    pub y: ::std::os::raw::c_char,
    pub z: ::std::os::raw::c_char,
    pub w: ::std::os::raw::c_char,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ushort1 {
    pub x: ::std::os::raw::c_ushort,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ushort2 {
    pub x: ::std::os::raw::c_ushort,
    pub y: ::std::os::raw::c_ushort,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ushort3 {
    pub x: ::std::os::raw::c_ushort,
    pub y: ::std::os::raw::c_ushort,
    pub z: ::std::os::raw::c_ushort,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ushort4 {
    pub x: ::std::os::raw::c_ushort,
    pub y: ::std::os::raw::c_ushort,
    pub z: ::std::os::raw::c_ushort,
    pub w: ::std::os::raw::c_ushort,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct short1 {
    pub x: ::std::os::raw::c_short,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct short2 {
    pub x: ::std::os::raw::c_short,
    pub y: ::std::os::raw::c_short,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct short3 {
    pub x: ::std::os::raw::c_short,
    pub y: ::std::os::raw::c_short,
    pub z: ::std::os::raw::c_short,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct short4 {
    pub x: ::std::os::raw::c_short,
    pub y: ::std::os::raw::c_short,
    pub z: ::std::os::raw::c_short,
    pub w: ::std::os::raw::c_short,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uint1 {
    pub x: ::std::os::raw::c_uint,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uint2 {
    pub x: ::std::os::raw::c_uint,
    pub y: ::std::os::raw::c_uint,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uint3 {
    pub x: ::std::os::raw::c_uint,
    pub y: ::std::os::raw::c_uint,
    pub z: ::std::os::raw::c_uint,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uint4 {
    pub x: ::std::os::raw::c_uint,
    pub y: ::std::os::raw::c_uint,
    pub z: ::std::os::raw::c_uint,
    pub w: ::std::os::raw::c_uint,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct int1 {
    pub x: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct int2 {
    pub x: ::std::os::raw::c_int,
    pub y: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct int3 {
    pub x: ::std::os::raw::c_int,
    pub y: ::std::os::raw::c_int,
    pub z: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct int4 {
    pub x: ::std::os::raw::c_int,
    pub y: ::std::os::raw::c_int,
    pub z: ::std::os::raw::c_int,
    pub w: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ulong1 {
    pub x: ::std::os::raw::c_ulong,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ulong2 {
    pub x: ::std::os::raw::c_ulong,
    pub y: ::std::os::raw::c_ulong,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ulong3 {
    pub x: ::std::os::raw::c_ulong,
    pub y: ::std::os::raw::c_ulong,
    pub z: ::std::os::raw::c_ulong,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ulong4 {
    pub x: ::std::os::raw::c_ulong,
    pub y: ::std::os::raw::c_ulong,
    pub z: ::std::os::raw::c_ulong,
    pub w: ::std::os::raw::c_ulong,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct long1 {
    pub x: ::std::os::raw::c_long,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct long2 {
    pub x: ::std::os::raw::c_long,
    pub y: ::std::os::raw::c_long,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct long3 {
    pub x: ::std::os::raw::c_long,
    pub y: ::std::os::raw::c_long,
    pub z: ::std::os::raw::c_long,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct long4 {
    pub x: ::std::os::raw::c_long,
    pub y: ::std::os::raw::c_long,
    pub z: ::std::os::raw::c_long,
    pub w: ::std::os::raw::c_long,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ulonglong1 {
    pub x: ::std::os::raw::c_ulonglong,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ulonglong2 {
    pub x: ::std::os::raw::c_ulonglong,
    pub y: ::std::os::raw::c_ulonglong,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ulonglong3 {
    pub x: ::std::os::raw::c_ulonglong,
    pub y: ::std::os::raw::c_ulonglong,
    pub z: ::std::os::raw::c_ulonglong,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ulonglong4 {
    pub x: ::std::os::raw::c_ulonglong,
    pub y: ::std::os::raw::c_ulonglong,
    pub z: ::std::os::raw::c_ulonglong,
    pub w: ::std::os::raw::c_ulonglong,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct longlong1 {
    pub x: ::std::os::raw::c_longlong,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct longlong2 {
    pub x: ::std::os::raw::c_longlong,
    pub y: ::std::os::raw::c_longlong,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct longlong3 {
    pub x: ::std::os::raw::c_longlong,
    pub y: ::std::os::raw::c_longlong,
    pub z: ::std::os::raw::c_longlong,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct longlong4 {
    pub x: ::std::os::raw::c_longlong,
    pub y: ::std::os::raw::c_longlong,
    pub z: ::std::os::raw::c_longlong,
    pub w: ::std::os::raw::c_longlong,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct float1 {
    pub x: f32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct float2 {
    pub x: f32,
    pub y: f32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct float3 {
    pub x: f32,
    pub y: f32,
    pub z: f32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct float4 {
    pub x: f32,
    pub y: f32,
    pub z: f32,
    pub w: f32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct double1 {
    pub x: f64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct double2 {
    pub x: f64,
    pub y: f64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct double3 {
    pub x: f64,
    pub y: f64,
    pub z: f64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct double4 {
    pub x: f64,
    pub y: f64,
    pub z: f64,
    pub w: f64,
}
extern "C" {
    pub fn hipCreateChannelDesc(
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
        z: ::std::os::raw::c_int,
        w: ::std::os::raw::c_int,
        f: hipChannelFormatKind,
    ) -> hipChannelFormatDesc;
}
#[doc = " An opaque value that represents a hip texture object"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __hip_texture {
    _unused: [u8; 0],
}
pub type hipTextureObject_t = *mut __hip_texture;
#[repr(u32)]
#[non_exhaustive]
#[doc = " hip texture address modes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum hipTextureAddressMode {
    hipAddressModeWrap = 0,
    hipAddressModeClamp = 1,
    hipAddressModeMirror = 2,
    hipAddressModeBorder = 3,
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " hip texture filter modes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum hipTextureFilterMode {
    hipFilterModePoint = 0,
    hipFilterModeLinear = 1,
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " hip texture read modes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum hipTextureReadMode {
    hipReadModeElementType = 0,
    hipReadModeNormalizedFloat = 1,
}
#[doc = " hip texture reference"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct textureReference {
    pub normalized: ::std::os::raw::c_int,
    pub readMode: hipTextureReadMode,
    pub filterMode: hipTextureFilterMode,
    pub addressMode: [hipTextureAddressMode; 3usize],
    pub channelDesc: hipChannelFormatDesc,
    pub sRGB: ::std::os::raw::c_int,
    pub maxAnisotropy: ::std::os::raw::c_uint,
    pub mipmapFilterMode: hipTextureFilterMode,
    pub mipmapLevelBias: f32,
    pub minMipmapLevelClamp: f32,
    pub maxMipmapLevelClamp: f32,
    pub textureObject: hipTextureObject_t,
    pub numChannels: ::std::os::raw::c_int,
    pub format: hipArray_Format,
}
#[doc = " hip texture descriptor"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hipTextureDesc {
    pub addressMode: [hipTextureAddressMode; 3usize],
    pub filterMode: hipTextureFilterMode,
    pub readMode: hipTextureReadMode,
    pub sRGB: ::std::os::raw::c_int,
    pub borderColor: [f32; 4usize],
    pub normalizedCoords: ::std::os::raw::c_int,
    pub maxAnisotropy: ::std::os::raw::c_uint,
    pub mipmapFilterMode: hipTextureFilterMode,
    pub mipmapLevelBias: f32,
    pub minMipmapLevelClamp: f32,
    pub maxMipmapLevelClamp: f32,
}
#[doc = " An opaque value that represents a hip surface object"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __hip_surface {
    _unused: [u8; 0],
}
pub type hipSurfaceObject_t = *mut __hip_surface;
#[doc = " hip surface reference"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct surfaceReference {
    pub surfaceObject: hipSurfaceObject_t,
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " hip surface boundary modes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum hipSurfaceBoundaryMode {
    hipBoundaryModeZero = 0,
    hipBoundaryModeTrap = 1,
    hipBoundaryModeClamp = 2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ihipCtx_t {
    _unused: [u8; 0],
}
pub type hipCtx_t = *mut ihipCtx_t;
pub type hipDevice_t = ::std::os::raw::c_int;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum hipDeviceP2PAttr {
    hipDevP2PAttrPerformanceRank = 0,
    hipDevP2PAttrAccessSupported = 1,
    hipDevP2PAttrNativeAtomicSupported = 2,
    hipDevP2PAttrHipArrayAccessSupported = 3,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ihipStream_t {
    _unused: [u8; 0],
}
pub type hipStream_t = *mut ihipStream_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hipIpcMemHandle_st {
    pub reserved: [::std::os::raw::c_char; 64usize],
}
pub type hipIpcMemHandle_t = hipIpcMemHandle_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hipIpcEventHandle_st {
    pub reserved: [::std::os::raw::c_char; 64usize],
}
pub type hipIpcEventHandle_t = hipIpcEventHandle_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ihipModule_t {
    _unused: [u8; 0],
}
pub type hipModule_t = *mut ihipModule_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ihipModuleSymbol_t {
    _unused: [u8; 0],
}
pub type hipFunction_t = *mut ihipModuleSymbol_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ihipMemPoolHandle_t {
    _unused: [u8; 0],
}
#[doc = " HIP memory pool"]
pub type hipMemPool_t = *mut ihipMemPoolHandle_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hipFuncAttributes {
    pub binaryVersion: ::std::os::raw::c_int,
    pub cacheModeCA: ::std::os::raw::c_int,
    pub constSizeBytes: usize,
    pub localSizeBytes: usize,
    pub maxDynamicSharedSizeBytes: ::std::os::raw::c_int,
    pub maxThreadsPerBlock: ::std::os::raw::c_int,
    pub numRegs: ::std::os::raw::c_int,
    pub preferredShmemCarveout: ::std::os::raw::c_int,
    pub ptxVersion: ::std::os::raw::c_int,
    pub sharedSizeBytes: usize,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ihipEvent_t {
    _unused: [u8; 0],
}
pub type hipEvent_t = *mut ihipEvent_t;
#[repr(u32)]
#[non_exhaustive]
#[doc = " hipLimit\n\n @note In HIP device limit-related APIs, any input limit value other than those defined in the\n enum is treated as \"UnsupportedLimit\" by default."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum hipLimit_t {
    #[doc = "< Limit of stack size in bytes on the current device, per\n< thread. The size is in units of 256 dwords, up to the\n< limit of (128K - 16)"]
    hipLimitStackSize = 0,
    #[doc = "< Size limit in bytes of fifo used by printf call on the\n< device. Currently not supported"]
    hipLimitPrintfFifoSize = 1,
    #[doc = "< Limit of heap size in bytes on the current device, should\n< be less than the global memory size on the device"]
    hipLimitMallocHeapSize = 2,
    #[doc = "< Supported limit range"]
    hipLimitRange = 3,
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " HIP Memory Advise values\n\n @note This memory advise enumeration is used on Linux, not Windows."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum hipMemoryAdvise {
    #[doc = "< Data will mostly be read and only occassionally\n< be written to"]
    hipMemAdviseSetReadMostly = 1,
    #[doc = "< Undo the effect of hipMemAdviseSetReadMostly"]
    hipMemAdviseUnsetReadMostly = 2,
    #[doc = "< Set the preferred location for the data as\n< the specified device"]
    hipMemAdviseSetPreferredLocation = 3,
    #[doc = "< Clear the preferred location for the data"]
    hipMemAdviseUnsetPreferredLocation = 4,
    #[doc = "< Data will be accessed by the specified device\n< so prevent page faults as much as possible"]
    hipMemAdviseSetAccessedBy = 5,
    #[doc = "< Let HIP to decide on the page faulting policy\n< for the specified device"]
    hipMemAdviseUnsetAccessedBy = 6,
    #[doc = "< The default memory model is fine-grain. That allows\n< coherent operations between host and device, while\n< executing kernels. The coarse-grain can be used\n< for data that only needs to be coherent at dispatch\n< boundaries for better performance"]
    hipMemAdviseSetCoarseGrain = 100,
    #[doc = "< Restores cache coherency policy back to fine-grain"]
    hipMemAdviseUnsetCoarseGrain = 101,
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " HIP Coherency Mode"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum hipMemRangeCoherencyMode {
    #[doc = "< Updates to memory with this attribute can be\n< done coherently from all devices"]
    hipMemRangeCoherencyModeFineGrain = 0,
    #[doc = "< Writes to memory with this attribute can be\n< performed by a single device at a time"]
    hipMemRangeCoherencyModeCoarseGrain = 1,
    #[doc = "< Memory region queried contains subregions with\n< both hipMemRangeCoherencyModeFineGrain and\n< hipMemRangeCoherencyModeCoarseGrain attributes"]
    hipMemRangeCoherencyModeIndeterminate = 2,
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " HIP range attributes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum hipMemRangeAttribute {
    #[doc = "< Whether the range will mostly be read and\n< only occassionally be written to"]
    hipMemRangeAttributeReadMostly = 1,
    #[doc = "< The preferred location of the range"]
    hipMemRangeAttributePreferredLocation = 2,
    #[doc = "< Memory range has hipMemAdviseSetAccessedBy\n< set for the specified device"]
    hipMemRangeAttributeAccessedBy = 3,
    #[doc = "< The last location to where the range was\n< prefetched"]
    hipMemRangeAttributeLastPrefetchLocation = 4,
    #[doc = "< Returns coherency mode\n< @ref hipMemRangeCoherencyMode for the range"]
    hipMemRangeAttributeCoherencyMode = 100,
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " HIP memory pool attributes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum hipMemPoolAttr {
    #[doc = " (value type = int)\n Allow @p hipMemAllocAsync to use memory asynchronously freed\n in another streams as long as a stream ordering dependency\n of the allocating stream on the free action exists.\n hip events and null stream interactions can create the required\n stream ordered dependencies. (default enabled)"]
    hipMemPoolReuseFollowEventDependencies = 1,
    #[doc = " (value type = int)\n Allow reuse of already completed frees when there is no dependency\n between the free and allocation. (default enabled)"]
    hipMemPoolReuseAllowOpportunistic = 2,
    #[doc = " (value type = int)\n Allow @p hipMemAllocAsync to insert new stream dependencies\n in order to establish the stream ordering required to reuse\n a piece of memory released by cuFreeAsync (default enabled)."]
    hipMemPoolReuseAllowInternalDependencies = 3,
    #[doc = " (value type = uint64_t)\n Amount of reserved memory in bytes to hold onto before trying\n to release memory back to the OS. When more than the release\n threshold bytes of memory are held by the memory pool, the\n allocator will try to release memory back to the OS on the\n next call to stream, event or context synchronize. (default 0)"]
    hipMemPoolAttrReleaseThreshold = 4,
    #[doc = " (value type = uint64_t)\n Amount of backing memory currently allocated for the mempool."]
    hipMemPoolAttrReservedMemCurrent = 5,
    #[doc = " (value type = uint64_t)\n High watermark of backing memory allocated for the mempool since the\n last time it was reset. High watermark can only be reset to zero."]
    hipMemPoolAttrReservedMemHigh = 6,
    #[doc = " (value type = uint64_t)\n Amount of memory from the pool that is currently in use by the application."]
    hipMemPoolAttrUsedMemCurrent = 7,
    #[doc = " (value type = uint64_t)\n High watermark of the amount of memory from the pool that was in use by the application since\n the last time it was reset. High watermark can only be reset to zero."]
    hipMemPoolAttrUsedMemHigh = 8,
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " Specifies the type of location"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum hipMemLocationType {
    hipMemLocationTypeInvalid = 0,
    #[doc = "< Device location, thus it's HIP device ID"]
    hipMemLocationTypeDevice = 1,
}
#[doc = " Specifies a memory location.\n\n To specify a gpu, set type = @p hipMemLocationTypeDevice and set id = the gpu's device ID"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hipMemLocation {
    #[doc = "< Specifies the location type, which describes the meaning of id"]
    pub type_: hipMemLocationType,
    #[doc = "< Identifier for the provided location type @p hipMemLocationType"]
    pub id: ::std::os::raw::c_int,
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " Specifies the memory protection flags for mapping\n"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum hipMemAccessFlags {
    #[doc = "< Default, make the address range not accessible"]
    hipMemAccessFlagsProtNone = 0,
    #[doc = "< Set the address range read accessible"]
    hipMemAccessFlagsProtRead = 1,
    #[doc = "< Set the address range read-write accessible"]
    hipMemAccessFlagsProtReadWrite = 3,
}
#[doc = " Memory access descriptor"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hipMemAccessDesc {
    #[doc = "< Location on which the accessibility has to change"]
    pub location: hipMemLocation,
    #[doc = "< Accessibility flags to set"]
    pub flags: hipMemAccessFlags,
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " Defines the allocation types"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum hipMemAllocationType {
    hipMemAllocationTypeInvalid = 0,
    #[doc = " This allocation type is 'pinned', i.e. cannot migrate from its current\n location while the application is actively using it"]
    hipMemAllocationTypePinned = 1,
    #[doc = " This allocation type is 'pinned', i.e. cannot migrate from its current\n location while the application is actively using it"]
    hipMemAllocationTypeMax = 2147483647,
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " Flags for specifying handle types for memory pool allocations\n"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum hipMemAllocationHandleType {
    #[doc = "< Does not allow any export mechanism"]
    hipMemHandleTypeNone = 0,
    #[doc = "< Allows a file descriptor for exporting. Permitted only on POSIX systems"]
    hipMemHandleTypePosixFileDescriptor = 1,
    #[doc = "< Allows a Win32 NT handle for exporting. (HANDLE)"]
    hipMemHandleTypeWin32 = 2,
    #[doc = "< Allows a Win32 KMT handle for exporting. (D3DKMT_HANDLE)"]
    hipMemHandleTypeWin32Kmt = 4,
}
#[doc = " Specifies the properties of allocations made from the pool."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hipMemPoolProps {
    #[doc = "< Allocation type. Currently must be specified as @p hipMemAllocationTypePinned"]
    pub allocType: hipMemAllocationType,
    #[doc = "< Handle types that will be supported by allocations from the pool"]
    pub handleTypes: hipMemAllocationHandleType,
    #[doc = "< Location where allocations should reside"]
    pub location: hipMemLocation,
    #[doc = " Windows-specific LPSECURITYATTRIBUTES required when @p hipMemHandleTypeWin32 is specified"]
    pub win32SecurityAttributes: *mut ::std::os::raw::c_void,
    #[doc = "< Reserved for future use, must be 0"]
    pub reserved: [::std::os::raw::c_uchar; 64usize],
}
#[doc = " Opaque data structure for exporting a pool allocation"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hipMemPoolPtrExportData {
    pub reserved: [::std::os::raw::c_uchar; 64usize],
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " hipJitOption"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum hipJitOption {
    hipJitOptionMaxRegisters = 0,
    hipJitOptionThreadsPerBlock = 1,
    hipJitOptionWallTime = 2,
    hipJitOptionInfoLogBuffer = 3,
    hipJitOptionInfoLogBufferSizeBytes = 4,
    hipJitOptionErrorLogBuffer = 5,
    hipJitOptionErrorLogBufferSizeBytes = 6,
    hipJitOptionOptimizationLevel = 7,
    hipJitOptionTargetFromContext = 8,
    hipJitOptionTarget = 9,
    hipJitOptionFallbackStrategy = 10,
    hipJitOptionGenerateDebugInfo = 11,
    hipJitOptionLogVerbose = 12,
    hipJitOptionGenerateLineInfo = 13,
    hipJitOptionCacheMode = 14,
    hipJitOptionSm3xOpt = 15,
    hipJitOptionFastCompile = 16,
    hipJitOptionNumOptions = 17,
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " @warning On AMD devices and some Nvidia devices, these hints and controls are ignored."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum hipFuncAttribute {
    hipFuncAttributeMaxDynamicSharedMemorySize = 8,
    hipFuncAttributePreferredSharedMemoryCarveout = 9,
    hipFuncAttributeMax = 10,
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " @warning On AMD devices and some Nvidia devices, these hints and controls are ignored."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum hipFuncCache_t {
    #[doc = "< no preference for shared memory or L1 (default)"]
    hipFuncCachePreferNone = 0,
    #[doc = "< prefer larger shared memory and smaller L1 cache"]
    hipFuncCachePreferShared = 1,
    #[doc = "< prefer larger L1 cache and smaller shared memory"]
    hipFuncCachePreferL1 = 2,
    #[doc = "< prefer equal size L1 cache and shared memory"]
    hipFuncCachePreferEqual = 3,
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " @warning On AMD devices and some Nvidia devices, these hints and controls are ignored."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum hipSharedMemConfig {
    #[doc = "< The compiler selects a device-specific value for the banking."]
    hipSharedMemBankSizeDefault = 0,
    #[doc = "< Shared mem is banked at 4-bytes intervals and performs best\n< when adjacent threads access data 4 bytes apart."]
    hipSharedMemBankSizeFourByte = 1,
    #[doc = "< Shared mem is banked at 8-byte intervals and performs best\n< when adjacent threads access data 4 bytes apart."]
    hipSharedMemBankSizeEightByte = 2,
}
#[doc = " Struct for data in 3D"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dim3 {
    #[doc = "< x"]
    pub x: u32,
    #[doc = "< y"]
    pub y: u32,
    #[doc = "< z"]
    pub z: u32,
}
#[doc = " struct hipLaunchParams_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hipLaunchParams_t {
    #[doc = "< Device function symbol"]
    pub func: *mut ::std::os::raw::c_void,
    #[doc = "< Grid dimentions"]
    pub gridDim: dim3,
    #[doc = "< Block dimentions"]
    pub blockDim: dim3,
    #[doc = "< Arguments"]
    pub args: *mut *mut ::std::os::raw::c_void,
    #[doc = "< Shared memory"]
    pub sharedMem: usize,
    #[doc = "< Stream identifier"]
    pub stream: hipStream_t,
}
#[doc = " struct hipLaunchParams_t"]
pub type hipLaunchParams = hipLaunchParams_t;
#[doc = " struct hipFunctionLaunchParams_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hipFunctionLaunchParams_t {
    #[doc = "< Kernel to launch"]
    pub function: hipFunction_t,
    #[doc = "< Width(X) of grid in blocks"]
    pub gridDimX: ::std::os::raw::c_uint,
    #[doc = "< Height(Y) of grid in blocks"]
    pub gridDimY: ::std::os::raw::c_uint,
    #[doc = "< Depth(Z) of grid in blocks"]
    pub gridDimZ: ::std::os::raw::c_uint,
    #[doc = "< X dimension of each thread block"]
    pub blockDimX: ::std::os::raw::c_uint,
    #[doc = "< Y dimension of each thread block"]
    pub blockDimY: ::std::os::raw::c_uint,
    #[doc = "< Z dimension of each thread block"]
    pub blockDimZ: ::std::os::raw::c_uint,
    #[doc = "< Shared memory"]
    pub sharedMemBytes: ::std::os::raw::c_uint,
    #[doc = "< Stream identifier"]
    pub hStream: hipStream_t,
    #[doc = "< Kernel parameters"]
    pub kernelParams: *mut *mut ::std::os::raw::c_void,
}
#[doc = " struct hipFunctionLaunchParams_t"]
pub type hipFunctionLaunchParams = hipFunctionLaunchParams_t;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum hipExternalMemoryHandleType_enum {
    hipExternalMemoryHandleTypeOpaqueFd = 1,
    hipExternalMemoryHandleTypeOpaqueWin32 = 2,
    hipExternalMemoryHandleTypeOpaqueWin32Kmt = 3,
    hipExternalMemoryHandleTypeD3D12Heap = 4,
    hipExternalMemoryHandleTypeD3D12Resource = 5,
    hipExternalMemoryHandleTypeD3D11Resource = 6,
    hipExternalMemoryHandleTypeD3D11ResourceKmt = 7,
    hipExternalMemoryHandleTypeNvSciBuf = 8,
}
pub use self::hipExternalMemoryHandleType_enum as hipExternalMemoryHandleType;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct hipExternalMemoryHandleDesc_st {
    pub type_: hipExternalMemoryHandleType,
    pub handle: hipExternalMemoryHandleDesc_st__bindgen_ty_1,
    pub size: ::std::os::raw::c_ulonglong,
    pub flags: ::std::os::raw::c_uint,
    pub reserved: [::std::os::raw::c_uint; 16usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union hipExternalMemoryHandleDesc_st__bindgen_ty_1 {
    pub fd: ::std::os::raw::c_int,
    pub win32: hipExternalMemoryHandleDesc_st__bindgen_ty_1__bindgen_ty_1,
    pub nvSciBufObject: *const ::std::os::raw::c_void,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hipExternalMemoryHandleDesc_st__bindgen_ty_1__bindgen_ty_1 {
    pub handle: *mut ::std::os::raw::c_void,
    pub name: *const ::std::os::raw::c_void,
}
pub type hipExternalMemoryHandleDesc = hipExternalMemoryHandleDesc_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hipExternalMemoryBufferDesc_st {
    pub offset: ::std::os::raw::c_ulonglong,
    pub size: ::std::os::raw::c_ulonglong,
    pub flags: ::std::os::raw::c_uint,
    pub reserved: [::std::os::raw::c_uint; 16usize],
}
pub type hipExternalMemoryBufferDesc = hipExternalMemoryBufferDesc_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hipExternalMemoryMipmappedArrayDesc_st {
    pub offset: ::std::os::raw::c_ulonglong,
    pub formatDesc: hipChannelFormatDesc,
    pub extent: hipExtent,
    pub flags: ::std::os::raw::c_uint,
    pub numLevels: ::std::os::raw::c_uint,
}
pub type hipExternalMemoryMipmappedArrayDesc = hipExternalMemoryMipmappedArrayDesc_st;
pub type hipExternalMemory_t = *mut ::std::os::raw::c_void;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum hipExternalSemaphoreHandleType_enum {
    hipExternalSemaphoreHandleTypeOpaqueFd = 1,
    hipExternalSemaphoreHandleTypeOpaqueWin32 = 2,
    hipExternalSemaphoreHandleTypeOpaqueWin32Kmt = 3,
    hipExternalSemaphoreHandleTypeD3D12Fence = 4,
    hipExternalSemaphoreHandleTypeD3D11Fence = 5,
    hipExternalSemaphoreHandleTypeNvSciSync = 6,
    hipExternalSemaphoreHandleTypeKeyedMutex = 7,
    hipExternalSemaphoreHandleTypeKeyedMutexKmt = 8,
    hipExternalSemaphoreHandleTypeTimelineSemaphoreFd = 9,
    hipExternalSemaphoreHandleTypeTimelineSemaphoreWin32 = 10,
}
pub use self::hipExternalSemaphoreHandleType_enum as hipExternalSemaphoreHandleType;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct hipExternalSemaphoreHandleDesc_st {
    pub type_: hipExternalSemaphoreHandleType,
    pub handle: hipExternalSemaphoreHandleDesc_st__bindgen_ty_1,
    pub flags: ::std::os::raw::c_uint,
    pub reserved: [::std::os::raw::c_uint; 16usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union hipExternalSemaphoreHandleDesc_st__bindgen_ty_1 {
    pub fd: ::std::os::raw::c_int,
    pub win32: hipExternalSemaphoreHandleDesc_st__bindgen_ty_1__bindgen_ty_1,
    pub NvSciSyncObj: *const ::std::os::raw::c_void,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hipExternalSemaphoreHandleDesc_st__bindgen_ty_1__bindgen_ty_1 {
    pub handle: *mut ::std::os::raw::c_void,
    pub name: *const ::std::os::raw::c_void,
}
pub type hipExternalSemaphoreHandleDesc = hipExternalSemaphoreHandleDesc_st;
pub type hipExternalSemaphore_t = *mut ::std::os::raw::c_void;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct hipExternalSemaphoreSignalParams_st {
    pub params: hipExternalSemaphoreSignalParams_st__bindgen_ty_1,
    pub flags: ::std::os::raw::c_uint,
    pub reserved: [::std::os::raw::c_uint; 16usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct hipExternalSemaphoreSignalParams_st__bindgen_ty_1 {
    pub fence: hipExternalSemaphoreSignalParams_st__bindgen_ty_1__bindgen_ty_1,
    pub nvSciSync: hipExternalSemaphoreSignalParams_st__bindgen_ty_1__bindgen_ty_2,
    pub keyedMutex: hipExternalSemaphoreSignalParams_st__bindgen_ty_1__bindgen_ty_3,
    pub reserved: [::std::os::raw::c_uint; 12usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hipExternalSemaphoreSignalParams_st__bindgen_ty_1__bindgen_ty_1 {
    pub value: ::std::os::raw::c_ulonglong,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union hipExternalSemaphoreSignalParams_st__bindgen_ty_1__bindgen_ty_2 {
    pub fence: *mut ::std::os::raw::c_void,
    pub reserved: ::std::os::raw::c_ulonglong,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hipExternalSemaphoreSignalParams_st__bindgen_ty_1__bindgen_ty_3 {
    pub key: ::std::os::raw::c_ulonglong,
}
pub type hipExternalSemaphoreSignalParams = hipExternalSemaphoreSignalParams_st;
#[doc = " External semaphore wait parameters, compatible with driver type"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct hipExternalSemaphoreWaitParams_st {
    pub params: hipExternalSemaphoreWaitParams_st__bindgen_ty_1,
    pub flags: ::std::os::raw::c_uint,
    pub reserved: [::std::os::raw::c_uint; 16usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct hipExternalSemaphoreWaitParams_st__bindgen_ty_1 {
    pub fence: hipExternalSemaphoreWaitParams_st__bindgen_ty_1__bindgen_ty_1,
    pub nvSciSync: hipExternalSemaphoreWaitParams_st__bindgen_ty_1__bindgen_ty_2,
    pub keyedMutex: hipExternalSemaphoreWaitParams_st__bindgen_ty_1__bindgen_ty_3,
    pub reserved: [::std::os::raw::c_uint; 10usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hipExternalSemaphoreWaitParams_st__bindgen_ty_1__bindgen_ty_1 {
    pub value: ::std::os::raw::c_ulonglong,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union hipExternalSemaphoreWaitParams_st__bindgen_ty_1__bindgen_ty_2 {
    pub fence: *mut ::std::os::raw::c_void,
    pub reserved: ::std::os::raw::c_ulonglong,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hipExternalSemaphoreWaitParams_st__bindgen_ty_1__bindgen_ty_3 {
    pub key: ::std::os::raw::c_ulonglong,
    pub timeoutMs: ::std::os::raw::c_uint,
}
#[doc = " External semaphore wait parameters, compatible with driver type"]
pub type hipExternalSemaphoreWaitParams = hipExternalSemaphoreWaitParams_st;
extern "C" {
    #[doc = " Internal use only. This API may change in the future\n Pre-Compiled header for online compilation"]
    pub fn __hipGetPCH(pch: *mut *const ::std::os::raw::c_char, size: *mut ::std::os::raw::c_uint);
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " HIP Access falgs for Interop resources."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum hipGraphicsRegisterFlags {
    hipGraphicsRegisterFlagsNone = 0,
    #[doc = "< HIP will not write to this registered resource"]
    hipGraphicsRegisterFlagsReadOnly = 1,
    hipGraphicsRegisterFlagsWriteDiscard = 2,
    #[doc = "< HIP will bind this resource to a surface"]
    hipGraphicsRegisterFlagsSurfaceLoadStore = 4,
    hipGraphicsRegisterFlagsTextureGather = 8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _hipGraphicsResource {
    _unused: [u8; 0],
}
pub type hipGraphicsResource = _hipGraphicsResource;
pub type hipGraphicsResource_t = *mut hipGraphicsResource;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ihipGraph {
    _unused: [u8; 0],
}
#[doc = " An opaque value that represents a hip graph"]
pub type hipGraph_t = *mut ihipGraph;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hipGraphNode {
    _unused: [u8; 0],
}
#[doc = " An opaque value that represents a hip graph node"]
pub type hipGraphNode_t = *mut hipGraphNode;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hipGraphExec {
    _unused: [u8; 0],
}
#[doc = " An opaque value that represents a hip graph Exec"]
pub type hipGraphExec_t = *mut hipGraphExec;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hipUserObject {
    _unused: [u8; 0],
}
#[doc = " An opaque value that represents a user obj"]
pub type hipUserObject_t = *mut hipUserObject;
#[repr(u32)]
#[non_exhaustive]
#[doc = " hipGraphNodeType"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum hipGraphNodeType {
    #[doc = "< GPU kernel node"]
    hipGraphNodeTypeKernel = 0,
    #[doc = "< Memcpy node"]
    hipGraphNodeTypeMemcpy = 1,
    #[doc = "< Memset node"]
    hipGraphNodeTypeMemset = 2,
    #[doc = "< Host (executable) node"]
    hipGraphNodeTypeHost = 3,
    #[doc = "< Node which executes an embedded graph"]
    hipGraphNodeTypeGraph = 4,
    #[doc = "< Empty (no-op) node"]
    hipGraphNodeTypeEmpty = 5,
    #[doc = "< External event wait node"]
    hipGraphNodeTypeWaitEvent = 6,
    #[doc = "< External event record node"]
    hipGraphNodeTypeEventRecord = 7,
    #[doc = "< External Semaphore signal node"]
    hipGraphNodeTypeExtSemaphoreSignal = 8,
    #[doc = "< External Semaphore wait node"]
    hipGraphNodeTypeExtSemaphoreWait = 9,
    #[doc = "< Memory alloc node"]
    hipGraphNodeTypeMemAlloc = 10,
    #[doc = "< Memory free node"]
    hipGraphNodeTypeMemFree = 11,
    #[doc = "< MemcpyFromSymbol node"]
    hipGraphNodeTypeMemcpyFromSymbol = 12,
    #[doc = "< MemcpyToSymbol node"]
    hipGraphNodeTypeMemcpyToSymbol = 13,
    hipGraphNodeTypeCount = 14,
}
pub type hipHostFn_t =
    ::std::option::Option<unsafe extern "C" fn(userData: *mut ::std::os::raw::c_void)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hipHostNodeParams {
    pub fn_: hipHostFn_t,
    pub userData: *mut ::std::os::raw::c_void,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hipKernelNodeParams {
    pub blockDim: dim3,
    pub extra: *mut *mut ::std::os::raw::c_void,
    pub func: *mut ::std::os::raw::c_void,
    pub gridDim: dim3,
    pub kernelParams: *mut *mut ::std::os::raw::c_void,
    pub sharedMemBytes: ::std::os::raw::c_uint,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hipMemsetParams {
    pub dst: *mut ::std::os::raw::c_void,
    pub elementSize: ::std::os::raw::c_uint,
    pub height: usize,
    pub pitch: usize,
    pub value: ::std::os::raw::c_uint,
    pub width: usize,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hipMemAllocNodeParams {
    #[doc = "< Pool properties, which contain where\n< the location should reside"]
    pub poolProps: hipMemPoolProps,
    #[doc = "< The number of memory access descriptors.\n< Must not be bigger than the number of GPUs"]
    pub accessDescs: *const hipMemAccessDesc,
    #[doc = "< The number of access descriptors"]
    pub accessDescCount: usize,
    #[doc = "< The size of the requested allocation in bytes"]
    pub bytesize: usize,
    #[doc = "< Returned device address of the allocation"]
    pub dptr: *mut ::std::os::raw::c_void,
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " Kernel node attributeID"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum hipKernelNodeAttrID {
    hipKernelNodeAttributeAccessPolicyWindow = 1,
    hipKernelNodeAttributeCooperative = 2,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum hipAccessProperty {
    hipAccessPropertyNormal = 0,
    hipAccessPropertyStreaming = 1,
    hipAccessPropertyPersisting = 2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hipAccessPolicyWindow {
    pub base_ptr: *mut ::std::os::raw::c_void,
    pub hitProp: hipAccessProperty,
    pub hitRatio: f32,
    pub missProp: hipAccessProperty,
    pub num_bytes: usize,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union hipKernelNodeAttrValue {
    pub accessPolicyWindow: hipAccessPolicyWindow,
    pub cooperative: ::std::os::raw::c_int,
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " Graph execution update result"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum hipGraphExecUpdateResult {
    #[doc = "< The update succeeded"]
    hipGraphExecUpdateSuccess = 0,
    #[doc = "< The update failed for an unexpected reason which is described\n< in the return value of the function"]
    hipGraphExecUpdateError = 1,
    #[doc = "< The update failed because the topology changed"]
    hipGraphExecUpdateErrorTopologyChanged = 2,
    #[doc = "< The update failed because a node type changed"]
    hipGraphExecUpdateErrorNodeTypeChanged = 3,
    hipGraphExecUpdateErrorFunctionChanged = 4,
    hipGraphExecUpdateErrorParametersChanged = 5,
    hipGraphExecUpdateErrorNotSupported = 6,
    hipGraphExecUpdateErrorUnsupportedFunctionChange = 7,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum hipStreamCaptureMode {
    hipStreamCaptureModeGlobal = 0,
    hipStreamCaptureModeThreadLocal = 1,
    hipStreamCaptureModeRelaxed = 2,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum hipStreamCaptureStatus {
    #[doc = "< Stream is not capturing"]
    hipStreamCaptureStatusNone = 0,
    #[doc = "< Stream is actively capturing"]
    hipStreamCaptureStatusActive = 1,
    #[doc = "< Stream is part of a capture sequence that has been\n< invalidated, but not terminated"]
    hipStreamCaptureStatusInvalidated = 2,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum hipStreamUpdateCaptureDependenciesFlags {
    #[doc = "< Add new nodes to the dependency set"]
    hipStreamAddCaptureDependencies = 0,
    #[doc = "< Replace the dependency set with the new nodes"]
    hipStreamSetCaptureDependencies = 1,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum hipGraphMemAttributeType {
    #[doc = "< Amount of memory, in bytes, currently associated with graphs"]
    hipGraphMemAttrUsedMemCurrent = 0,
    #[doc = "< High watermark of memory, in bytes, associated with graphs since the last time."]
    hipGraphMemAttrUsedMemHigh = 1,
    #[doc = "< Amount of memory, in bytes, currently allocated for graphs."]
    hipGraphMemAttrReservedMemCurrent = 2,
    #[doc = "< High watermark of memory, in bytes, currently allocated for graphs"]
    hipGraphMemAttrReservedMemHigh = 3,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum hipUserObjectFlags {
    #[doc = "< Destructor execution is not synchronized."]
    hipUserObjectNoDestructorSync = 1,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum hipUserObjectRetainFlags {
    #[doc = "< Add new reference or retain."]
    hipGraphUserObjectMove = 1,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum hipGraphInstantiateFlags {
    hipGraphInstantiateFlagAutoFreeOnLaunch = 1,
    hipGraphInstantiateFlagUpload = 2,
    hipGraphInstantiateFlagDeviceLaunch = 4,
    hipGraphInstantiateFlagUseNodePriority = 8,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum hipGraphDebugDotFlags {
    hipGraphDebugDotFlagsVerbose = 1,
    #[doc = "< Adds hipKernelNodeParams to output"]
    hipGraphDebugDotFlagsKernelNodeParams = 4,
    #[doc = "< Adds hipMemcpy3DParms to output"]
    hipGraphDebugDotFlagsMemcpyNodeParams = 8,
    #[doc = "< Adds hipMemsetParams to output"]
    hipGraphDebugDotFlagsMemsetNodeParams = 16,
    #[doc = "< Adds hipHostNodeParams to output"]
    hipGraphDebugDotFlagsHostNodeParams = 32,
    hipGraphDebugDotFlagsEventNodeParams = 64,
    hipGraphDebugDotFlagsExtSemasSignalNodeParams = 128,
    hipGraphDebugDotFlagsExtSemasWaitNodeParams = 256,
    hipGraphDebugDotFlagsKernelNodeAttributes = 512,
    hipGraphDebugDotFlagsHandles = 1024,
}
#[doc = " Memory allocation properties"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hipMemAllocationProp {
    #[doc = "< Memory allocation type"]
    pub type_: hipMemAllocationType,
    #[doc = "< Requested handle type"]
    pub requestedHandleType: hipMemAllocationHandleType,
    #[doc = "< Memory location"]
    pub location: hipMemLocation,
    #[doc = "< Metadata for Win32 handles"]
    pub win32HandleMetaData: *mut ::std::os::raw::c_void,
    pub allocFlags: hipMemAllocationProp__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hipMemAllocationProp__bindgen_ty_1 {
    #[doc = "< Compression type"]
    pub compressionType: ::std::os::raw::c_uchar,
    #[doc = "< RDMA capable"]
    pub gpuDirectRDMACapable: ::std::os::raw::c_uchar,
    #[doc = "< Usage"]
    pub usage: ::std::os::raw::c_ushort,
}
#[doc = " External semaphore signal node parameters"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hipExternalSemaphoreSignalNodeParams {
    pub extSemArray: *mut hipExternalSemaphore_t,
    pub paramsArray: *const hipExternalSemaphoreSignalParams,
    pub numExtSems: ::std::os::raw::c_uint,
}
#[doc = " External semaphore wait node parameters"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hipExternalSemaphoreWaitNodeParams {
    pub extSemArray: *mut hipExternalSemaphore_t,
    pub paramsArray: *const hipExternalSemaphoreWaitParams,
    pub numExtSems: ::std::os::raw::c_uint,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ihipMemGenericAllocationHandle {
    _unused: [u8; 0],
}
#[doc = " Generic handle for memory allocation"]
pub type hipMemGenericAllocationHandle_t = *mut ihipMemGenericAllocationHandle;
#[repr(u32)]
#[non_exhaustive]
#[doc = " Flags for granularity"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum hipMemAllocationGranularity_flags {
    #[doc = "< Minimum granularity"]
    hipMemAllocationGranularityMinimum = 0,
    #[doc = "< Recommended granularity for performance"]
    hipMemAllocationGranularityRecommended = 1,
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " Memory handle type"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum hipMemHandleType {
    #[doc = "< Generic handle type"]
    hipMemHandleTypeGeneric = 0,
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " Memory operation types"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum hipMemOperationType {
    #[doc = "< Map operation"]
    hipMemOperationTypeMap = 1,
    #[doc = "< Unmap operation"]
    hipMemOperationTypeUnmap = 2,
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " Subresource types for sparse arrays"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum hipArraySparseSubresourceType {
    #[doc = "< Sparse level"]
    hipArraySparseSubresourceTypeSparseLevel = 0,
    #[doc = "< Miptail"]
    hipArraySparseSubresourceTypeMiptail = 1,
}
#[doc = " Map info for arrays"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct hipArrayMapInfo {
    #[doc = "< Resource type"]
    pub resourceType: hipResourceType,
    pub resource: hipArrayMapInfo__bindgen_ty_1,
    #[doc = "< Sparse subresource type"]
    pub subresourceType: hipArraySparseSubresourceType,
    pub subresource: hipArrayMapInfo__bindgen_ty_2,
    #[doc = "< Memory operation type"]
    pub memOperationType: hipMemOperationType,
    #[doc = "< Memory handle type"]
    pub memHandleType: hipMemHandleType,
    pub memHandle: hipArrayMapInfo__bindgen_ty_3,
    #[doc = "< Offset within the memory"]
    pub offset: ::std::os::raw::c_ulonglong,
    #[doc = "< Device ordinal bit mask"]
    pub deviceBitMask: ::std::os::raw::c_uint,
    #[doc = "< flags for future use, must be zero now."]
    pub flags: ::std::os::raw::c_uint,
    #[doc = "< Reserved for future use, must be zero now."]
    pub reserved: [::std::os::raw::c_uint; 2usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union hipArrayMapInfo__bindgen_ty_1 {
    pub mipmap: hipMipmappedArray,
    pub array: hipArray_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union hipArrayMapInfo__bindgen_ty_2 {
    pub sparseLevel: hipArrayMapInfo__bindgen_ty_2__bindgen_ty_1,
    pub miptail: hipArrayMapInfo__bindgen_ty_2__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hipArrayMapInfo__bindgen_ty_2__bindgen_ty_1 {
    #[doc = "< For mipmapped arrays must be a valid mipmap level. For arrays must be zero"]
    pub level: ::std::os::raw::c_uint,
    #[doc = "< For layered arrays must be a valid layer index. Otherwise, must be zero"]
    pub layer: ::std::os::raw::c_uint,
    #[doc = "< X offset in elements"]
    pub offsetX: ::std::os::raw::c_uint,
    #[doc = "< Y offset in elements"]
    pub offsetY: ::std::os::raw::c_uint,
    #[doc = "< Z offset in elements"]
    pub offsetZ: ::std::os::raw::c_uint,
    #[doc = "< Width in elements"]
    pub extentWidth: ::std::os::raw::c_uint,
    #[doc = "< Height in elements"]
    pub extentHeight: ::std::os::raw::c_uint,
    #[doc = "< Depth in elements"]
    pub extentDepth: ::std::os::raw::c_uint,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hipArrayMapInfo__bindgen_ty_2__bindgen_ty_2 {
    #[doc = "< For layered arrays must be a valid layer index. Otherwise, must be zero"]
    pub layer: ::std::os::raw::c_uint,
    #[doc = "< Offset within mip tail"]
    pub offset: ::std::os::raw::c_ulonglong,
    #[doc = "< Extent in bytes"]
    pub size: ::std::os::raw::c_ulonglong,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union hipArrayMapInfo__bindgen_ty_3 {
    pub memHandle: hipMemGenericAllocationHandle_t,
}
extern "C" {
    #[doc = " @}\n/\n/**\n  @defgroup API HIP API\n  @{\n\n  Defines the HIP API.  See the individual sections for more information.\n/\n/**\n  @defgroup Driver Initialization and Version\n  @{\n  This section describes the initializtion and version functions of HIP runtime API.\n\n/\n/**\n @brief Explicitly initializes the HIP runtime.\n\n @param [in] flags  Initialization flag, should be zero.\n\n Most HIP APIs implicitly initialize the HIP runtime.\n This API provides control over the timing of the initialization.\n\n @returns #hipSuccess, #hipErrorInvalidValue"]
    pub fn hipInit(flags: ::std::os::raw::c_uint) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Returns the approximate HIP driver version.\n\n @param [out] driverVersion driver version\n\n @returns #hipSuccess, #hipErrorInvalidValue\n\n @warning The HIP feature set does not correspond to an exact CUDA SDK driver revision.\n This function always set *driverVersion to 4 as an approximation though HIP supports\n some features which were introduced in later CUDA SDK revisions.\n HIP apps code should not rely on the driver revision number here and should\n use arch feature flags to test device capabilities or conditional compilation.\n\n @see hipRuntimeGetVersion"]
    pub fn hipDriverGetVersion(driverVersion: *mut ::std::os::raw::c_int) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Returns the approximate HIP Runtime version.\n\n @param [out] runtimeVersion HIP runtime version\n\n @returns #hipSuccess, #hipErrorInvalidValue\n\n @warning The version definition of HIP runtime is different from CUDA.\n On AMD platform, the function returns HIP runtime version,\n while on NVIDIA platform, it returns CUDA runtime version.\n And there is no mapping/correlation between HIP version and CUDA version.\n\n @see hipDriverGetVersion"]
    pub fn hipRuntimeGetVersion(runtimeVersion: *mut ::std::os::raw::c_int) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Returns a handle to a compute device\n @param [out] device Handle of device\n @param [in] ordinal Device ordinal\n\n @returns #hipSuccess, #hipErrorInvalidDevice"]
    pub fn hipDeviceGet(device: *mut hipDevice_t, ordinal: ::std::os::raw::c_int) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Returns the compute capability of the device\n @param [out] major Major compute capability version number\n @param [out] minor Minor compute capability version number\n @param [in] device Device ordinal\n\n @returns #hipSuccess, #hipErrorInvalidDevice"]
    pub fn hipDeviceComputeCapability(
        major: *mut ::std::os::raw::c_int,
        minor: *mut ::std::os::raw::c_int,
        device: hipDevice_t,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Returns an identifer string for the device.\n @param [out] name String of the device name\n @param [in] len Maximum length of string to store in device name\n @param [in] device Device ordinal\n\n @returns #hipSuccess, #hipErrorInvalidDevice"]
    pub fn hipDeviceGetName(
        name: *mut ::std::os::raw::c_char,
        len: ::std::os::raw::c_int,
        device: hipDevice_t,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Returns an UUID for the device.[BETA]\n @param [out] uuid UUID for the device\n @param [in] device device ordinal\n\n @beta This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues.\n\n @returns #hipSuccess, #hipErrorInvalidDevice, #hipErrorInvalidValue, #hipErrorNotInitialized,\n #hipErrorDeinitialized"]
    pub fn hipDeviceGetUuid(uuid: *mut hipUUID, device: hipDevice_t) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Returns a value for attribute of link between two devices\n @param [out] value Pointer of the value for the attrubute\n @param [in] attr enum of hipDeviceP2PAttr to query\n @param [in] srcDevice The source device of the link\n @param [in] dstDevice The destination device of the link\n\n @returns #hipSuccess, #hipErrorInvalidDevice"]
    pub fn hipDeviceGetP2PAttribute(
        value: *mut ::std::os::raw::c_int,
        attr: hipDeviceP2PAttr,
        srcDevice: ::std::os::raw::c_int,
        dstDevice: ::std::os::raw::c_int,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Returns a PCI Bus Id string for the device, overloaded to take int device ID.\n @param [out] pciBusId The string of PCI Bus Id format for the device\n @param [in] len Maximum length of string\n @param [in] device The device ordinal\n\n @returns #hipSuccess, #hipErrorInvalidDevice"]
    pub fn hipDeviceGetPCIBusId(
        pciBusId: *mut ::std::os::raw::c_char,
        len: ::std::os::raw::c_int,
        device: ::std::os::raw::c_int,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Returns a handle to a compute device.\n @param [out] device The handle of the device\n @param [in] pciBusId The string of PCI Bus Id for the device\n\n @returns #hipSuccess, #hipErrorInvalidDevice, #hipErrorInvalidValue"]
    pub fn hipDeviceGetByPCIBusId(
        device: *mut ::std::os::raw::c_int,
        pciBusId: *const ::std::os::raw::c_char,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Returns the total amount of memory on the device.\n @param [out] bytes The size of memory in bytes, on the device\n @param [in] device The ordinal of the device\n\n @returns #hipSuccess, #hipErrorInvalidDevice"]
    pub fn hipDeviceTotalMem(bytes: *mut usize, device: hipDevice_t) -> hipError_t;
}
extern "C" {
    #[doc = " @}\n/\n/**\n  @defgroup Device Device Management\n  @{\n  This section describes the device management functions of HIP runtime API.\n/\n/**\n @brief Waits on all active streams on current device\n\n When this command is invoked, the host thread gets blocked until all the commands associated\n with streams associated with the device. HIP does not support multiple blocking modes (yet!).\n\n @returns #hipSuccess\n\n @see hipSetDevice, hipDeviceReset"]
    pub fn hipDeviceSynchronize() -> hipError_t;
}
extern "C" {
    #[doc = " @brief The state of current device is discarded and updated to a fresh state.\n\n Calling this function deletes all streams created, memory allocated, kernels running, events\n created. Make sure that no other thread is using the device or streams, memory, kernels, events\n associated with the current device.\n\n @returns #hipSuccess\n\n @see hipDeviceSynchronize"]
    pub fn hipDeviceReset() -> hipError_t;
}
extern "C" {
    #[doc = " @brief Set default device to be used for subsequent hip API calls from this thread.\n\n @param[in] deviceId Valid device in range 0...hipGetDeviceCount().\n\n Sets @p device as the default device for the calling host thread.  Valid device id's are 0...\n (hipGetDeviceCount()-1).\n\n Many HIP APIs implicitly use the \"default device\" :\n\n - Any device memory subsequently allocated from this host thread (using hipMalloc) will be\n allocated on device.\n - Any streams or events created from this host thread will be associated with device.\n - Any kernels launched from this host thread (using hipLaunchKernel) will be executed on device\n (unless a specific stream is specified, in which case the device associated with that stream will\n be used).\n\n This function may be called from any host thread.  Multiple host threads may use the same device.\n This function does no synchronization with the previous or new device, and has very little\n runtime overhead. Applications can use hipSetDevice to quickly switch the default device before\n making a HIP runtime call which uses the default device.\n\n The default device is stored in thread-local-storage for each thread.\n Thread-pool implementations may inherit the default device of the previous thread.  A good\n practice is to always call hipSetDevice at the start of HIP coding sequency to establish a known\n standard device.\n\n @returns #hipSuccess, #hipErrorInvalidDevice, #hipErrorDeviceAlreadyInUse\n\n @see hipGetDevice, hipGetDeviceCount"]
    pub fn hipSetDevice(deviceId: ::std::os::raw::c_int) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Return the default device id for the calling host thread.\n\n @param [out] deviceId *device is written with the default device\n\n HIP maintains an default device for each thread using thread-local-storage.\n This device is used implicitly for HIP runtime APIs called by this thread.\n hipGetDevice returns in * @p device the default device for the calling host thread.\n\n @returns #hipSuccess, #hipErrorInvalidDevice, #hipErrorInvalidValue\n\n @see hipSetDevice, hipGetDevicesizeBytes"]
    pub fn hipGetDevice(deviceId: *mut ::std::os::raw::c_int) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Return number of compute-capable devices.\n\n @param [out] count Returns number of compute-capable devices.\n\n @returns #hipSuccess, #hipErrorNoDevice\n\n\n Returns in @p *count the number of devices that have ability to run compute commands.  If there\n are no such devices, then @ref hipGetDeviceCount will return #hipErrorNoDevice. If 1 or more\n devices can be found, then hipGetDeviceCount returns #hipSuccess."]
    pub fn hipGetDeviceCount(count: *mut ::std::os::raw::c_int) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Query for a specific device attribute.\n\n @param [out] pi pointer to value to return\n @param [in] attr attribute to query\n @param [in] deviceId which device to query for information\n\n @returns #hipSuccess, #hipErrorInvalidDevice, #hipErrorInvalidValue"]
    pub fn hipDeviceGetAttribute(
        pi: *mut ::std::os::raw::c_int,
        attr: hipDeviceAttribute_t,
        deviceId: ::std::os::raw::c_int,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Returns the default memory pool of the specified device\n\n @param [out] mem_pool Default memory pool to return\n @param [in] device    Device index for query the default memory pool\n\n @returns #hipSuccess, #hipErrorInvalidDevice, #hipErrorInvalidValue, #hipErrorNotSupported\n\n @see hipDeviceGetDefaultMemPool, hipMallocAsync, hipMemPoolTrimTo, hipMemPoolGetAttribute,\n hipDeviceSetMemPool, hipMemPoolSetAttribute, hipMemPoolSetAccess, hipMemPoolGetAccess\n\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues."]
    pub fn hipDeviceGetDefaultMemPool(
        mem_pool: *mut hipMemPool_t,
        device: ::std::os::raw::c_int,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Sets the current memory pool of a device\n\n The memory pool must be local to the specified device.\n @p hipMallocAsync allocates from the current mempool of the provided stream's device.\n By default, a device's current memory pool is its default memory pool.\n\n @note Use @p hipMallocFromPoolAsync for asynchronous memory allocations from a device\n different than the one the stream runs on.\n\n @param [in] device   Device index for the update\n @param [in] mem_pool Memory pool for update as the current on the specified device\n\n @returns #hipSuccess, #hipErrorInvalidValue, #hipErrorInvalidDevice, #hipErrorNotSupported\n\n @see hipDeviceGetDefaultMemPool, hipMallocAsync, hipMemPoolTrimTo, hipMemPoolGetAttribute,\n hipDeviceSetMemPool, hipMemPoolSetAttribute, hipMemPoolSetAccess, hipMemPoolGetAccess\n\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues."]
    pub fn hipDeviceSetMemPool(device: ::std::os::raw::c_int, mem_pool: hipMemPool_t)
        -> hipError_t;
}
extern "C" {
    #[doc = " @brief Gets the current memory pool for the specified device\n\n Returns the last pool provided to @p hipDeviceSetMemPool for this device\n or the device's default memory pool if @p hipDeviceSetMemPool has never been called.\n By default the current mempool is the default mempool for a device,\n otherwise the returned pool must have been set with @p hipDeviceSetMemPool.\n\n @param [out] mem_pool Current memory pool on the specified device\n @param [in] device    Device index to query the current memory pool\n\n @returns #hipSuccess, #hipErrorInvalidValue, #hipErrorNotSupported\n\n @see hipDeviceGetDefaultMemPool, hipMallocAsync, hipMemPoolTrimTo, hipMemPoolGetAttribute,\n hipDeviceSetMemPool, hipMemPoolSetAttribute, hipMemPoolSetAccess, hipMemPoolGetAccess\n\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues."]
    pub fn hipDeviceGetMemPool(
        mem_pool: *mut hipMemPool_t,
        device: ::std::os::raw::c_int,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Returns device properties.\n\n @param [out] prop written with device properties\n @param [in]  deviceId which device to query for information\n\n @return #hipSuccess, #hipErrorInvalidDevice\n @bug HCC always returns 0 for maxThreadsPerMultiProcessor\n @bug HCC always returns 0 for regsPerBlock\n @bug HCC always returns 0 for l2CacheSize\n\n Populates hipGetDeviceProperties with information for the specified device."]
    pub fn hipGetDevicePropertiesR0600(
        prop: *mut hipDeviceProp_tR0600,
        deviceId: ::std::os::raw::c_int,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Set L1/Shared cache partition.\n\n @param [in] cacheConfig Cache configuration\n\n @returns #hipSuccess, #hipErrorNotInitialized, #hipErrorNotSupported\n\n Note: AMD devices do not support reconfigurable cache. This API is not implemented\n on AMD platform. If the function is called, it will return hipErrorNotSupported.\n"]
    pub fn hipDeviceSetCacheConfig(cacheConfig: hipFuncCache_t) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Get Cache configuration for a specific Device\n\n @param [out] cacheConfig Pointer of cache configuration\n\n @returns #hipSuccess, #hipErrorNotInitialized\n Note: AMD devices do not support reconfigurable cache. This hint is ignored\n on these architectures.\n"]
    pub fn hipDeviceGetCacheConfig(cacheConfig: *mut hipFuncCache_t) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Gets resource limits of current device\n\n The function queries the size of limit value, as required by the input enum value hipLimit_t,\n which can be either #hipLimitStackSize, or #hipLimitMallocHeapSize. Any other input as\n default, the function will return #hipErrorUnsupportedLimit.\n\n @param [out] pValue Returns the size of the limit in bytes\n @param [in]  limit The limit to query\n\n @returns #hipSuccess, #hipErrorUnsupportedLimit, #hipErrorInvalidValue\n"]
    pub fn hipDeviceGetLimit(pValue: *mut usize, limit: hipLimit_t) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Sets resource limits of current device.\n\n As the input enum limit,\n #hipLimitStackSize sets the limit value of the stack size on the current GPU device, per thread.\n The limit size can get via hipDeviceGetLimit. The size is in units of 256 dwords, up to the limit\n (128K - 16).\n\n #hipLimitMallocHeapSize sets the limit value of the heap used by the malloc()/free()\n calls. For limit size, use the #hipDeviceGetLimit API.\n\n Any other input as default, the funtion will return hipErrorUnsupportedLimit.\n\n @param [in] limit Enum of hipLimit_t to set\n @param [in] value The size of limit value in bytes\n\n @returns #hipSuccess, #hipErrorUnsupportedLimit, #hipErrorInvalidValue\n"]
    pub fn hipDeviceSetLimit(limit: hipLimit_t, value: usize) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Returns bank width of shared memory for current device\n\n @param [out] pConfig The pointer of the bank width for shared memory\n\n @returns #hipSuccess, #hipErrorInvalidValue, #hipErrorNotInitialized\n\n Note: AMD devices and some Nvidia GPUS do not support shared cache banking, and the hint is\n ignored on those architectures.\n"]
    pub fn hipDeviceGetSharedMemConfig(pConfig: *mut hipSharedMemConfig) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Gets the flags set for current device\n\n @param [out] flags Pointer of the flags\n\n @returns #hipSuccess, #hipErrorInvalidDevice, #hipErrorInvalidValue"]
    pub fn hipGetDeviceFlags(flags: *mut ::std::os::raw::c_uint) -> hipError_t;
}
extern "C" {
    #[doc = " @brief The bank width of shared memory on current device is set\n\n @param [in] config Configuration for the bank width of shared memory\n\n @returns #hipSuccess, #hipErrorInvalidValue, #hipErrorNotInitialized\n\n Note: AMD devices and some Nvidia GPUS do not support shared cache banking, and the hint is\n ignored on those architectures.\n"]
    pub fn hipDeviceSetSharedMemConfig(config: hipSharedMemConfig) -> hipError_t;
}
extern "C" {
    #[doc = " @brief The current device behavior is changed according the flags passed.\n\n @param [in] flags Flag to set on the current device\n\n The schedule flags impact how HIP waits for the completion of a command running on a device.\n hipDeviceScheduleSpin         : HIP runtime will actively spin in the thread which submitted the\n work until the command completes.  This offers the lowest latency, but will consume a CPU core\n and may increase power. hipDeviceScheduleYield        : The HIP runtime will yield the CPU to\n system so that other tasks can use it.  This may increase latency to detect the completion but\n will consume less power and is friendlier to other tasks in the system.\n hipDeviceScheduleBlockingSync : On ROCm platform, this is a synonym for hipDeviceScheduleYield.\n hipDeviceScheduleAuto         : Use a hueristic to select between Spin and Yield modes.  If the\n number of HIP contexts is greater than the number of logical processors in the system, use Spin\n scheduling.  Else use Yield scheduling.\n\n\n hipDeviceMapHost              : Allow mapping host memory.  On ROCM, this is always allowed and\n the flag is ignored. hipDeviceLmemResizeToMax      : @warning ROCm silently ignores this flag.\n\n @returns #hipSuccess, #hipErrorInvalidDevice, #hipErrorSetOnActiveProcess\n\n"]
    pub fn hipSetDeviceFlags(flags: ::std::os::raw::c_uint) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Device which matches hipDeviceProp_t is returned\n\n @param [out] device Pointer of the device\n @param [in]  prop Pointer of the properties\n\n @returns #hipSuccess, #hipErrorInvalidValue"]
    pub fn hipChooseDeviceR0600(
        device: *mut ::std::os::raw::c_int,
        prop: *const hipDeviceProp_tR0600,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Returns the link type and hop count between two devices\n\n @param [in] device1 Ordinal for device1\n @param [in] device2 Ordinal for device2\n @param [out] linktype Returns the link type (See hsa_amd_link_info_type_t) between the two devices\n @param [out] hopcount Returns the hop count between the two devices\n\n Queries and returns the HSA link type and the hop count between the two specified devices.\n\n @returns #hipSuccess, #hipInvalidDevice, #hipErrorRuntimeOther"]
    pub fn hipExtGetLinkTypeAndHopCount(
        device1: ::std::os::raw::c_int,
        device2: ::std::os::raw::c_int,
        linktype: *mut u32,
        hopcount: *mut u32,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Gets an interprocess memory handle for an existing device memory\n          allocation\n\n Takes a pointer to the base of an existing device memory allocation created\n with hipMalloc and exports it for use in another process. This is a\n lightweight operation and may be called multiple times on an allocation\n without adverse effects.\n\n If a region of memory is freed with hipFree and a subsequent call\n to hipMalloc returns memory with the same device address,\n hipIpcGetMemHandle will return a unique handle for the\n new memory.\n\n @param handle - Pointer to user allocated hipIpcMemHandle to return\n                    the handle in.\n @param devPtr - Base pointer to previously allocated device memory\n\n @returns\n #hipSuccess\n #hipErrorInvalidHandle\n #hipErrorOutOfMemory\n #hipErrorMapFailed\n\n @note This IPC memory related feature API on Windows may behave differently from Linux.\n"]
    pub fn hipIpcGetMemHandle(
        handle: *mut hipIpcMemHandle_t,
        devPtr: *mut ::std::os::raw::c_void,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Opens an interprocess memory handle exported from another process\n          and returns a device pointer usable in the local process.\n\n Maps memory exported from another process with hipIpcGetMemHandle into\n the current device address space. For contexts on different devices\n hipIpcOpenMemHandle can attempt to enable peer access between the\n devices as if the user called hipDeviceEnablePeerAccess. This behavior is\n controlled by the hipIpcMemLazyEnablePeerAccess flag.\n hipDeviceCanAccessPeer can determine if a mapping is possible.\n\n Contexts that may open hipIpcMemHandles are restricted in the following way.\n hipIpcMemHandles from each device in a given process may only be opened\n by one context per device per other process.\n\n Memory returned from hipIpcOpenMemHandle must be freed with\n hipIpcCloseMemHandle.\n\n Calling hipFree on an exported memory region before calling\n hipIpcCloseMemHandle in the importing context will result in undefined\n behavior.\n\n @param devPtr - Returned device pointer\n @param handle - hipIpcMemHandle to open\n @param flags  - Flags for this operation. Must be specified as hipIpcMemLazyEnablePeerAccess\n\n @returns\n #hipSuccess,\n #hipErrorMapFailed,\n #hipErrorInvalidHandle,\n #hipErrorTooManyPeers\n\n @note During multiple processes, using the same memory handle opened by the current context,\n there is no guarantee that the same device poiter will be returned in @p *devPtr.\n This is diffrent from CUDA.\n @note This IPC memory related feature API on Windows may behave differently from Linux.\n"]
    pub fn hipIpcOpenMemHandle(
        devPtr: *mut *mut ::std::os::raw::c_void,
        handle: hipIpcMemHandle_t,
        flags: ::std::os::raw::c_uint,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Close memory mapped with hipIpcOpenMemHandle\n\n Unmaps memory returnd by hipIpcOpenMemHandle. The original allocation\n in the exporting process as well as imported mappings in other processes\n will be unaffected.\n\n Any resources used to enable peer access will be freed if this is the\n last mapping using them.\n\n @param devPtr - Device pointer returned by hipIpcOpenMemHandle\n\n @returns\n #hipSuccess,\n #hipErrorMapFailed,\n #hipErrorInvalidHandle\n\n @note This IPC memory related feature API on Windows may behave differently from Linux.\n"]
    pub fn hipIpcCloseMemHandle(devPtr: *mut ::std::os::raw::c_void) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Gets an opaque interprocess handle for an event.\n\n This opaque handle may be copied into other processes and opened with hipIpcOpenEventHandle.\n Then hipEventRecord, hipEventSynchronize, hipStreamWaitEvent and hipEventQuery may be used in\n either process. Operations on the imported event after the exported event has been freed with hipEventDestroy\n will result in undefined behavior.\n\n @param[out]  handle Pointer to hipIpcEventHandle to return the opaque event handle\n @param[in]   event  Event allocated with hipEventInterprocess and hipEventDisableTiming flags\n\n @returns #hipSuccess, #hipErrorInvalidConfiguration, #hipErrorInvalidValue\n\n @note This IPC event related feature API is currently applicable on Linux.\n"]
    pub fn hipIpcGetEventHandle(handle: *mut hipIpcEventHandle_t, event: hipEvent_t) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Opens an interprocess event handles.\n\n Opens an interprocess event handle exported from another process with cudaIpcGetEventHandle. The returned\n hipEvent_t behaves like a locally created event with the hipEventDisableTiming flag specified. This event\n need be freed with hipEventDestroy. Operations on the imported event after the exported event has been freed\n with hipEventDestroy will result in undefined behavior. If the function is called within the same process where\n handle is returned by hipIpcGetEventHandle, it will return hipErrorInvalidContext.\n\n @param[out]  event  Pointer to hipEvent_t to return the event\n @param[in]   handle The opaque interprocess handle to open\n\n @returns #hipSuccess, #hipErrorInvalidValue, #hipErrorInvalidContext\n\n @note This IPC event related feature API is currently applicable on Linux.\n"]
    pub fn hipIpcOpenEventHandle(event: *mut hipEvent_t, handle: hipIpcEventHandle_t)
        -> hipError_t;
}
extern "C" {
    #[doc = " @}\n/\n/**\n\n  @defgroup Execution Execution Control\n  @{\n  This section describes the execution control functions of HIP runtime API.\n\n/\n/**\n @brief Set attribute for a specific function\n\n @param [in] func Pointer of the function\n @param [in] attr Attribute to set\n @param [in] value Value to set\n\n @returns #hipSuccess, #hipErrorInvalidDeviceFunction, #hipErrorInvalidValue\n\n Note: AMD devices and some Nvidia GPUS do not support shared cache banking, and the hint is\n ignored on those architectures.\n"]
    pub fn hipFuncSetAttribute(
        func: *const ::std::os::raw::c_void,
        attr: hipFuncAttribute,
        value: ::std::os::raw::c_int,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Set Cache configuration for a specific function\n\n @param [in] func Pointer of the function.\n @param [in] config Configuration to set.\n\n @returns #hipSuccess, #hipErrorNotInitialized\n Note: AMD devices and some Nvidia GPUS do not support reconfigurable cache.  This hint is ignored\n on those architectures.\n"]
    pub fn hipFuncSetCacheConfig(
        func: *const ::std::os::raw::c_void,
        config: hipFuncCache_t,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Set shared memory configuation for a specific function\n\n @param [in] func Pointer of the function\n @param [in] config Configuration\n\n @returns #hipSuccess, #hipErrorInvalidDeviceFunction, #hipErrorInvalidValue\n\n Note: AMD devices and some Nvidia GPUS do not support shared cache banking, and the hint is\n ignored on those architectures.\n"]
    pub fn hipFuncSetSharedMemConfig(
        func: *const ::std::os::raw::c_void,
        config: hipSharedMemConfig,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @}\n/\n/**\n-------------------------------------------------------------------------------------------------\n-------------------------------------------------------------------------------------------------\n  @defgroup Error Error Handling\n  @{\n  This section describes the error handling functions of HIP runtime API.\n/\n/**\n @brief Return last error returned by any HIP runtime API call and resets the stored error code to\n #hipSuccess\n\n @returns return code from last HIP called from the active host thread\n\n Returns the last error that has been returned by any of the runtime calls in the same host\n thread, and then resets the saved error to #hipSuccess.\n\n @see hipGetErrorString, hipGetLastError, hipPeakAtLastError, hipError_t"]
    pub fn hipGetLastError() -> hipError_t;
}
extern "C" {
    #[doc = " @brief Return last error returned by any HIP runtime API call and resets the stored error code to\n #hipSuccess\n\n @returns return code from last HIP called from the active host thread\n\n Returns the last error that has been returned by any of the runtime calls in the same host\n thread, and then resets the saved error to #hipSuccess.\n\n @see hipGetErrorString, hipGetLastError, hipPeakAtLastError, hipError_t"]
    pub fn hipExtGetLastError() -> hipError_t;
}
extern "C" {
    #[doc = " @brief Return last error returned by any HIP runtime API call.\n\n @return #hipSuccess\n\n Returns the last error that has been returned by any of the runtime calls in the same host\n thread. Unlike hipGetLastError, this function does not reset the saved error code.\n\n @see hipGetErrorString, hipGetLastError, hipPeakAtLastError, hipError_t"]
    pub fn hipPeekAtLastError() -> hipError_t;
}
extern "C" {
    #[doc = " @brief Return hip error as text string form.\n\n @param hip_error Error code to convert to name.\n @return const char pointer to the NULL-terminated error name\n\n @see hipGetErrorString, hipGetLastError, hipPeakAtLastError, hipError_t"]
    pub fn hipGetErrorName(hip_error: hipError_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @brief Return handy text string message to explain the error which occurred\n\n @param hipError Error code to convert to string.\n @return const char pointer to the NULL-terminated error string\n\n @see hipGetErrorName, hipGetLastError, hipPeakAtLastError, hipError_t"]
    pub fn hipGetErrorString(hipError: hipError_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @brief Return hip error as text string form.\n\n @param [in] hipError Error code to convert to string.\n @param [out] errorString char pointer to the NULL-terminated error string\n @return #hipSuccess, #hipErrorInvalidValue\n\n @see hipGetErrorName, hipGetLastError, hipPeakAtLastError, hipError_t"]
    pub fn hipDrvGetErrorName(
        hipError: hipError_t,
        errorString: *mut *const ::std::os::raw::c_char,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Return handy text string message to explain the error which occurred\n\n @param [in] hipError Error code to convert to string.\n @param [out] errorString char pointer to the NULL-terminated error string\n @return #hipSuccess, #hipErrorInvalidValue\n\n @see hipGetErrorName, hipGetLastError, hipPeakAtLastError, hipError_t"]
    pub fn hipDrvGetErrorString(
        hipError: hipError_t,
        errorString: *mut *const ::std::os::raw::c_char,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Create an asynchronous stream.\n\n @param[in, out] stream Valid pointer to hipStream_t.  This function writes the memory with the\n newly created stream.\n @return #hipSuccess, #hipErrorInvalidValue\n\n Create a new asynchronous stream.  @p stream returns an opaque handle that can be used to\n reference the newly created stream in subsequent hipStream* commands.  The stream is allocated on\n the heap and will remain allocated even if the handle goes out-of-scope.  To release the memory\n used by the stream, applicaiton must call hipStreamDestroy.\n\n @return #hipSuccess, #hipErrorInvalidValue\n\n @see hipStreamCreateWithFlags, hipStreamCreateWithPriority, hipStreamSynchronize, hipStreamWaitEvent, hipStreamDestroy"]
    pub fn hipStreamCreate(stream: *mut hipStream_t) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Create an asynchronous stream.\n\n @param[in, out] stream Pointer to new stream\n @param[in ] flags to control stream creation.\n @return #hipSuccess, #hipErrorInvalidValue\n\n Create a new asynchronous stream.  @p stream returns an opaque handle that can be used to\n reference the newly created stream in subsequent hipStream* commands.  The stream is allocated on\n the heap and will remain allocated even if the handle goes out-of-scope.  To release the memory\n used by the stream, applicaiton must call hipStreamDestroy. Flags controls behavior of the\n stream.  See #hipStreamDefault, #hipStreamNonBlocking.\n\n\n @see hipStreamCreate, hipStreamCreateWithPriority, hipStreamSynchronize, hipStreamWaitEvent, hipStreamDestroy"]
    pub fn hipStreamCreateWithFlags(
        stream: *mut hipStream_t,
        flags: ::std::os::raw::c_uint,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Create an asynchronous stream with the specified priority.\n\n @param[in, out] stream Pointer to new stream\n @param[in ] flags to control stream creation.\n @param[in ] priority of the stream. Lower numbers represent higher priorities.\n @return #hipSuccess, #hipErrorInvalidValue\n\n Create a new asynchronous stream with the specified priority.  @p stream returns an opaque handle\n that can be used to reference the newly created stream in subsequent hipStream* commands.  The\n stream is allocated on the heap and will remain allocated even if the handle goes out-of-scope.\n To release the memory used by the stream, applicaiton must call hipStreamDestroy. Flags controls\n behavior of the stream.  See #hipStreamDefault, #hipStreamNonBlocking.\n\n\n @see hipStreamCreate, hipStreamSynchronize, hipStreamWaitEvent, hipStreamDestroy"]
    pub fn hipStreamCreateWithPriority(
        stream: *mut hipStream_t,
        flags: ::std::os::raw::c_uint,
        priority: ::std::os::raw::c_int,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Returns numerical values that correspond to the least and greatest stream priority.\n\n @param[in, out] leastPriority pointer in which value corresponding to least priority is returned.\n @param[in, out] greatestPriority pointer in which value corresponding to greatest priority is returned.\n @returns #hipSuccess\n\n Returns in *leastPriority and *greatestPriority the numerical values that correspond to the least\n and greatest stream priority respectively. Stream priorities follow a convention where lower numbers\n imply greater priorities. The range of meaningful stream priorities is given by\n [*greatestPriority, *leastPriority]. If the user attempts to create a stream with a priority value\n that is outside the the meaningful range as specified by this API, the priority is automatically\n clamped to within the valid range."]
    pub fn hipDeviceGetStreamPriorityRange(
        leastPriority: *mut ::std::os::raw::c_int,
        greatestPriority: *mut ::std::os::raw::c_int,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Destroys the specified stream.\n\n @param[in] stream stream identifier.\n @return #hipSuccess #hipErrorInvalidHandle\n\n Destroys the specified stream.\n\n If commands are still executing on the specified stream, some may complete execution before the\n queue is deleted.\n\n The queue may be destroyed while some commands are still inflight, or may wait for all commands\n queued to the stream before destroying it.\n\n @see hipStreamCreate, hipStreamCreateWithFlags, hipStreamCreateWithPriority, hipStreamQuery, hipStreamWaitEvent,\n hipStreamSynchronize"]
    pub fn hipStreamDestroy(stream: hipStream_t) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Return #hipSuccess if all of the operations in the specified @p stream have completed, or\n #hipErrorNotReady if not.\n\n @param[in] stream stream to query\n\n @return #hipSuccess, #hipErrorNotReady, #hipErrorInvalidHandle\n\n This is thread-safe and returns a snapshot of the current state of the queue.  However, if other\n host threads are sending work to the stream, the status may change immediately after the function\n is called.  It is typically used for debug.\n\n @see hipStreamCreate, hipStreamCreateWithFlags, hipStreamCreateWithPriority, hipStreamWaitEvent, hipStreamSynchronize,\n hipStreamDestroy"]
    pub fn hipStreamQuery(stream: hipStream_t) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Wait for all commands in stream to complete.\n\n @param[in] stream stream identifier.\n\n @return #hipSuccess, #hipErrorInvalidHandle\n\n This command is host-synchronous : the host will block until the specified stream is empty.\n\n This command follows standard null-stream semantics.  Specifically, specifying the null stream\n will cause the command to wait for other streams on the same device to complete all pending\n operations.\n\n This command honors the hipDeviceLaunchBlocking flag, which controls whether the wait is active\n or blocking.\n\n @see hipStreamCreate, hipStreamCreateWithFlags, hipStreamCreateWithPriority, hipStreamWaitEvent, hipStreamDestroy\n"]
    pub fn hipStreamSynchronize(stream: hipStream_t) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Make the specified compute stream wait for an event\n\n @param[in] stream stream to make wait.\n @param[in] event event to wait on\n @param[in] flags control operation [must be 0]\n\n @return #hipSuccess, #hipErrorInvalidHandle\n\n This function inserts a wait operation into the specified stream.\n All future work submitted to @p stream will wait until @p event reports completion before\n beginning execution.\n\n This function only waits for commands in the current stream to complete.  Notably,, this function\n does not impliciy wait for commands in the default stream to complete, even if the specified\n stream is created with hipStreamNonBlocking = 0.\n\n @see hipStreamCreate, hipStreamCreateWithFlags, hipStreamCreateWithPriority, hipStreamSynchronize, hipStreamDestroy"]
    pub fn hipStreamWaitEvent(
        stream: hipStream_t,
        event: hipEvent_t,
        flags: ::std::os::raw::c_uint,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Return flags associated with this stream.\n\n @param[in] stream stream to be queried\n @param[in,out] flags Pointer to an unsigned integer in which the stream's flags are returned\n @return #hipSuccess, #hipErrorInvalidValue, #hipErrorInvalidHandle\n\n @returns #hipSuccess #hipErrorInvalidValue #hipErrorInvalidHandle\n\n Return flags associated with this stream in *@p flags.\n\n @see hipStreamCreateWithFlags"]
    pub fn hipStreamGetFlags(stream: hipStream_t, flags: *mut ::std::os::raw::c_uint)
        -> hipError_t;
}
extern "C" {
    #[doc = " @brief Query the priority of a stream.\n\n @param[in] stream stream to be queried\n @param[in,out] priority Pointer to an unsigned integer in which the stream's priority is returned\n @return #hipSuccess, #hipErrorInvalidValue, #hipErrorInvalidHandle\n\n @returns #hipSuccess #hipErrorInvalidValue #hipErrorInvalidHandle\n\n Query the priority of a stream. The priority is returned in in priority.\n\n @see hipStreamCreateWithFlags"]
    pub fn hipStreamGetPriority(
        stream: hipStream_t,
        priority: *mut ::std::os::raw::c_int,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Get the device assocaited with the stream\n\n @param[in] stream stream to be queried\n @param[out] device device associated with the stream\n @return #hipSuccess, #hipErrorInvalidValue, #hipErrorContextIsDestroyed, #hipErrorInvalidHandle,\n #hipErrorNotInitialized, #hipErrorDeinitialized, #hipErrorInvalidContext\n\n @see hipStreamCreate, hipStreamDestroy, hipDeviceGetStreamPriorityRange"]
    pub fn hipStreamGetDevice(stream: hipStream_t, device: *mut hipDevice_t) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Create an asynchronous stream with the specified CU mask.\n\n @param[in, out] stream Pointer to new stream\n @param[in ] cuMaskSize Size of CU mask bit array passed in.\n @param[in ] cuMask Bit-vector representing the CU mask. Each active bit represents using one CU.\n The first 32 bits represent the first 32 CUs, and so on. If its size is greater than physical\n CU number (i.e., multiProcessorCount member of hipDeviceProp_t), the extra elements are ignored.\n It is user's responsibility to make sure the input is meaningful.\n @return #hipSuccess, #hipErrorInvalidHandle, #hipErrorInvalidValue\n\n Create a new asynchronous stream with the specified CU mask.  @p stream returns an opaque handle\n that can be used to reference the newly created stream in subsequent hipStream* commands.  The\n stream is allocated on the heap and will remain allocated even if the handle goes out-of-scope.\n To release the memory used by the stream, application must call hipStreamDestroy.\n\n\n @see hipStreamCreate, hipStreamSynchronize, hipStreamWaitEvent, hipStreamDestroy"]
    pub fn hipExtStreamCreateWithCUMask(
        stream: *mut hipStream_t,
        cuMaskSize: u32,
        cuMask: *const u32,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Get CU mask associated with an asynchronous stream\n\n @param[in] stream stream to be queried\n @param[in] cuMaskSize number of the block of memories (uint32_t *) allocated by user\n @param[out] cuMask Pointer to a pre-allocated block of memories (uint32_t *) in which\n the stream's CU mask is returned. The CU mask is returned in a chunck of 32 bits where\n each active bit represents one active CU\n @return #hipSuccess, #hipErrorInvalidHandle, #hipErrorInvalidValue\n\n @see hipStreamCreate, hipStreamSynchronize, hipStreamWaitEvent, hipStreamDestroy"]
    pub fn hipExtStreamGetCUMask(
        stream: hipStream_t,
        cuMaskSize: u32,
        cuMask: *mut u32,
    ) -> hipError_t;
}
#[doc = " Stream CallBack struct"]
pub type hipStreamCallback_t = ::std::option::Option<
    unsafe extern "C" fn(
        stream: hipStream_t,
        status: hipError_t,
        userData: *mut ::std::os::raw::c_void,
    ),
>;
extern "C" {
    #[doc = " @brief Adds a callback to be called on the host after all currently enqueued\n items in the stream have completed.  For each\n hipStreamAddCallback call, a callback will be executed exactly once.\n The callback will block later work in the stream until it is finished.\n @param[in] stream   - Stream to add callback to\n @param[in] callback - The function to call once preceding stream operations are complete\n @param[in] userData - User specified data to be passed to the callback function\n @param[in] flags    - Reserved for future use, must be 0\n @return #hipSuccess, #hipErrorInvalidHandle, #hipErrorNotSupported\n\n @see hipStreamCreate, hipStreamCreateWithFlags, hipStreamQuery, hipStreamSynchronize,\n hipStreamWaitEvent, hipStreamDestroy, hipStreamCreateWithPriority\n"]
    pub fn hipStreamAddCallback(
        stream: hipStream_t,
        callback: hipStreamCallback_t,
        userData: *mut ::std::os::raw::c_void,
        flags: ::std::os::raw::c_uint,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @}\n/\n/**\n-------------------------------------------------------------------------------------------------\n-------------------------------------------------------------------------------------------------\n  @defgroup StreamM Stream Memory Operations\n  @{\n  This section describes Stream Memory Wait and Write functions of HIP runtime API.\n/\n/**\n @brief Enqueues a wait command to the stream.[BETA]\n\n @param [in] stream - Stream identifier\n @param [in] ptr    - Pointer to memory object allocated using 'hipMallocSignalMemory' flag\n @param [in] value  - Value to be used in compare operation\n @param [in] flags  - Defines the compare operation, supported values are hipStreamWaitValueGte\n hipStreamWaitValueEq, hipStreamWaitValueAnd and hipStreamWaitValueNor\n @param [in] mask   - Mask to be applied on value at memory before it is compared with value,\n default value is set to enable every bit\n\n @returns #hipSuccess, #hipErrorInvalidValue\n\n Enqueues a wait command to the stream, all operations enqueued  on this stream after this, will\n not execute until the defined wait condition is true.\n\n hipStreamWaitValueGte: waits until *ptr&mask >= value\n hipStreamWaitValueEq : waits until *ptr&mask == value\n hipStreamWaitValueAnd: waits until ((*ptr&mask) & value) != 0\n hipStreamWaitValueNor: waits until ~((*ptr&mask) | (value&mask)) != 0\n\n @note when using 'hipStreamWaitValueNor', mask is applied on both 'value' and '*ptr'.\n\n @note Support for hipStreamWaitValue32 can be queried using 'hipDeviceGetAttribute()' and\n 'hipDeviceAttributeCanUseStreamWaitValue' flag.\n\n @beta This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues.\n\n @see hipExtMallocWithFlags, hipFree, hipStreamWaitValue64, hipStreamWriteValue64,\n hipStreamWriteValue32, hipDeviceGetAttribute"]
    pub fn hipStreamWaitValue32(
        stream: hipStream_t,
        ptr: *mut ::std::os::raw::c_void,
        value: u32,
        flags: ::std::os::raw::c_uint,
        mask: u32,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Enqueues a wait command to the stream.[BETA]\n\n @param [in] stream - Stream identifier\n @param [in] ptr    - Pointer to memory object allocated using 'hipMallocSignalMemory' flag\n @param [in] value  - Value to be used in compare operation\n @param [in] flags  - Defines the compare operation, supported values are hipStreamWaitValueGte\n hipStreamWaitValueEq, hipStreamWaitValueAnd and hipStreamWaitValueNor.\n @param [in] mask   - Mask to be applied on value at memory before it is compared with value\n default value is set to enable every bit\n\n @returns #hipSuccess, #hipErrorInvalidValue\n\n Enqueues a wait command to the stream, all operations enqueued  on this stream after this, will\n not execute until the defined wait condition is true.\n\n hipStreamWaitValueGte: waits until *ptr&mask >= value\n hipStreamWaitValueEq : waits until *ptr&mask == value\n hipStreamWaitValueAnd: waits until ((*ptr&mask) & value) != 0\n hipStreamWaitValueNor: waits until ~((*ptr&mask) | (value&mask)) != 0\n\n @note when using 'hipStreamWaitValueNor', mask is applied on both 'value' and '*ptr'.\n\n @note Support for hipStreamWaitValue64 can be queried using 'hipDeviceGetAttribute()' and\n 'hipDeviceAttributeCanUseStreamWaitValue' flag.\n\n @beta This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues.\n\n @see hipExtMallocWithFlags, hipFree, hipStreamWaitValue32, hipStreamWriteValue64,\n hipStreamWriteValue32, hipDeviceGetAttribute"]
    pub fn hipStreamWaitValue64(
        stream: hipStream_t,
        ptr: *mut ::std::os::raw::c_void,
        value: u64,
        flags: ::std::os::raw::c_uint,
        mask: u64,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Enqueues a write command to the stream.[BETA]\n\n @param [in] stream - Stream identifier\n @param [in] ptr    - Pointer to a GPU accessible memory object\n @param [in] value  - Value to be written\n @param [in] flags  - reserved, ignored for now, will be used in future releases\n\n @returns #hipSuccess, #hipErrorInvalidValue\n\n Enqueues a write command to the stream, write operation is performed after all earlier commands\n on this stream have completed the execution.\n\n @beta This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues.\n\n @see hipExtMallocWithFlags, hipFree, hipStreamWriteValue32, hipStreamWaitValue32,\n hipStreamWaitValue64"]
    pub fn hipStreamWriteValue32(
        stream: hipStream_t,
        ptr: *mut ::std::os::raw::c_void,
        value: u32,
        flags: ::std::os::raw::c_uint,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Enqueues a write command to the stream.[BETA]\n\n @param [in] stream - Stream identifier\n @param [in] ptr    - Pointer to a GPU accessible memory object\n @param [in] value  - Value to be written\n @param [in] flags  - reserved, ignored for now, will be used in future releases\n\n @returns #hipSuccess, #hipErrorInvalidValue\n\n Enqueues a write command to the stream, write operation is performed after all earlier commands\n on this stream have completed the execution.\n\n @beta This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues.\n\n @see hipExtMallocWithFlags, hipFree, hipStreamWriteValue32, hipStreamWaitValue32,\n hipStreamWaitValue64"]
    pub fn hipStreamWriteValue64(
        stream: hipStream_t,
        ptr: *mut ::std::os::raw::c_void,
        value: u64,
        flags: ::std::os::raw::c_uint,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @}\n/\n/**\n-------------------------------------------------------------------------------------------------\n-------------------------------------------------------------------------------------------------\n  @defgroup Event Event Management\n  @{\n  This section describes the event management functions of HIP runtime API.\n/\n/**\n @brief Create an event with the specified flags\n\n @param[in,out] event Returns the newly created event.\n @param[in] flags     Flags to control event behavior.  Valid values are #hipEventDefault,\n#hipEventBlockingSync, #hipEventDisableTiming, #hipEventInterprocess\n #hipEventDefault : Default flag.  The event will use active synchronization and will support\ntiming.  Blocking synchronization provides lowest possible latency at the expense of dedicating a\nCPU to poll on the event.\n #hipEventBlockingSync : The event will use blocking synchronization : if hipEventSynchronize is\ncalled on this event, the thread will block until the event completes.  This can increase latency\nfor the synchroniation but can result in lower power and more resources for other CPU threads.\n #hipEventDisableTiming : Disable recording of timing information. Events created with this flag\nwould not record profiling data and provide best performance if used for synchronization.\n #hipEventInterprocess : The event can be used as an interprocess event. hipEventDisableTiming\nflag also must be set when hipEventInterprocess flag is set.\n #hipEventDisableSystemFence : Disable acquire and release system scope fence. This may\nimprove performance but device memory may not be visible to the host and other devices\nif this flag is set.\n\n @returns #hipSuccess, #hipErrorNotInitialized, #hipErrorInvalidValue,\n#hipErrorLaunchFailure, #hipErrorOutOfMemory\n\n @see hipEventCreate, hipEventSynchronize, hipEventDestroy, hipEventElapsedTime"]
    pub fn hipEventCreateWithFlags(
        event: *mut hipEvent_t,
        flags: ::std::os::raw::c_uint,
    ) -> hipError_t;
}
extern "C" {
    #[doc = "  Create an event\n\n @param[in,out] event Returns the newly created event.\n\n @returns #hipSuccess, #hipErrorNotInitialized, #hipErrorInvalidValue,\n #hipErrorLaunchFailure, #hipErrorOutOfMemory\n\n @see hipEventCreateWithFlags, hipEventRecord, hipEventQuery, hipEventSynchronize,\n hipEventDestroy, hipEventElapsedTime"]
    pub fn hipEventCreate(event: *mut hipEvent_t) -> hipError_t;
}
extern "C" {
    pub fn hipEventRecord(event: hipEvent_t, stream: hipStream_t) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Destroy the specified event.\n\n  @param[in] event Event to destroy.\n  @returns #hipSuccess, #hipErrorNotInitialized, #hipErrorInvalidValue,\n #hipErrorLaunchFailure\n\n  Releases memory associated with the event.  If the event is recording but has not completed\n recording when hipEventDestroy() is called, the function will return immediately and the\n completion_future resources will be released later, when the hipDevice is synchronized.\n\n @see hipEventCreate, hipEventCreateWithFlags, hipEventQuery, hipEventSynchronize, hipEventRecord,\n hipEventElapsedTime\n\n @returns #hipSuccess"]
    pub fn hipEventDestroy(event: hipEvent_t) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Wait for an event to complete.\n\n  This function will block until the event is ready, waiting for all previous work in the stream\n specified when event was recorded with hipEventRecord().\n\n  If hipEventRecord() has not been called on @p event, this function returns immediately.\n\n  TODO-hip- This function needs to support hipEventBlockingSync parameter.\n\n  @param[in] event Event on which to wait.\n  @returns #hipSuccess, #hipErrorInvalidValue, #hipErrorNotInitialized,\n #hipErrorInvalidHandle, #hipErrorLaunchFailure\n\n  @see hipEventCreate, hipEventCreateWithFlags, hipEventQuery, hipEventDestroy, hipEventRecord,\n hipEventElapsedTime"]
    pub fn hipEventSynchronize(event: hipEvent_t) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Return the elapsed time between two events.\n\n @param[out] ms : Return time between start and stop in ms.\n @param[in]   start : Start event.\n @param[in]   stop  : Stop event.\n @returns #hipSuccess, #hipErrorInvalidValue, #hipErrorNotReady, #hipErrorInvalidHandle,\n #hipErrorNotInitialized, #hipErrorLaunchFailure\n\n Computes the elapsed time between two events. Time is computed in ms, with\n a resolution of approximately 1 us.\n\n Events which are recorded in a NULL stream will block until all commands\n on all other streams complete execution, and then record the timestamp.\n\n Events which are recorded in a non-NULL stream will record their timestamp\n when they reach the head of the specified stream, after all previous\n commands in that stream have completed executing.  Thus the time that\n the event recorded may be significantly after the host calls hipEventRecord().\n\n If hipEventRecord() has not been called on either event, then #hipErrorInvalidHandle is\n returned. If hipEventRecord() has been called on both events, but the timestamp has not yet been\n recorded on one or both events (that is, hipEventQuery() would return #hipErrorNotReady on at\n least one of the events), then #hipErrorNotReady is returned.\n\n @see hipEventCreate, hipEventCreateWithFlags, hipEventQuery, hipEventDestroy, hipEventRecord,\n hipEventSynchronize"]
    pub fn hipEventElapsedTime(ms: *mut f32, start: hipEvent_t, stop: hipEvent_t) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Query event status\n\n @param[in] event Event to query.\n @returns #hipSuccess, #hipErrorNotReady, #hipErrorInvalidHandle, #hipErrorInvalidValue,\n #hipErrorNotInitialized, #hipErrorLaunchFailure\n\n Query the status of the specified event.  This function will return #hipSuccess if all\n commands in the appropriate stream (specified to hipEventRecord()) have completed.  If that work\n has not completed, or if hipEventRecord() was not called on the event, then #hipErrorNotReady is\n returned.\n\n @see hipEventCreate, hipEventCreateWithFlags, hipEventRecord, hipEventDestroy,\n hipEventSynchronize, hipEventElapsedTime"]
    pub fn hipEventQuery(event: hipEvent_t) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Sets information on the specified pointer.[BETA]\n\n  @param [in]      value     sets pointer attribute value\n  @param [in]      atribute attribute to set\n  @param [in]      ptr      pointer to set attributes for\n\n  @return #hipSuccess, #hipErrorInvalidDevice, #hipErrorInvalidValue\n\n  @beta This API is marked as beta, meaning, while this is feature complete,\n  it is still open to changes and may have outstanding issues.\n"]
    pub fn hipPointerSetAttribute(
        value: *const ::std::os::raw::c_void,
        attribute: hipPointer_attribute,
        ptr: hipDeviceptr_t,
    ) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Return attributes for the specified pointer\n\n  @param [out]  attributes  attributes for the specified pointer\n  @param [in]   ptr         pointer to get attributes for\n\n  @note: To get pointer's memory type, the parameter attributes has 'type' as member variable.\n  The 'type' indicates input pointer is allocated on device or host. That means the input pointer\n  must be returned or passed through an HIP API such as hipHostMalloc, hipMallocManaged,\n  hipHostRegister, etc. Otherwise, the pointer can't be handled by this API and attributes\n  returned hipErrorInvalidValue, due to the hipMemoryType enums values, unrecognized memory type\n  is currently not supported due to HIP functionality backward compatibility.\n\n  @return #hipSuccess, #hipErrorInvalidDevice, #hipErrorInvalidValue\n\n  @see hipPointerGetAttribute"]
    pub fn hipPointerGetAttributes(
        attributes: *mut hipPointerAttribute_t,
        ptr: *const ::std::os::raw::c_void,
    ) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Returns information about the specified pointer.[BETA]\n\n  @param [in, out] data     returned pointer attribute value\n  @param [in]      atribute attribute to query for\n  @param [in]      ptr      pointer to get attributes for\n\n  @return #hipSuccess, #hipErrorInvalidDevice, #hipErrorInvalidValue\n\n  @beta This API is marked as beta, meaning, while this is feature complete,\n  it is still open to changes and may have outstanding issues.\n\n  @see hipPointerGetAttributes"]
    pub fn hipPointerGetAttribute(
        data: *mut ::std::os::raw::c_void,
        attribute: hipPointer_attribute,
        ptr: hipDeviceptr_t,
    ) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Returns information about the specified pointer.[BETA]\n\n  @param [in]  numAttributes   number of attributes to query for\n  @param [in]  attributes      attributes to query for\n  @param [in, out] data        a two-dimensional containing pointers to memory locations\n                               where the result of each attribute query will be written to\n  @param [in]  ptr             pointer to get attributes for\n\n  @return #hipSuccess, #hipErrorInvalidDevice, #hipErrorInvalidValue\n\n  @beta This API is marked as beta, meaning, while this is feature complete,\n  it is still open to changes and may have outstanding issues.\n\n  @see hipPointerGetAttribute"]
    pub fn hipDrvPointerGetAttributes(
        numAttributes: ::std::os::raw::c_uint,
        attributes: *mut hipPointer_attribute,
        data: *mut *mut ::std::os::raw::c_void,
        ptr: hipDeviceptr_t,
    ) -> hipError_t;
}
extern "C" {
    #[doc = "-------------------------------------------------------------------------------------------------\n-------------------------------------------------------------------------------------------------\n  @defgroup External External Resource Interoperability\n  @{\n  @ingroup API\n\n  This section describes the external resource interoperability functions of HIP runtime API.\n\n/\n/**\n  @brief Imports an external semaphore.\n\n  @param[out] extSem_out  External semaphores to be waited on\n  @param[in] semHandleDesc Semaphore import handle descriptor\n\n  @return #hipSuccess, #hipErrorInvalidDevice, #hipErrorInvalidValue\n\n  @see"]
    pub fn hipImportExternalSemaphore(
        extSem_out: *mut hipExternalSemaphore_t,
        semHandleDesc: *const hipExternalSemaphoreHandleDesc,
    ) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Signals a set of external semaphore objects.\n\n  @param[in] extSem_out  External semaphores to be waited on\n  @param[in] paramsArray Array of semaphore parameters\n  @param[in] numExtSems Number of semaphores to wait on\n  @param[in] stream Stream to enqueue the wait operations in\n\n  @return #hipSuccess, #hipErrorInvalidDevice, #hipErrorInvalidValue\n\n  @see"]
    pub fn hipSignalExternalSemaphoresAsync(
        extSemArray: *const hipExternalSemaphore_t,
        paramsArray: *const hipExternalSemaphoreSignalParams,
        numExtSems: ::std::os::raw::c_uint,
        stream: hipStream_t,
    ) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Waits on a set of external semaphore objects\n\n  @param[in] extSem_out  External semaphores to be waited on\n  @param[in] paramsArray Array of semaphore parameters\n  @param[in] numExtSems Number of semaphores to wait on\n  @param[in] stream Stream to enqueue the wait operations in\n\n  @return #hipSuccess, #hipErrorInvalidDevice, #hipErrorInvalidValue\n\n  @see"]
    pub fn hipWaitExternalSemaphoresAsync(
        extSemArray: *const hipExternalSemaphore_t,
        paramsArray: *const hipExternalSemaphoreWaitParams,
        numExtSems: ::std::os::raw::c_uint,
        stream: hipStream_t,
    ) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Destroys an external semaphore object and releases any references to the underlying resource. Any outstanding signals or waits must have completed before the semaphore is destroyed.\n\n  @param[in] extSem handle to an external memory object\n\n  @return #hipSuccess, #hipErrorInvalidDevice, #hipErrorInvalidValue\n\n  @see"]
    pub fn hipDestroyExternalSemaphore(extSem: hipExternalSemaphore_t) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Imports an external memory object.\n\n  @param[out] extMem_out  Returned handle to an external memory object\n  @param[in]  memHandleDesc Memory import handle descriptor\n\n  @return #hipSuccess, #hipErrorInvalidDevice, #hipErrorInvalidValue\n\n  @see"]
    pub fn hipImportExternalMemory(
        extMem_out: *mut hipExternalMemory_t,
        memHandleDesc: *const hipExternalMemoryHandleDesc,
    ) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Maps a buffer onto an imported memory object.\n\n  @param[out] devPtr Returned device pointer to buffer\n  @param[in]  extMem  Handle to external memory object\n  @param[in]  bufferDesc  Buffer descriptor\n\n  @return #hipSuccess, #hipErrorInvalidDevice, #hipErrorInvalidValue\n\n  @see"]
    pub fn hipExternalMemoryGetMappedBuffer(
        devPtr: *mut *mut ::std::os::raw::c_void,
        extMem: hipExternalMemory_t,
        bufferDesc: *const hipExternalMemoryBufferDesc,
    ) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Destroys an external memory object.\n\n  @param[in] extMem  External memory object to be destroyed\n\n  @returns #hipSuccess, #hipErrorInvalidDevice, #hipErrorInvalidValue\n\n  @see"]
    pub fn hipDestroyExternalMemory(extMem: hipExternalMemory_t) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Maps a mipmapped array onto an external memory object.\n\n  @param[out] mipmap mipmapped array to return\n  @param[in]  extMem external memory object handle\n  @param[in]  mipmapDesc external mipmapped array descriptor\n\n  Returned mipmapped array must be freed using hipFreeMipmappedArray.\n\n  @return #hipSuccess, #hipErrorInvalidValue, #hipErrorInvalidResourceHandle\n\n  @see hipImportExternalMemory, hipDestroyExternalMemory, hipExternalMemoryGetMappedBuffer, hipFreeMipmappedArray"]
    pub fn hipExternalMemoryGetMappedMipmappedArray(
        mipmap: *mut hipMipmappedArray_t,
        extMem: hipExternalMemory_t,
        mipmapDesc: *const hipExternalMemoryMipmappedArrayDesc,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @}\n/\n/**\n  @brief Allocate memory on the default accelerator\n\n  @param[out] ptr Pointer to the allocated memory\n  @param[in]  size Requested memory size\n\n  If size is 0, no memory is allocated, *ptr returns nullptr, and hipSuccess is returned.\n\n  @return #hipSuccess, #hipErrorOutOfMemory, #hipErrorInvalidValue (bad context, null *ptr)\n\n  @see hipMallocPitch, hipFree, hipMallocArray, hipFreeArray, hipMalloc3D, hipMalloc3DArray,\n hipHostFree, hipHostMalloc"]
    pub fn hipMalloc(ptr: *mut *mut ::std::os::raw::c_void, size: usize) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Allocate memory on the default accelerator\n\n  @param[out] ptr Pointer to the allocated memory\n  @param[in]  size Requested memory size\n  @param[in]  flags Type of memory allocation\n\n  If requested memory size is 0, no memory is allocated, *ptr returns nullptr, and #hipSuccess\n  is returned.\n\n  The memory allocation flag should be either #hipDeviceMallocDefault,\n  #hipDeviceMallocFinegrained, #hipDeviceMallocUncached, or #hipMallocSignalMemory.\n  If the flag is any other value, the API returns #hipErrorInvalidValue.\n\n  @return #hipSuccess, #hipErrorOutOfMemory, #hipErrorInvalidValue (bad context, null *ptr)\n\n  @see hipMallocPitch, hipFree, hipMallocArray, hipFreeArray, hipMalloc3D, hipMalloc3DArray,\n hipHostFree, hipHostMalloc"]
    pub fn hipExtMallocWithFlags(
        ptr: *mut *mut ::std::os::raw::c_void,
        sizeBytes: usize,
        flags: ::std::os::raw::c_uint,
    ) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Allocate pinned host memory [Deprecated]\n\n  @param[out] ptr Pointer to the allocated host pinned memory\n  @param[in]  size Requested memory size\n\n  If size is 0, no memory is allocated, *ptr returns nullptr, and hipSuccess is returned.\n\n  @return #hipSuccess, #hipErrorOutOfMemory\n\n  @warning  This API is deprecated, use hipHostMalloc() instead"]
    pub fn hipMallocHost(ptr: *mut *mut ::std::os::raw::c_void, size: usize) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Allocate pinned host memory [Deprecated]\n\n  @param[out] ptr Pointer to the allocated host pinned memory\n  @param[in]  size Requested memory size\n\n  If size is 0, no memory is allocated, *ptr returns nullptr, and hipSuccess is returned.\n\n  @return #hipSuccess, #hipErrorOutOfMemory\n\n  @warning  This API is deprecated, use hipHostMalloc() instead"]
    pub fn hipMemAllocHost(ptr: *mut *mut ::std::os::raw::c_void, size: usize) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Allocates device accessible page locked (pinned) host memory\n\n  This API allocates pinned host memory which is mapped into the address space of all GPUs\n  in the system, the memory can be accessed directly by the GPU device, and can be read or\n  written with much higher bandwidth than pageable memory obtained with functions such as\n  malloc().\n\n  Using the pinned host memory, applications can implement faster data transfers for HostToDevice\n  and DeviceToHost. The runtime tracks the hipHostMalloc allocations and can avoid some of the\n  setup required for regular unpinned memory.\n\n  When the memory accesses are infrequent, zero-copy memory can be a good choice, for coherent\n  allocation. GPU can directly access the host memory over the CPU/GPU interconnect, without need\n  to copy the data.\n\n  Currently the allocation granularity is 4KB for the API.\n\n  Developers need to choose proper allocation flag with consideration of synchronization.\n\n  @param[out] ptr Pointer to the allocated host pinned memory\n  @param[in]  size Requested memory size in bytes\n  If size is 0, no memory is allocated, *ptr returns nullptr, and hipSuccess is returned.\n  @param[in]  flags Type of host memory allocation\n\n  If no input for flags, it will be the default pinned memory allocation on the host.\n\n  @return #hipSuccess, #hipErrorOutOfMemory\n\n  @see hipSetDeviceFlags, hipHostFree"]
    pub fn hipHostMalloc(
        ptr: *mut *mut ::std::os::raw::c_void,
        size: usize,
        flags: ::std::os::raw::c_uint,
    ) -> hipError_t;
}
extern "C" {
    #[doc = "-------------------------------------------------------------------------------------------------\n-------------------------------------------------------------------------------------------------\n  @defgroup MemoryM Managed Memory\n\n  @ingroup Memory\n @{\n  This section describes the managed memory management functions of HIP runtime API.\n\n  @note  The managed memory management APIs are implemented on Linux, under developement\n  on Windows.\n\n/\n/**\n @brief Allocates memory that will be automatically managed by HIP.\n\n This API is used for managed memory, allows data be shared and accessible to both CPU and\n GPU using a single pointer.\n\n The API returns the allocation pointer, managed by HMM, can be used further to execute kernels\n on device and fetch data between the host and device as needed.\n\n @note   It is recommend to do the capability check before call this API.\n\n @param [out] dev_ptr - pointer to allocated device memory\n @param [in]  size    - requested allocation size in bytes, it should be granularity of 4KB\n @param [in]  flags   - must be either hipMemAttachGlobal or hipMemAttachHost\n                        (defaults to hipMemAttachGlobal)\n\n @returns #hipSuccess, #hipErrorMemoryAllocation, #hipErrorNotSupported, #hipErrorInvalidValue\n"]
    pub fn hipMallocManaged(
        dev_ptr: *mut *mut ::std::os::raw::c_void,
        size: usize,
        flags: ::std::os::raw::c_uint,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Prefetches memory to the specified destination device using HIP.\n\n @param [in] dev_ptr  pointer to be prefetched\n @param [in] count    size in bytes for prefetching\n @param [in] device   destination device to prefetch to\n @param [in] stream   stream to enqueue prefetch operation\n\n @returns #hipSuccess, #hipErrorInvalidValue\n\n @note  This API is implemented on Linux, under development on Windows."]
    pub fn hipMemPrefetchAsync(
        dev_ptr: *const ::std::os::raw::c_void,
        count: usize,
        device: ::std::os::raw::c_int,
        stream: hipStream_t,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Advise about the usage of a given memory range to HIP.\n\n @param [in] dev_ptr  pointer to memory to set the advice for\n @param [in] count    size in bytes of the memory range, it should be CPU page size alligned.\n @param [in] advice   advice to be applied for the specified memory range\n @param [in] device   device to apply the advice for\n\n @returns #hipSuccess, #hipErrorInvalidValue\n\n This HIP API advises about the usage to be applied on unified memory allocation in the\n range starting from the pointer address devPtr, with the size of count bytes.\n The memory range must refer to managed memory allocated via the API hipMallocManaged, and the\n range will be handled with proper round down and round up respectively in the driver to\n be aligned to CPU page size, the same way as corresponding CUDA API behaves in CUDA version 8.0\n and afterwards.\n\n @note  This API is implemented on Linux and is under development on Windows."]
    pub fn hipMemAdvise(
        dev_ptr: *const ::std::os::raw::c_void,
        count: usize,
        advice: hipMemoryAdvise,
        device: ::std::os::raw::c_int,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Query an attribute of a given memory range in HIP.\n\n @param [in,out] data   a pointer to a memory location where the result of each\n                        attribute query will be written to\n @param [in] data_size  the size of data\n @param [in] attribute  the attribute to query\n @param [in] dev_ptr    start of the range to query\n @param [in] count      size of the range to query\n\n @returns #hipSuccess, #hipErrorInvalidValue\n\n @note  This API is implemented on Linux, under development on Windows."]
    pub fn hipMemRangeGetAttribute(
        data: *mut ::std::os::raw::c_void,
        data_size: usize,
        attribute: hipMemRangeAttribute,
        dev_ptr: *const ::std::os::raw::c_void,
        count: usize,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Query attributes of a given memory range in HIP.\n\n @param [in,out] data     a two-dimensional array containing pointers to memory locations\n                          where the result of each attribute query will be written to\n @param [in] data_sizes   an array, containing the sizes of each result\n @param [in] attributes   the attribute to query\n @param [in] num_attributes  an array of attributes to query (numAttributes and the number\n                          of attributes in this array should match)\n @param [in] dev_ptr      start of the range to query\n @param [in] count        size of the range to query\n\n @returns #hipSuccess, #hipErrorInvalidValue\n\n @note  This API is implemented on Linux, under development on Windows."]
    pub fn hipMemRangeGetAttributes(
        data: *mut *mut ::std::os::raw::c_void,
        data_sizes: *mut usize,
        attributes: *mut hipMemRangeAttribute,
        num_attributes: usize,
        dev_ptr: *const ::std::os::raw::c_void,
        count: usize,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Attach memory to a stream asynchronously in HIP.\n\n @param [in] stream     - stream in which to enqueue the attach operation\n @param [in] dev_ptr    - pointer to memory (must be a pointer to managed memory or\n                          to a valid host-accessible region of system-allocated memory)\n @param [in] length     - length of memory (defaults to zero)\n @param [in] flags      - must be one of hipMemAttachGlobal, hipMemAttachHost or\n                          hipMemAttachSingle (defaults to hipMemAttachSingle)\n\n @returns #hipSuccess, #hipErrorInvalidValue\n\n @note  This API is implemented on Linux, under development on Windows."]
    pub fn hipStreamAttachMemAsync(
        stream: hipStream_t,
        dev_ptr: *mut ::std::os::raw::c_void,
        length: usize,
        flags: ::std::os::raw::c_uint,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Allocates memory with stream ordered semantics\n\n Inserts a memory allocation operation into @p stream.\n A pointer to the allocated memory is returned immediately in *dptr.\n The allocation must not be accessed until the the allocation operation completes.\n The allocation comes from the memory pool associated with the stream's device.\n\n @note The default memory pool of a device contains device memory from that device.\n @note Basic stream ordering allows future work submitted into the same stream to use the\n  allocation. Stream query, stream synchronize, and HIP events can be used to guarantee that\n  the allocation operation completes before work submitted in a separate stream runs.\n @note During stream capture, this function results in the creation of an allocation node.\n  In this case, the allocation is owned by the graph instead of the memory pool. The memory\n  pool's properties are used to set the node's creation parameters.\n\n @param [out] dev_ptr  Returned device pointer of memory allocation\n @param [in] size      Number of bytes to allocate\n @param [in] stream    The stream establishing the stream ordering contract and\n                       the memory pool to allocate from\n\n @return #hipSuccess, #hipErrorInvalidValue, #hipErrorNotSupported, #hipErrorOutOfMemory\n\n @see hipMallocFromPoolAsync, hipFreeAsync, hipMemPoolTrimTo, hipMemPoolGetAttribute,\n hipDeviceSetMemPool, hipMemPoolSetAttribute, hipMemPoolSetAccess, hipMemPoolGetAccess\n\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues.\n\n @note  This API is implemented on Linux, under development on Windows."]
    pub fn hipMallocAsync(
        dev_ptr: *mut *mut ::std::os::raw::c_void,
        size: usize,
        stream: hipStream_t,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Frees memory with stream ordered semantics\n\n Inserts a free operation into @p stream.\n The allocation must not be used after stream execution reaches the free.\n After this API returns, accessing the memory from any subsequent work launched on the GPU\n or querying its pointer attributes results in undefined behavior.\n\n @note During stream capture, this function results in the creation of a free node and\n must therefore be passed the address of a graph allocation.\n\n @param [in] dev_ptr Pointer to device memory to free\n @param [in] stream  The stream, where the destruciton will occur according to the execution order\n\n @returns #hipSuccess, #hipErrorInvalidValue, #hipErrorNotSupported\n\n @see hipMallocFromPoolAsync, hipMallocAsync, hipMemPoolTrimTo, hipMemPoolGetAttribute,\n hipDeviceSetMemPool, hipMemPoolSetAttribute, hipMemPoolSetAccess, hipMemPoolGetAccess\n\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues.\n\n @note  This API is implemented on Linux, under development on Windows."]
    pub fn hipFreeAsync(dev_ptr: *mut ::std::os::raw::c_void, stream: hipStream_t) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Releases freed memory back to the OS\n\n Releases memory back to the OS until the pool contains fewer than @p min_bytes_to_keep\n reserved bytes, or there is no more memory that the allocator can safely release.\n The allocator cannot release OS allocations that back outstanding asynchronous allocations.\n The OS allocations may happen at different granularity from the user allocations.\n\n @note: Allocations that have not been freed count as outstanding.\n @note: Allocations that have been asynchronously freed but whose completion has\n not been observed on the host (eg. by a synchronize) can count as outstanding.\n\n @param[in] mem_pool          The memory pool to trim allocations\n @param[in] min_bytes_to_hold If the pool has less than min_bytes_to_hold reserved,\n then the TrimTo operation is a no-op.  Otherwise the memory pool will contain\n at least min_bytes_to_hold bytes reserved after the operation.\n\n @returns #hipSuccess, #hipErrorInvalidValue\n\n @see hipMallocFromPoolAsync, hipMallocAsync, hipFreeAsync, hipMemPoolGetAttribute,\n hipDeviceSetMemPool, hipMemPoolSetAttribute, hipMemPoolSetAccess, hipMemPoolGetAccess\n\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues.\n\n @note  This API is implemented on Linux, under development on Windows."]
    pub fn hipMemPoolTrimTo(mem_pool: hipMemPool_t, min_bytes_to_hold: usize) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Sets attributes of a memory pool\n\n Supported attributes are:\n - @p hipMemPoolAttrReleaseThreshold: (value type = cuuint64_t)\n                                  Amount of reserved memory in bytes to hold onto before trying\n                                  to release memory back to the OS. When more than the release\n                                  threshold bytes of memory are held by the memory pool, the\n                                  allocator will try to release memory back to the OS on the\n                                  next call to stream, event or context synchronize. (default 0)\n - @p hipMemPoolReuseFollowEventDependencies: (value type = int)\n                                  Allow @p hipMallocAsync to use memory asynchronously freed\n                                  in another stream as long as a stream ordering dependency\n                                  of the allocating stream on the free action exists.\n                                  HIP events and null stream interactions can create the required\n                                  stream ordered dependencies. (default enabled)\n - @p hipMemPoolReuseAllowOpportunistic: (value type = int)\n                                  Allow reuse of already completed frees when there is no dependency\n                                  between the free and allocation. (default enabled)\n - @p hipMemPoolReuseAllowInternalDependencies: (value type = int)\n                                  Allow @p hipMallocAsync to insert new stream dependencies\n                                  in order to establish the stream ordering required to reuse\n                                  a piece of memory released by @p hipFreeAsync (default enabled).\n\n @param [in] mem_pool The memory pool to modify\n @param [in] attr     The attribute to modify\n @param [in] value    Pointer to the value to assign\n\n @returns #hipSuccess, #hipErrorInvalidValue\n\n @see hipMallocFromPoolAsync, hipMallocAsync, hipFreeAsync, hipMemPoolGetAttribute,\n hipMemPoolTrimTo, hipDeviceSetMemPool, hipMemPoolSetAccess, hipMemPoolGetAccess\n\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues.\n\n @note  This API is implemented on Linux, under development on Windows."]
    pub fn hipMemPoolSetAttribute(
        mem_pool: hipMemPool_t,
        attr: hipMemPoolAttr,
        value: *mut ::std::os::raw::c_void,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Gets attributes of a memory pool\n\n Supported attributes are:\n - @p hipMemPoolAttrReleaseThreshold: (value type = cuuint64_t)\n                                  Amount of reserved memory in bytes to hold onto before trying\n                                  to release memory back to the OS. When more than the release\n                                  threshold bytes of memory are held by the memory pool, the\n                                  allocator will try to release memory back to the OS on the\n                                  next call to stream, event or context synchronize. (default 0)\n - @p hipMemPoolReuseFollowEventDependencies: (value type = int)\n                                  Allow @p hipMallocAsync to use memory asynchronously freed\n                                  in another stream as long as a stream ordering dependency\n                                  of the allocating stream on the free action exists.\n                                  HIP events and null stream interactions can create the required\n                                  stream ordered dependencies. (default enabled)\n - @p hipMemPoolReuseAllowOpportunistic: (value type = int)\n                                  Allow reuse of already completed frees when there is no dependency\n                                  between the free and allocation. (default enabled)\n - @p hipMemPoolReuseAllowInternalDependencies: (value type = int)\n                                  Allow @p hipMallocAsync to insert new stream dependencies\n                                  in order to establish the stream ordering required to reuse\n                                  a piece of memory released by @p hipFreeAsync (default enabled).\n\n @param [in] mem_pool The memory pool to get attributes of\n @param [in] attr     The attribute to get\n @param [in] value    Retrieved value\n\n @returns  #hipSuccess, #hipErrorInvalidValue\n\n @see hipMallocFromPoolAsync, hipMallocAsync, hipFreeAsync,\n hipMemPoolTrimTo, hipDeviceSetMemPool, hipMemPoolSetAttribute, hipMemPoolSetAccess, hipMemPoolGetAccess\n\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues.\n\n @note  This API is implemented on Linux, under development on Windows."]
    pub fn hipMemPoolGetAttribute(
        mem_pool: hipMemPool_t,
        attr: hipMemPoolAttr,
        value: *mut ::std::os::raw::c_void,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Controls visibility of the specified pool between devices\n\n @param [in] mem_pool   Memory pool for acccess change\n @param [in] desc_list  Array of access descriptors. Each descriptor instructs the access to enable for a single gpu\n @param [in] count  Number of descriptors in the map array.\n\n @returns  #hipSuccess, #hipErrorInvalidValue\n\n @see hipMallocFromPoolAsync, hipMallocAsync, hipFreeAsync, hipMemPoolGetAttribute,\n hipMemPoolTrimTo, hipDeviceSetMemPool, hipMemPoolSetAttribute, hipMemPoolGetAccess\n\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues.\n\n @note  This API is implemented on Linux, under development on Windows."]
    pub fn hipMemPoolSetAccess(
        mem_pool: hipMemPool_t,
        desc_list: *const hipMemAccessDesc,
        count: usize,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Returns the accessibility of a pool from a device\n\n Returns the accessibility of the pool's memory from the specified location.\n\n @param [out] flags    Accessibility of the memory pool from the specified location/device\n @param [in] mem_pool   Memory pool being queried\n @param [in] location  Location/device for memory pool access\n\n @returns #hipSuccess, #hipErrorInvalidValue\n\n @see hipMallocFromPoolAsync, hipMallocAsync, hipFreeAsync, hipMemPoolGetAttribute,\n hipMemPoolTrimTo, hipDeviceSetMemPool, hipMemPoolSetAttribute, hipMemPoolSetAccess\n\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues.\n\n @note  This API is implemented on Linux, under development on Windows."]
    pub fn hipMemPoolGetAccess(
        flags: *mut hipMemAccessFlags,
        mem_pool: hipMemPool_t,
        location: *mut hipMemLocation,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Creates a memory pool\n\n Creates a HIP memory pool and returns the handle in @p mem_pool. The @p pool_props determines\n the properties of the pool such as the backing device and IPC capabilities.\n\n By default, the memory pool will be accessible from the device it is allocated on.\n\n @param [out] mem_pool    Contains createed memory pool\n @param [in] pool_props   Memory pool properties\n\n @note Specifying hipMemHandleTypeNone creates a memory pool that will not support IPC.\n\n @returns #hipSuccess, #hipErrorInvalidValue, #hipErrorNotSupported\n\n @see hipMallocFromPoolAsync, hipMallocAsync, hipFreeAsync, hipMemPoolGetAttribute, hipMemPoolDestroy,\n hipMemPoolTrimTo, hipDeviceSetMemPool, hipMemPoolSetAttribute, hipMemPoolSetAccess, hipMemPoolGetAccess\n\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues.\n\n @note  This API is implemented on Linux, under development on Windows."]
    pub fn hipMemPoolCreate(
        mem_pool: *mut hipMemPool_t,
        pool_props: *const hipMemPoolProps,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Destroys the specified memory pool\n\n If any pointers obtained from this pool haven't been freed or\n the pool has free operations that haven't completed\n when @p hipMemPoolDestroy is invoked, the function will return immediately and the\n resources associated with the pool will be released automatically\n once there are no more outstanding allocations.\n\n Destroying the current mempool of a device sets the default mempool of\n that device as the current mempool for that device.\n\n @param [in] mem_pool Memory pool for destruction\n\n @note A device's default memory pool cannot be destroyed.\n\n @returns #hipSuccess, #hipErrorInvalidValue\n\n @see hipMallocFromPoolAsync, hipMallocAsync, hipFreeAsync, hipMemPoolGetAttribute, hipMemPoolCreate\n hipMemPoolTrimTo, hipDeviceSetMemPool, hipMemPoolSetAttribute, hipMemPoolSetAccess, hipMemPoolGetAccess\n\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues.\n\n @note  This API is implemented on Linux, under development on Windows."]
    pub fn hipMemPoolDestroy(mem_pool: hipMemPool_t) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Allocates memory from a specified pool with stream ordered semantics.\n\n Inserts an allocation operation into @p stream.\n A pointer to the allocated memory is returned immediately in @p dev_ptr.\n The allocation must not be accessed until the the allocation operation completes.\n The allocation comes from the specified memory pool.\n\n @note The specified memory pool may be from a device different than that of the specified @p stream.\n\n Basic stream ordering allows future work submitted into the same stream to use the allocation.\n Stream query, stream synchronize, and HIP events can be used to guarantee that the allocation\n operation completes before work submitted in a separate stream runs.\n\n @note During stream capture, this function results in the creation of an allocation node. In this case,\n the allocation is owned by the graph instead of the memory pool. The memory pool's properties\n are used to set the node's creation parameters.\n\n @param [out] dev_ptr Returned device pointer\n @param [in] size     Number of bytes to allocate\n @param [in] mem_pool The pool to allocate from\n @param [in] stream   The stream establishing the stream ordering semantic\n\n @returns #hipSuccess, #hipErrorInvalidValue, #hipErrorNotSupported, #hipErrorOutOfMemory\n\n @see hipMallocAsync, hipFreeAsync, hipMemPoolGetAttribute, hipMemPoolCreate\n hipMemPoolTrimTo, hipDeviceSetMemPool, hipMemPoolSetAttribute, hipMemPoolSetAccess, hipMemPoolGetAccess,\n\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues.\n\n @note  This API is implemented on Linux, under development on Windows."]
    pub fn hipMallocFromPoolAsync(
        dev_ptr: *mut *mut ::std::os::raw::c_void,
        size: usize,
        mem_pool: hipMemPool_t,
        stream: hipStream_t,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Exports a memory pool to the requested handle type.\n\n Given an IPC capable mempool, create an OS handle to share the pool with another process.\n A recipient process can convert the shareable handle into a mempool with @p hipMemPoolImportFromShareableHandle.\n Individual pointers can then be shared with the @p hipMemPoolExportPointer and @p hipMemPoolImportPointer APIs.\n The implementation of what the shareable handle is and how it can be transferred is defined by the requested\n handle type.\n\n @note: To create an IPC capable mempool, create a mempool with a @p hipMemAllocationHandleType other\n than @p hipMemHandleTypeNone.\n\n @param [out] shared_handle Pointer to the location in which to store the requested handle\n @param [in] mem_pool       Pool to export\n @param [in] handle_type    The type of handle to create\n @param [in] flags          Must be 0\n\n @returns #hipSuccess, #hipErrorInvalidValue, #hipErrorOutOfMemory\n\n @see hipMemPoolImportFromShareableHandle\n\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues.\n\n @note  This API is implemented on Linux, under development on Windows."]
    pub fn hipMemPoolExportToShareableHandle(
        shared_handle: *mut ::std::os::raw::c_void,
        mem_pool: hipMemPool_t,
        handle_type: hipMemAllocationHandleType,
        flags: ::std::os::raw::c_uint,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Imports a memory pool from a shared handle.\n\n Specific allocations can be imported from the imported pool with @p hipMemPoolImportPointer.\n\n @note Imported memory pools do not support creating new allocations.\n As such imported memory pools may not be used in @p hipDeviceSetMemPool\n or @p hipMallocFromPoolAsync calls.\n\n @param [out] mem_pool     Returned memory pool\n @param [in] shared_handle OS handle of the pool to open\n @param [in] handle_type   The type of handle being imported\n @param [in] flags         Must be 0\n\n @returns #hipSuccess, #hipErrorInvalidValue, #hipErrorOutOfMemory\n\n @see hipMemPoolExportToShareableHandle\n\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues.\n\n @note  This API is implemented on Linux, under development on Windows."]
    pub fn hipMemPoolImportFromShareableHandle(
        mem_pool: *mut hipMemPool_t,
        shared_handle: *mut ::std::os::raw::c_void,
        handle_type: hipMemAllocationHandleType,
        flags: ::std::os::raw::c_uint,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Export data to share a memory pool allocation between processes.\n\n Constructs @p export_data for sharing a specific allocation from an already shared memory pool.\n The recipient process can import the allocation with the @p hipMemPoolImportPointer api.\n The data is not a handle and may be shared through any IPC mechanism.\n\n @param[out] export_data  Returned export data\n @param[in] dev_ptr       Pointer to memory being exported\n\n @returns #hipSuccess, #hipErrorInvalidValue, #hipErrorOutOfMemory\n\n @see hipMemPoolImportPointer\n\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues.\n\n @note  This API is implemented on Linux, under development on Windows."]
    pub fn hipMemPoolExportPointer(
        export_data: *mut hipMemPoolPtrExportData,
        dev_ptr: *mut ::std::os::raw::c_void,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Import a memory pool allocation from another process.\n\n Returns in @p dev_ptr a pointer to the imported memory.\n The imported memory must not be accessed before the allocation operation completes\n in the exporting process. The imported memory must be freed from all importing processes before\n being freed in the exporting process. The pointer may be freed with @p hipFree\n or @p hipFreeAsync. If @p hipFreeAsync is used, the free must be completed\n on the importing process before the free operation on the exporting process.\n\n @note The @p hipFreeAsync api may be used in the exporting process before\n the @p hipFreeAsync operation completes in its stream as long as the\n @p hipFreeAsync in the exporting process specifies a stream with\n a stream dependency on the importing process's @p hipFreeAsync.\n\n @param [out] dev_ptr     Pointer to imported memory\n @param [in] mem_pool     Memory pool from which to import a pointer\n @param [in] export_data  Data specifying the memory to import\n\n @returns #hipSuccess, #hipErrorInvalidValue, #hipErrorNotInitialized, #hipErrorOutOfMemory\n\n @see hipMemPoolExportPointer\n\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues.\n\n @note  This API is implemented on Linux, under development on Windows."]
    pub fn hipMemPoolImportPointer(
        dev_ptr: *mut *mut ::std::os::raw::c_void,
        mem_pool: hipMemPool_t,
        export_data: *mut hipMemPoolPtrExportData,
    ) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Allocate device accessible page locked host memory [Deprecated]\n\n  @param[out] ptr Pointer to the allocated host pinned memory\n  @param[in]  size Requested memory size in bytes\n  @param[in]  flags Type of host memory allocation\n\n  If size is 0, no memory is allocated, *ptr returns nullptr, and hipSuccess is returned.\n\n  @return #hipSuccess, #hipErrorOutOfMemory\n\n  @warning This API is deprecated, use hipHostMalloc() instead"]
    pub fn hipHostAlloc(
        ptr: *mut *mut ::std::os::raw::c_void,
        size: usize,
        flags: ::std::os::raw::c_uint,
    ) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Get Device pointer from Host Pointer allocated through hipHostMalloc\n\n  @param[out] dstPtr Device Pointer mapped to passed host pointer\n  @param[in]  hstPtr Host Pointer allocated through hipHostMalloc\n  @param[in]  flags Flags to be passed for extension\n\n  @return #hipSuccess, #hipErrorInvalidValue, #hipErrorOutOfMemory\n\n  @see hipSetDeviceFlags, hipHostMalloc"]
    pub fn hipHostGetDevicePointer(
        devPtr: *mut *mut ::std::os::raw::c_void,
        hstPtr: *mut ::std::os::raw::c_void,
        flags: ::std::os::raw::c_uint,
    ) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Return flags associated with host pointer\n\n  @param[out] flagsPtr Memory location to store flags\n  @param[in]  hostPtr Host Pointer allocated through hipHostMalloc\n  @return #hipSuccess, #hipErrorInvalidValue\n\n  @see hipHostMalloc"]
    pub fn hipHostGetFlags(
        flagsPtr: *mut ::std::os::raw::c_uint,
        hostPtr: *mut ::std::os::raw::c_void,
    ) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Register host memory so it can be accessed from the current device.\n\n  @param[out] hostPtr Pointer to host memory to be registered.\n  @param[in] sizeBytes size of the host memory\n  @param[in] flags.  See below.\n\n  Flags:\n  - #hipHostRegisterDefault   Memory is Mapped and Portable\n  - #hipHostRegisterPortable  Memory is considered registered by all contexts.  HIP only supports\n one context so this is always assumed true.\n  - #hipHostRegisterMapped    Map the allocation into the address space for the current device.\n The device pointer can be obtained with #hipHostGetDevicePointer.\n\n\n  After registering the memory, use #hipHostGetDevicePointer to obtain the mapped device pointer.\n  On many systems, the mapped device pointer will have a different value than the mapped host\n pointer.  Applications must use the device pointer in device code, and the host pointer in device\n code.\n\n  On some systems, registered memory is pinned.  On some systems, registered memory may not be\n actually be pinned but uses OS or hardware facilities to all GPU access to the host memory.\n\n  Developers are strongly encouraged to register memory blocks which are aligned to the host\n cache-line size. (typically 64-bytes but can be obtains from the CPUID instruction).\n\n  If registering non-aligned pointers, the application must take care when register pointers from\n the same cache line on different devices.  HIP's coarse-grained synchronization model does not\n guarantee correct results if different devices write to different parts of the same cache block -\n typically one of the writes will \"win\" and overwrite data from the other registered memory\n region.\n\n  @return #hipSuccess, #hipErrorOutOfMemory\n\n  @see hipHostUnregister, hipHostGetFlags, hipHostGetDevicePointer"]
    pub fn hipHostRegister(
        hostPtr: *mut ::std::os::raw::c_void,
        sizeBytes: usize,
        flags: ::std::os::raw::c_uint,
    ) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Un-register host pointer\n\n  @param[in] hostPtr Host pointer previously registered with #hipHostRegister\n  @return Error code\n\n  @see hipHostRegister"]
    pub fn hipHostUnregister(hostPtr: *mut ::std::os::raw::c_void) -> hipError_t;
}
extern "C" {
    #[doc = "  Allocates at least width (in bytes) * height bytes of linear memory\n  Padding may occur to ensure alighnment requirements are met for the given row\n  The change in width size due to padding will be returned in *pitch.\n  Currently the alignment is set to 128 bytes\n\n  @param[out] ptr Pointer to the allocated device memory\n  @param[out] pitch Pitch for allocation (in bytes)\n  @param[in]  width Requested pitched allocation width (in bytes)\n  @param[in]  height Requested pitched allocation height\n\n  If size is 0, no memory is allocated, *ptr returns nullptr, and hipSuccess is returned.\n\n  @return Error code\n\n  @see hipMalloc, hipFree, hipMallocArray, hipFreeArray, hipHostFree, hipMalloc3D,\n hipMalloc3DArray, hipHostMalloc"]
    pub fn hipMallocPitch(
        ptr: *mut *mut ::std::os::raw::c_void,
        pitch: *mut usize,
        width: usize,
        height: usize,
    ) -> hipError_t;
}
extern "C" {
    #[doc = "  Allocates at least width (in bytes) * height bytes of linear memory\n  Padding may occur to ensure alighnment requirements are met for the given row\n  The change in width size due to padding will be returned in *pitch.\n  Currently the alignment is set to 128 bytes\n\n  @param[out] dptr Pointer to the allocated device memory\n  @param[out] pitch Pitch for allocation (in bytes)\n  @param[in]  width Requested pitched allocation width (in bytes)\n  @param[in]  height Requested pitched allocation height\n\n  If size is 0, no memory is allocated, *ptr returns nullptr, and hipSuccess is returned.\n  The intended usage of pitch is as a separate parameter of the allocation, used to compute addresses within the 2D array.\n  Given the row and column of an array element of type T, the address is computed as:\n  T* pElement = (T*)((char*)BaseAddress + Row * Pitch) + Column;\n\n  @return Error code\n\n  @see hipMalloc, hipFree, hipMallocArray, hipFreeArray, hipHostFree, hipMalloc3D,\n hipMalloc3DArray, hipHostMalloc"]
    pub fn hipMemAllocPitch(
        dptr: *mut hipDeviceptr_t,
        pitch: *mut usize,
        widthInBytes: usize,
        height: usize,
        elementSizeBytes: ::std::os::raw::c_uint,
    ) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Free memory allocated by the hcc hip memory allocation API.\n  This API performs an implicit hipDeviceSynchronize() call.\n  If pointer is NULL, the hip runtime is initialized and hipSuccess is returned.\n\n  @param[in] ptr Pointer to memory to be freed\n  @return #hipSuccess\n  @return #hipErrorInvalidDevicePointer (if pointer is invalid, including host pointers allocated\n with hipHostMalloc)\n\n  @see hipMalloc, hipMallocPitch, hipMallocArray, hipFreeArray, hipHostFree, hipMalloc3D,\n hipMalloc3DArray, hipHostMalloc"]
    pub fn hipFree(ptr: *mut ::std::os::raw::c_void) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Free memory allocated by the hcc hip host memory allocation API [Deprecated]\n\n  @param[in] ptr Pointer to memory to be freed\n  @return #hipSuccess,\n          #hipErrorInvalidValue (if pointer is invalid, including device pointers allocated\n  with hipMalloc)\n\n  @warning  This API is deprecated, use hipHostFree() instead"]
    pub fn hipFreeHost(ptr: *mut ::std::os::raw::c_void) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Free memory allocated by the hcc hip host memory allocation API\n  This API performs an implicit hipDeviceSynchronize() call.\n  If pointer is NULL, the hip runtime is initialized and hipSuccess is returned.\n\n  @param[in] ptr Pointer to memory to be freed\n  @return #hipSuccess,\n          #hipErrorInvalidValue (if pointer is invalid, including device pointers allocated with\n hipMalloc)\n\n  @see hipMalloc, hipMallocPitch, hipFree, hipMallocArray, hipFreeArray, hipMalloc3D,\n hipMalloc3DArray, hipHostMalloc"]
    pub fn hipHostFree(ptr: *mut ::std::os::raw::c_void) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Copy data from src to dst.\n\n  It supports memory from host to device,\n  device to host, device to device and host to host\n  The src and dst must not overlap.\n\n  For hipMemcpy, the copy is always performed by the current device (set by hipSetDevice).\n  For multi-gpu or peer-to-peer configurations, it is recommended to set the current device to the\n  device where the src data is physically located. For optimal peer-to-peer copies, the copy device\n  must be able to access the src and dst pointers (by calling hipDeviceEnablePeerAccess with copy\n  agent as the current device and src/dest as the peerDevice argument.  if this is not done, the\n  hipMemcpy will still work, but will perform the copy using a staging buffer on the host.\n  Calling hipMemcpy with dst and src pointers that do not match the hipMemcpyKind results in\n  undefined behavior.\n\n  @param[out]  dst Data being copy to\n  @param[in]  src Data being copy from\n  @param[in]  sizeBytes Data size in bytes\n  @param[in]  copyType Memory copy type\n  @return #hipSuccess, #hipErrorInvalidValue, #hipErrorMemoryFree, #hipErrorUnknown\n\n  @see hipArrayCreate, hipArrayDestroy, hipArrayGetDescriptor, hipMemAlloc, hipMemAllocHost,\n hipMemAllocPitch, hipMemcpy2D, hipMemcpy2DAsync, hipMemcpy2DUnaligned, hipMemcpyAtoA,\n hipMemcpyAtoD, hipMemcpyAtoH, hipMemcpyAtoHAsync, hipMemcpyDtoA, hipMemcpyDtoD,\n hipMemcpyDtoDAsync, hipMemcpyDtoH, hipMemcpyDtoHAsync, hipMemcpyHtoA, hipMemcpyHtoAAsync,\n hipMemcpyHtoDAsync, hipMemFree, hipMemFreeHost, hipMemGetAddressRange, hipMemGetInfo,\n hipMemHostAlloc, hipMemHostGetDevicePointer"]
    pub fn hipMemcpy(
        dst: *mut ::std::os::raw::c_void,
        src: *const ::std::os::raw::c_void,
        sizeBytes: usize,
        kind: hipMemcpyKind,
    ) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Memory copy on the stream.\n  It allows single or multiple devices to do memory copy on single or multiple streams.\n\n  @param[out]  dst Data being copy to\n  @param[in]  src Data being copy from\n  @param[in]  sizeBytes Data size in bytes\n  @param[in]  copyType Memory copy type\n  @param[in]  stream Valid stream\n  @return #hipSuccess, #hipErrorInvalidValue, #hipErrorMemoryFree, #hipErrorUnknown, #hipErrorContextIsDestroyed\n\n  @see hipMemcpy, hipStreamCreate, hipStreamSynchronize, hipStreamDestroy, hipSetDevice, hipLaunchKernelGGL\n"]
    pub fn hipMemcpyWithStream(
        dst: *mut ::std::os::raw::c_void,
        src: *const ::std::os::raw::c_void,
        sizeBytes: usize,
        kind: hipMemcpyKind,
        stream: hipStream_t,
    ) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Copy data from Host to Device\n\n  @param[out]  dst Data being copy to\n  @param[in]   src Data being copy from\n  @param[in]   sizeBytes Data size in bytes\n\n  @return #hipSuccess, #hipErrorDeinitialized, #hipErrorNotInitialized, #hipErrorInvalidContext,\n #hipErrorInvalidValue\n\n  @see hipArrayCreate, hipArrayDestroy, hipArrayGetDescriptor, hipMemAlloc, hipMemAllocHost,\n hipMemAllocPitch, hipMemcpy2D, hipMemcpy2DAsync, hipMemcpy2DUnaligned, hipMemcpyAtoA,\n hipMemcpyAtoD, hipMemcpyAtoH, hipMemcpyAtoHAsync, hipMemcpyDtoA, hipMemcpyDtoD,\n hipMemcpyDtoDAsync, hipMemcpyDtoH, hipMemcpyDtoHAsync, hipMemcpyHtoA, hipMemcpyHtoAAsync,\n hipMemcpyHtoDAsync, hipMemFree, hipMemFreeHost, hipMemGetAddressRange, hipMemGetInfo,\n hipMemHostAlloc, hipMemHostGetDevicePointer"]
    pub fn hipMemcpyHtoD(
        dst: hipDeviceptr_t,
        src: *mut ::std::os::raw::c_void,
        sizeBytes: usize,
    ) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Copy data from Device to Host\n\n  @param[out]  dst Data being copy to\n  @param[in]   src Data being copy from\n  @param[in]   sizeBytes Data size in bytes\n\n  @return #hipSuccess, #hipErrorDeinitialized, #hipErrorNotInitialized, #hipErrorInvalidContext,\n #hipErrorInvalidValue\n\n  @see hipArrayCreate, hipArrayDestroy, hipArrayGetDescriptor, hipMemAlloc, hipMemAllocHost,\n hipMemAllocPitch, hipMemcpy2D, hipMemcpy2DAsync, hipMemcpy2DUnaligned, hipMemcpyAtoA,\n hipMemcpyAtoD, hipMemcpyAtoH, hipMemcpyAtoHAsync, hipMemcpyDtoA, hipMemcpyDtoD,\n hipMemcpyDtoDAsync, hipMemcpyDtoH, hipMemcpyDtoHAsync, hipMemcpyHtoA, hipMemcpyHtoAAsync,\n hipMemcpyHtoDAsync, hipMemFree, hipMemFreeHost, hipMemGetAddressRange, hipMemGetInfo,\n hipMemHostAlloc, hipMemHostGetDevicePointer"]
    pub fn hipMemcpyDtoH(
        dst: *mut ::std::os::raw::c_void,
        src: hipDeviceptr_t,
        sizeBytes: usize,
    ) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Copy data from Device to Device\n\n  @param[out]  dst Data being copy to\n  @param[in]   src Data being copy from\n  @param[in]   sizeBytes Data size in bytes\n\n  @return #hipSuccess, #hipErrorDeinitialized, #hipErrorNotInitialized, #hipErrorInvalidContext,\n #hipErrorInvalidValue\n\n  @see hipArrayCreate, hipArrayDestroy, hipArrayGetDescriptor, hipMemAlloc, hipMemAllocHost,\n hipMemAllocPitch, hipMemcpy2D, hipMemcpy2DAsync, hipMemcpy2DUnaligned, hipMemcpyAtoA,\n hipMemcpyAtoD, hipMemcpyAtoH, hipMemcpyAtoHAsync, hipMemcpyDtoA, hipMemcpyDtoD,\n hipMemcpyDtoDAsync, hipMemcpyDtoH, hipMemcpyDtoHAsync, hipMemcpyHtoA, hipMemcpyHtoAAsync,\n hipMemcpyHtoDAsync, hipMemFree, hipMemFreeHost, hipMemGetAddressRange, hipMemGetInfo,\n hipMemHostAlloc, hipMemHostGetDevicePointer"]
    pub fn hipMemcpyDtoD(dst: hipDeviceptr_t, src: hipDeviceptr_t, sizeBytes: usize) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Copy data from Host to Device asynchronously\n\n  @param[out]  dst Data being copy to\n  @param[in]   src Data being copy from\n  @param[in]   sizeBytes Data size in bytes\n\n  @return #hipSuccess, #hipErrorDeinitialized, #hipErrorNotInitialized, #hipErrorInvalidContext,\n #hipErrorInvalidValue\n\n  @see hipArrayCreate, hipArrayDestroy, hipArrayGetDescriptor, hipMemAlloc, hipMemAllocHost,\n hipMemAllocPitch, hipMemcpy2D, hipMemcpy2DAsync, hipMemcpy2DUnaligned, hipMemcpyAtoA,\n hipMemcpyAtoD, hipMemcpyAtoH, hipMemcpyAtoHAsync, hipMemcpyDtoA, hipMemcpyDtoD,\n hipMemcpyDtoDAsync, hipMemcpyDtoH, hipMemcpyDtoHAsync, hipMemcpyHtoA, hipMemcpyHtoAAsync,\n hipMemcpyHtoDAsync, hipMemFree, hipMemFreeHost, hipMemGetAddressRange, hipMemGetInfo,\n hipMemHostAlloc, hipMemHostGetDevicePointer"]
    pub fn hipMemcpyHtoDAsync(
        dst: hipDeviceptr_t,
        src: *mut ::std::os::raw::c_void,
        sizeBytes: usize,
        stream: hipStream_t,
    ) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Copy data from Device to Host asynchronously\n\n  @param[out]  dst Data being copy to\n  @param[in]   src Data being copy from\n  @param[in]   sizeBytes Data size in bytes\n\n  @return #hipSuccess, #hipErrorDeinitialized, #hipErrorNotInitialized, #hipErrorInvalidContext,\n #hipErrorInvalidValue\n\n  @see hipArrayCreate, hipArrayDestroy, hipArrayGetDescriptor, hipMemAlloc, hipMemAllocHost,\n hipMemAllocPitch, hipMemcpy2D, hipMemcpy2DAsync, hipMemcpy2DUnaligned, hipMemcpyAtoA,\n hipMemcpyAtoD, hipMemcpyAtoH, hipMemcpyAtoHAsync, hipMemcpyDtoA, hipMemcpyDtoD,\n hipMemcpyDtoDAsync, hipMemcpyDtoH, hipMemcpyDtoHAsync, hipMemcpyHtoA, hipMemcpyHtoAAsync,\n hipMemcpyHtoDAsync, hipMemFree, hipMemFreeHost, hipMemGetAddressRange, hipMemGetInfo,\n hipMemHostAlloc, hipMemHostGetDevicePointer"]
    pub fn hipMemcpyDtoHAsync(
        dst: *mut ::std::os::raw::c_void,
        src: hipDeviceptr_t,
        sizeBytes: usize,
        stream: hipStream_t,
    ) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Copy data from Device to Device asynchronously\n\n  @param[out]  dst Data being copy to\n  @param[in]   src Data being copy from\n  @param[in]   sizeBytes Data size in bytes\n\n  @return #hipSuccess, #hipErrorDeinitialized, #hipErrorNotInitialized, #hipErrorInvalidContext,\n #hipErrorInvalidValue\n\n  @see hipArrayCreate, hipArrayDestroy, hipArrayGetDescriptor, hipMemAlloc, hipMemAllocHost,\n hipMemAllocPitch, hipMemcpy2D, hipMemcpy2DAsync, hipMemcpy2DUnaligned, hipMemcpyAtoA,\n hipMemcpyAtoD, hipMemcpyAtoH, hipMemcpyAtoHAsync, hipMemcpyDtoA, hipMemcpyDtoD,\n hipMemcpyDtoDAsync, hipMemcpyDtoH, hipMemcpyDtoHAsync, hipMemcpyHtoA, hipMemcpyHtoAAsync,\n hipMemcpyHtoDAsync, hipMemFree, hipMemFreeHost, hipMemGetAddressRange, hipMemGetInfo,\n hipMemHostAlloc, hipMemHostGetDevicePointer"]
    pub fn hipMemcpyDtoDAsync(
        dst: hipDeviceptr_t,
        src: hipDeviceptr_t,
        sizeBytes: usize,
        stream: hipStream_t,
    ) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Returns a global pointer from a module.\n  Returns in *dptr and *bytes the pointer and size of the global of name name located in module hmod.\n  If no variable of that name exists, it returns hipErrorNotFound. Both parameters dptr and bytes are optional.\n  If one of them is NULL, it is ignored and hipSuccess is returned.\n\n  @param[out]  dptr  Returns global device pointer\n  @param[out]  bytes Returns global size in bytes\n  @param[in]   hmod  Module to retrieve global from\n  @param[in]   name  Name of global to retrieve\n\n  @return #hipSuccess, #hipErrorInvalidValue, #hipErrorNotFound, #hipErrorInvalidContext\n"]
    pub fn hipModuleGetGlobal(
        dptr: *mut hipDeviceptr_t,
        bytes: *mut usize,
        hmod: hipModule_t,
        name: *const ::std::os::raw::c_char,
    ) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Gets device pointer associated with symbol on the device.\n\n  @param[out]  devPtr  pointer to the device associated the symbole\n  @param[in]   symbol  pointer to the symbole of the device\n\n  @return #hipSuccess, #hipErrorInvalidValue\n"]
    pub fn hipGetSymbolAddress(
        devPtr: *mut *mut ::std::os::raw::c_void,
        symbol: *const ::std::os::raw::c_void,
    ) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Gets the size of the given symbol on the device.\n\n  @param[in]   symbol  pointer to the device symbole\n  @param[out]  size  pointer to the size\n\n  @return #hipSuccess, #hipErrorInvalidValue\n"]
    pub fn hipGetSymbolSize(size: *mut usize, symbol: *const ::std::os::raw::c_void) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Copies data to the given symbol on the device.\n Symbol HIP APIs allow a kernel to define a device-side data symbol which can be accessed on\n the host side. The symbol can be in __constant or device space.\n Note that the symbol name needs to be encased in the HIP_SYMBOL macro.\n This also applies to hipMemcpyFromSymbol, hipGetSymbolAddress, and hipGetSymbolSize.\n For detail usage, see the example at\n https://github.com/ROCm-Developer-Tools/HIP/blob/rocm-5.0.x/docs/markdown/hip_porting_guide.md\n\n  @param[out]  symbol  pointer to the device symbole\n  @param[in]   src  pointer to the source address\n  @param[in]   sizeBytes  size in bytes to copy\n  @param[in]   offset  offset in bytes from start of symbole\n  @param[in]   kind  type of memory transfer\n\n  @return #hipSuccess, #hipErrorInvalidValue\n"]
    pub fn hipMemcpyToSymbol(
        symbol: *const ::std::os::raw::c_void,
        src: *const ::std::os::raw::c_void,
        sizeBytes: usize,
        offset: usize,
        kind: hipMemcpyKind,
    ) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Copies data to the given symbol on the device asynchronously.\n\n  @param[out]  symbol  pointer to the device symbole\n  @param[in]   src  pointer to the source address\n  @param[in]   sizeBytes  size in bytes to copy\n  @param[in]   offset  offset in bytes from start of symbole\n  @param[in]   kind  type of memory transfer\n  @param[in]   stream  stream identifier\n\n  @return #hipSuccess, #hipErrorInvalidValue\n"]
    pub fn hipMemcpyToSymbolAsync(
        symbol: *const ::std::os::raw::c_void,
        src: *const ::std::os::raw::c_void,
        sizeBytes: usize,
        offset: usize,
        kind: hipMemcpyKind,
        stream: hipStream_t,
    ) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Copies data from the given symbol on the device.\n\n  @param[out]  dptr  Returns pointer to destinition memory address\n  @param[in]   symbol  pointer to the symbole address on the device\n  @param[in]   sizeBytes  size in bytes to copy\n  @param[in]   offset  offset in bytes from the start of symbole\n  @param[in]   kind  type of memory transfer\n\n  @return #hipSuccess, #hipErrorInvalidValue\n"]
    pub fn hipMemcpyFromSymbol(
        dst: *mut ::std::os::raw::c_void,
        symbol: *const ::std::os::raw::c_void,
        sizeBytes: usize,
        offset: usize,
        kind: hipMemcpyKind,
    ) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Copies data from the given symbol on the device asynchronously.\n\n  @param[out]  dptr  Returns pointer to destinition memory address\n  @param[in]   symbol  pointer to the symbole address on the device\n  @param[in]   sizeBytes  size in bytes to copy\n  @param[in]   offset  offset in bytes from the start of symbole\n  @param[in]   kind  type of memory transfer\n  @param[in]   stream  stream identifier\n\n  @return #hipSuccess, #hipErrorInvalidValue\n"]
    pub fn hipMemcpyFromSymbolAsync(
        dst: *mut ::std::os::raw::c_void,
        symbol: *const ::std::os::raw::c_void,
        sizeBytes: usize,
        offset: usize,
        kind: hipMemcpyKind,
        stream: hipStream_t,
    ) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Copy data from src to dst asynchronously.\n\n  @warning If host or dest are not pinned, the memory copy will be performed synchronously.  For\n best performance, use hipHostMalloc to allocate host memory that is transferred asynchronously.\n\n  @warning on HCC hipMemcpyAsync does not support overlapped H2D and D2H copies.\n  For hipMemcpy, the copy is always performed by the device associated with the specified stream.\n\n  For multi-gpu or peer-to-peer configurations, it is recommended to use a stream which is a\n attached to the device where the src data is physically located. For optimal peer-to-peer copies,\n the copy device must be able to access the src and dst pointers (by calling\n hipDeviceEnablePeerAccess with copy agent as the current device and src/dest as the peerDevice\n argument.  if this is not done, the hipMemcpy will still work, but will perform the copy using a\n staging buffer on the host.\n\n  @param[out] dst Data being copy to\n  @param[in]  src Data being copy from\n  @param[in]  sizeBytes Data size in bytes\n  @param[in]  accelerator_view Accelerator view which the copy is being enqueued\n  @return #hipSuccess, #hipErrorInvalidValue, #hipErrorMemoryFree, #hipErrorUnknown\n\n  @see hipMemcpy, hipMemcpy2D, hipMemcpyToArray, hipMemcpy2DToArray, hipMemcpyFromArray,\n hipMemcpy2DFromArray, hipMemcpyArrayToArray, hipMemcpy2DArrayToArray, hipMemcpyToSymbol,\n hipMemcpyFromSymbol, hipMemcpy2DAsync, hipMemcpyToArrayAsync, hipMemcpy2DToArrayAsync,\n hipMemcpyFromArrayAsync, hipMemcpy2DFromArrayAsync, hipMemcpyToSymbolAsync,\n hipMemcpyFromSymbolAsync"]
    pub fn hipMemcpyAsync(
        dst: *mut ::std::os::raw::c_void,
        src: *const ::std::os::raw::c_void,
        sizeBytes: usize,
        kind: hipMemcpyKind,
        stream: hipStream_t,
    ) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Fills the first sizeBytes bytes of the memory area pointed to by dest with the constant\n byte value value.\n\n  @param[out] dst Data being filled\n  @param[in]  constant value to be set\n  @param[in]  sizeBytes Data size in bytes\n  @return #hipSuccess, #hipErrorInvalidValue, #hipErrorNotInitialized"]
    pub fn hipMemset(
        dst: *mut ::std::os::raw::c_void,
        value: ::std::os::raw::c_int,
        sizeBytes: usize,
    ) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Fills the first sizeBytes bytes of the memory area pointed to by dest with the constant\n byte value value.\n\n  @param[out] dst Data ptr to be filled\n  @param[in]  constant value to be set\n  @param[in]  number of values to be set\n  @return #hipSuccess, #hipErrorInvalidValue, #hipErrorNotInitialized"]
    pub fn hipMemsetD8(
        dest: hipDeviceptr_t,
        value: ::std::os::raw::c_uchar,
        count: usize,
    ) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Fills the first sizeBytes bytes of the memory area pointed to by dest with the constant\n byte value value.\n\n hipMemsetD8Async() is asynchronous with respect to the host, so the call may return before the\n memset is complete. The operation can optionally be associated to a stream by passing a non-zero\n stream argument. If stream is non-zero, the operation may overlap with operations in other\n streams.\n\n  @param[out] dst Data ptr to be filled\n  @param[in]  constant value to be set\n  @param[in]  number of values to be set\n  @param[in]  stream - Stream identifier\n  @return #hipSuccess, #hipErrorInvalidValue, #hipErrorNotInitialized"]
    pub fn hipMemsetD8Async(
        dest: hipDeviceptr_t,
        value: ::std::os::raw::c_uchar,
        count: usize,
        stream: hipStream_t,
    ) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Fills the first sizeBytes bytes of the memory area pointed to by dest with the constant\n short value value.\n\n  @param[out] dst Data ptr to be filled\n  @param[in]  constant value to be set\n  @param[in]  number of values to be set\n  @return #hipSuccess, #hipErrorInvalidValue, #hipErrorNotInitialized"]
    pub fn hipMemsetD16(
        dest: hipDeviceptr_t,
        value: ::std::os::raw::c_ushort,
        count: usize,
    ) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Fills the first sizeBytes bytes of the memory area pointed to by dest with the constant\n short value value.\n\n hipMemsetD16Async() is asynchronous with respect to the host, so the call may return before the\n memset is complete. The operation can optionally be associated to a stream by passing a non-zero\n stream argument. If stream is non-zero, the operation may overlap with operations in other\n streams.\n\n  @param[out] dst Data ptr to be filled\n  @param[in]  constant value to be set\n  @param[in]  number of values to be set\n  @param[in]  stream - Stream identifier\n  @return #hipSuccess, #hipErrorInvalidValue, #hipErrorNotInitialized"]
    pub fn hipMemsetD16Async(
        dest: hipDeviceptr_t,
        value: ::std::os::raw::c_ushort,
        count: usize,
        stream: hipStream_t,
    ) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Fills the memory area pointed to by dest with the constant integer\n value for specified number of times.\n\n  @param[out] dst Data being filled\n  @param[in]  constant value to be set\n  @param[in]  number of values to be set\n  @return #hipSuccess, #hipErrorInvalidValue, #hipErrorNotInitialized"]
    pub fn hipMemsetD32(
        dest: hipDeviceptr_t,
        value: ::std::os::raw::c_int,
        count: usize,
    ) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Fills the first sizeBytes bytes of the memory area pointed to by dev with the constant\n byte value value.\n\n hipMemsetAsync() is asynchronous with respect to the host, so the call may return before the\n memset is complete. The operation can optionally be associated to a stream by passing a non-zero\n stream argument. If stream is non-zero, the operation may overlap with operations in other\n streams.\n\n  @param[out] dst Pointer to device memory\n  @param[in]  value - Value to set for each byte of specified memory\n  @param[in]  sizeBytes - Size in bytes to set\n  @param[in]  stream - Stream identifier\n  @return #hipSuccess, #hipErrorInvalidValue, #hipErrorMemoryFree"]
    pub fn hipMemsetAsync(
        dst: *mut ::std::os::raw::c_void,
        value: ::std::os::raw::c_int,
        sizeBytes: usize,
        stream: hipStream_t,
    ) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Fills the memory area pointed to by dev with the constant integer\n value for specified number of times.\n\n  hipMemsetD32Async() is asynchronous with respect to the host, so the call may return before the\n memset is complete. The operation can optionally be associated to a stream by passing a non-zero\n stream argument. If stream is non-zero, the operation may overlap with operations in other\n streams.\n\n  @param[out] dst Pointer to device memory\n  @param[in]  value - Value to set for each byte of specified memory\n  @param[in]  count - number of values to be set\n  @param[in]  stream - Stream identifier\n  @return #hipSuccess, #hipErrorInvalidValue, #hipErrorMemoryFree"]
    pub fn hipMemsetD32Async(
        dst: hipDeviceptr_t,
        value: ::std::os::raw::c_int,
        count: usize,
        stream: hipStream_t,
    ) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Fills the memory area pointed to by dst with the constant value.\n\n  @param[out] dst Pointer to device memory\n  @param[in]  pitch - data size in bytes\n  @param[in]  value - constant value to be set\n  @param[in]  width\n  @param[in]  height\n  @return #hipSuccess, #hipErrorInvalidValue, #hipErrorMemoryFree"]
    pub fn hipMemset2D(
        dst: *mut ::std::os::raw::c_void,
        pitch: usize,
        value: ::std::os::raw::c_int,
        width: usize,
        height: usize,
    ) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Fills asynchronously the memory area pointed to by dst with the constant value.\n\n  @param[in]  dst Pointer to device memory\n  @param[in]  pitch - data size in bytes\n  @param[in]  value - constant value to be set\n  @param[in]  width\n  @param[in]  height\n  @param[in]  stream\n  @return #hipSuccess, #hipErrorInvalidValue, #hipErrorMemoryFree"]
    pub fn hipMemset2DAsync(
        dst: *mut ::std::os::raw::c_void,
        pitch: usize,
        value: ::std::os::raw::c_int,
        width: usize,
        height: usize,
        stream: hipStream_t,
    ) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Fills synchronously the memory area pointed to by pitchedDevPtr with the constant value.\n\n  @param[in] pitchedDevPtr\n  @param[in]  value - constant value to be set\n  @param[in]  extent\n  @return #hipSuccess, #hipErrorInvalidValue, #hipErrorMemoryFree"]
    pub fn hipMemset3D(
        pitchedDevPtr: hipPitchedPtr,
        value: ::std::os::raw::c_int,
        extent: hipExtent,
    ) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Fills asynchronously the memory area pointed to by pitchedDevPtr with the constant value.\n\n  @param[in] pitchedDevPtr\n  @param[in]  value - constant value to be set\n  @param[in]  extent\n  @param[in]  stream\n  @return #hipSuccess, #hipErrorInvalidValue, #hipErrorMemoryFree"]
    pub fn hipMemset3DAsync(
        pitchedDevPtr: hipPitchedPtr,
        value: ::std::os::raw::c_int,
        extent: hipExtent,
        stream: hipStream_t,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Query memory info.\n\n On ROCM, this function gets the actual free memory left on the current device, so supports\n the cases while running multi-workload (such as multiple processes, multiple threads, and\n multiple GPUs).\n\n @warning On Windows, the free memory only accounts for memory allocated by this process and may\n be optimistic.\n\n @param[out] free Returns free memory on the current device in bytes\n @param[out] total Returns total allocatable memory on the current device in bytes\n\n @return #hipSuccess, #hipErrorInvalidDevice, #hipErrorInvalidValue\n"]
    pub fn hipMemGetInfo(free: *mut usize, total: *mut usize) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Get allocated memory size via memory pointer.\n\n This function gets the allocated shared virtual memory size from memory pointer.\n\n @param[in] ptr Pointer to allocated memory\n @param[out] size Returns the allocated memory size in bytes\n\n @return #hipSuccess, #hipErrorInvalidValue\n"]
    pub fn hipMemPtrGetInfo(ptr: *mut ::std::os::raw::c_void, size: *mut usize) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Allocate an array on the device.\n\n  @param[out]  array  Pointer to allocated array in device memory\n  @param[in]   desc   Requested channel format\n  @param[in]   width  Requested array allocation width\n  @param[in]   height Requested array allocation height\n  @param[in]   flags  Requested properties of allocated array\n  @return      #hipSuccess, #hipErrorOutOfMemory\n\n  @see hipMalloc, hipMallocPitch, hipFree, hipFreeArray, hipHostMalloc, hipHostFree"]
    pub fn hipMallocArray(
        array: *mut hipArray_t,
        desc: *const hipChannelFormatDesc,
        width: usize,
        height: usize,
        flags: ::std::os::raw::c_uint,
    ) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Create an array memory pointer on the device.\n\n  @param[out]  pHandle  Pointer to the array memory\n  @param[in]   pAllocateArray   Requested array desciptor\n\n  @return      #hipSuccess, #hipErrorInvalidValue, #hipErrorNotSupported\n\n  @see hipMallocArray, hipArrayDestroy, hipFreeArray"]
    pub fn hipArrayCreate(
        pHandle: *mut hipArray_t,
        pAllocateArray: *const HIP_ARRAY_DESCRIPTOR,
    ) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Destroy an array memory pointer on the device.\n\n  @param[in]  array  Pointer to the array memory\n\n  @return      #hipSuccess, #hipErrorInvalidValue\n\n  @see hipArrayCreate, hipArrayDestroy, hipFreeArray"]
    pub fn hipArrayDestroy(array: hipArray_t) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Create a 3D array memory pointer on the device.\n\n  @param[out]  array  Pointer to the 3D array memory\n  @param[in]   pAllocateArray   Requested array desciptor\n\n  @return      #hipSuccess, #hipErrorInvalidValue, #hipErrorNotSupported\n\n  @see hipMallocArray, hipArrayDestroy, hipFreeArray"]
    pub fn hipArray3DCreate(
        array: *mut hipArray_t,
        pAllocateArray: *const HIP_ARRAY3D_DESCRIPTOR,
    ) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Create a 3D memory pointer on the device.\n\n  @param[out]  pitchedDevPtr  Pointer to the 3D memory\n  @param[in]   extent   Requested extent\n\n  @return      #hipSuccess, #hipErrorInvalidValue, #hipErrorNotSupported\n\n  @see hipMallocPitch, hipMemGetInfo, hipFree"]
    pub fn hipMalloc3D(pitchedDevPtr: *mut hipPitchedPtr, extent: hipExtent) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Frees an array on the device.\n\n  @param[in]  array  Pointer to array to free\n  @return     #hipSuccess, #hipErrorInvalidValue, #hipErrorNotInitialized\n\n  @see hipMalloc, hipMallocPitch, hipFree, hipMallocArray, hipHostMalloc, hipHostFree"]
    pub fn hipFreeArray(array: hipArray_t) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Allocate an array on the device.\n\n  @param[out]  array  Pointer to allocated array in device memory\n  @param[in]   desc   Requested channel format\n  @param[in]   extent Requested array allocation width, height and depth\n  @param[in]   flags  Requested properties of allocated array\n  @return      #hipSuccess, #hipErrorOutOfMemory\n\n  @see hipMalloc, hipMallocPitch, hipFree, hipFreeArray, hipHostMalloc, hipHostFree"]
    pub fn hipMalloc3DArray(
        array: *mut hipArray_t,
        desc: *const hipChannelFormatDesc,
        extent: hipExtent,
        flags: ::std::os::raw::c_uint,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Gets info about the specified array\n\n @param[out] desc   - Returned array type\n @param[out] extent - Returned array shape. 2D arrays will have depth of zero\n @param[out] flags  - Returned array flags\n @param[in]  array  - The HIP array to get info for\n\n @return #hipSuccess, #hipErrorInvalidValue #hipErrorInvalidHandle\n\n @see hipArrayGetDescriptor, hipArray3DGetDescriptor"]
    pub fn hipArrayGetInfo(
        desc: *mut hipChannelFormatDesc,
        extent: *mut hipExtent,
        flags: *mut ::std::os::raw::c_uint,
        array: hipArray_t,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Gets a 1D or 2D array descriptor\n\n @param[out] pArrayDescriptor - Returned array descriptor\n @param[in]  array            - Array to get descriptor of\n\n @return #hipSuccess, #hipErrorDeInitialized, #hipErrorNotInitialized, #hipErrorInvalidContext,\n #hipErrorInvalidValue #hipErrorInvalidHandle\n\n @see hipArray3DCreate, hipArray3DGetDescriptor, hipArrayCreate, hipArrayDestroy, hipMemAlloc,\n hipMemAllocHost, hipMemAllocPitch, hipMemcpy2D, hipMemcpy2DAsync, hipMemcpy2DUnaligned,\n hipMemcpy3D, hipMemcpy3DAsync, hipMemcpyAtoA, hipMemcpyAtoD, hipMemcpyAtoH, hipMemcpyAtoHAsync,\n hipMemcpyDtoA, hipMemcpyDtoD, hipMemcpyDtoDAsync, hipMemcpyDtoH, hipMemcpyDtoHAsync,\n hipMemcpyHtoA, hipMemcpyHtoAAsync, hipMemcpyHtoD, hipMemcpyHtoDAsync, hipMemFree,\n hipMemFreeHost, hipMemGetAddressRange, hipMemGetInfo, hipMemHostAlloc,\n hipMemHostGetDevicePointer, hipMemsetD8, hipMemsetD16, hipMemsetD32, hipArrayGetInfo"]
    pub fn hipArrayGetDescriptor(
        pArrayDescriptor: *mut HIP_ARRAY_DESCRIPTOR,
        array: hipArray_t,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Gets a 3D array descriptor\n\n @param[out] pArrayDescriptor - Returned 3D array descriptor\n @param[in]  array            - 3D array to get descriptor of\n\n @return #hipSuccess, #hipErrorDeInitialized, #hipErrorNotInitialized, #hipErrorInvalidContext,\n #hipErrorInvalidValue #hipErrorInvalidHandle, #hipErrorContextIsDestroyed\n\n @see hipArray3DCreate, hipArrayCreate, hipArrayDestroy, hipArrayGetDescriptor, hipMemAlloc,\n hipMemAllocHost, hipMemAllocPitch, hipMemcpy2D, hipMemcpy2DAsync, hipMemcpy2DUnaligned,\n hipMemcpy3D, hipMemcpy3DAsync, hipMemcpyAtoA, hipMemcpyAtoD, hipMemcpyAtoH, hipMemcpyAtoHAsync,\n hipMemcpyDtoA, hipMemcpyDtoD, hipMemcpyDtoDAsync, hipMemcpyDtoH, hipMemcpyDtoHAsync,\n hipMemcpyHtoA, hipMemcpyHtoAAsync, hipMemcpyHtoD, hipMemcpyHtoDAsync, hipMemFree,\n hipMemFreeHost, hipMemGetAddressRange, hipMemGetInfo, hipMemHostAlloc,\n hipMemHostGetDevicePointer, hipMemsetD8, hipMemsetD16, hipMemsetD32, hipArrayGetInfo"]
    pub fn hipArray3DGetDescriptor(
        pArrayDescriptor: *mut HIP_ARRAY3D_DESCRIPTOR,
        array: hipArray_t,
    ) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Copies data between host and device.\n\n  @param[in]   dst    Destination memory address\n  @param[in]   dpitch Pitch of destination memory\n  @param[in]   src    Source memory address\n  @param[in]   spitch Pitch of source memory\n  @param[in]   width  Width of matrix transfer (columns in bytes)\n  @param[in]   height Height of matrix transfer (rows)\n  @param[in]   kind   Type of transfer\n  @return      #hipSuccess, #hipErrorInvalidValue, #hipErrorInvalidPitchValue,\n #hipErrorInvalidDevicePointer, #hipErrorInvalidMemcpyDirection\n\n  @see hipMemcpy, hipMemcpyToArray, hipMemcpy2DToArray, hipMemcpyFromArray, hipMemcpyToSymbol,\n hipMemcpyAsync"]
    pub fn hipMemcpy2D(
        dst: *mut ::std::os::raw::c_void,
        dpitch: usize,
        src: *const ::std::os::raw::c_void,
        spitch: usize,
        width: usize,
        height: usize,
        kind: hipMemcpyKind,
    ) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Copies memory for 2D arrays.\n  @param[in]   pCopy Parameters for the memory copy\n  @return      #hipSuccess, #hipErrorInvalidValue, #hipErrorInvalidPitchValue,\n  #hipErrorInvalidDevicePointer, #hipErrorInvalidMemcpyDirection\n\n  @see hipMemcpy, hipMemcpy2D, hipMemcpyToArray, hipMemcpy2DToArray, hipMemcpyFromArray,\n hipMemcpyToSymbol, hipMemcpyAsync"]
    pub fn hipMemcpyParam2D(pCopy: *const hip_Memcpy2D) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Copies memory for 2D arrays.\n  @param[in]   pCopy Parameters for the memory copy\n  @param[in]   stream Stream to use\n  @return      #hipSuccess, #hipErrorInvalidValue, #hipErrorInvalidPitchValue,\n #hipErrorInvalidDevicePointer, #hipErrorInvalidMemcpyDirection\n\n  @see hipMemcpy, hipMemcpy2D, hipMemcpyToArray, hipMemcpy2DToArray, hipMemcpyFromArray,\n hipMemcpyToSymbol, hipMemcpyAsync"]
    pub fn hipMemcpyParam2DAsync(pCopy: *const hip_Memcpy2D, stream: hipStream_t) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Copies data between host and device.\n\n  @param[in]   dst    Destination memory address\n  @param[in]   dpitch Pitch of destination memory\n  @param[in]   src    Source memory address\n  @param[in]   spitch Pitch of source memory\n  @param[in]   width  Width of matrix transfer (columns in bytes)\n  @param[in]   height Height of matrix transfer (rows)\n  @param[in]   kind   Type of transfer\n  @param[in]   stream Stream to use\n  @return      #hipSuccess, #hipErrorInvalidValue, #hipErrorInvalidPitchValue,\n #hipErrorInvalidDevicePointer, #hipErrorInvalidMemcpyDirection\n\n  @see hipMemcpy, hipMemcpyToArray, hipMemcpy2DToArray, hipMemcpyFromArray, hipMemcpyToSymbol,\n hipMemcpyAsync"]
    pub fn hipMemcpy2DAsync(
        dst: *mut ::std::os::raw::c_void,
        dpitch: usize,
        src: *const ::std::os::raw::c_void,
        spitch: usize,
        width: usize,
        height: usize,
        kind: hipMemcpyKind,
        stream: hipStream_t,
    ) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Copies data between host and device.\n\n  @param[in]   dst     Destination memory address\n  @param[in]   wOffset Destination starting X offset\n  @param[in]   hOffset Destination starting Y offset\n  @param[in]   src     Source memory address\n  @param[in]   spitch  Pitch of source memory\n  @param[in]   width   Width of matrix transfer (columns in bytes)\n  @param[in]   height  Height of matrix transfer (rows)\n  @param[in]   kind    Type of transfer\n  @return      #hipSuccess, #hipErrorInvalidValue, #hipErrorInvalidPitchValue,\n #hipErrorInvalidDevicePointer, #hipErrorInvalidMemcpyDirection\n\n  @see hipMemcpy, hipMemcpyToArray, hipMemcpy2D, hipMemcpyFromArray, hipMemcpyToSymbol,\n hipMemcpyAsync"]
    pub fn hipMemcpy2DToArray(
        dst: hipArray_t,
        wOffset: usize,
        hOffset: usize,
        src: *const ::std::os::raw::c_void,
        spitch: usize,
        width: usize,
        height: usize,
        kind: hipMemcpyKind,
    ) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Copies data between host and device.\n\n  @param[in]   dst     Destination memory address\n  @param[in]   wOffset Destination starting X offset\n  @param[in]   hOffset Destination starting Y offset\n  @param[in]   src     Source memory address\n  @param[in]   spitch  Pitch of source memory\n  @param[in]   width   Width of matrix transfer (columns in bytes)\n  @param[in]   height  Height of matrix transfer (rows)\n  @param[in]   kind    Type of transfer\n  @param[in]   stream    Accelerator view which the copy is being enqueued\n  @return      #hipSuccess, #hipErrorInvalidValue, #hipErrorInvalidPitchValue,\n #hipErrorInvalidDevicePointer, #hipErrorInvalidMemcpyDirection\n\n  @see hipMemcpy, hipMemcpyToArray, hipMemcpy2D, hipMemcpyFromArray, hipMemcpyToSymbol,\n hipMemcpyAsync"]
    pub fn hipMemcpy2DToArrayAsync(
        dst: hipArray_t,
        wOffset: usize,
        hOffset: usize,
        src: *const ::std::os::raw::c_void,
        spitch: usize,
        width: usize,
        height: usize,
        kind: hipMemcpyKind,
        stream: hipStream_t,
    ) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Copies data between host and device.\n\n  @param[in]   dst     Destination memory address\n  @param[in]   wOffset Destination starting X offset\n  @param[in]   hOffset Destination starting Y offset\n  @param[in]   src     Source memory address\n  @param[in]   count   size in bytes to copy\n  @param[in]   kind    Type of transfer\n  @return      #hipSuccess, #hipErrorInvalidValue, #hipErrorInvalidPitchValue,\n #hipErrorInvalidDevicePointer, #hipErrorInvalidMemcpyDirection\n\n  @see hipMemcpy, hipMemcpy2DToArray, hipMemcpy2D, hipMemcpyFromArray, hipMemcpyToSymbol,\n  hipMemcpyAsync\n  @warning  This API is deprecated."]
    pub fn hipMemcpyToArray(
        dst: hipArray_t,
        wOffset: usize,
        hOffset: usize,
        src: *const ::std::os::raw::c_void,
        count: usize,
        kind: hipMemcpyKind,
    ) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Copies data between host and device.\n\n  @param[in]   dst       Destination memory address\n  @param[in]   srcArray  Source memory address\n  @param[in]   wOffset   Source starting X offset\n  @param[in]   hOffset   Source starting Y offset\n  @param[in]   count     Size in bytes to copy\n  @param[in]   kind      Type of transfer\n  @return      #hipSuccess, #hipErrorInvalidValue, #hipErrorInvalidPitchValue,\n #hipErrorInvalidDevicePointer, #hipErrorInvalidMemcpyDirection\n\n  @see hipMemcpy, hipMemcpy2DToArray, hipMemcpy2D, hipMemcpyFromArray, hipMemcpyToSymbol,\n hipMemcpyAsync\n @warning  This API is deprecated."]
    pub fn hipMemcpyFromArray(
        dst: *mut ::std::os::raw::c_void,
        srcArray: hipArray_const_t,
        wOffset: usize,
        hOffset: usize,
        count: usize,
        kind: hipMemcpyKind,
    ) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Copies data between host and device.\n\n  @param[in]   dst       Destination memory address\n  @param[in]   dpitch    Pitch of destination memory\n  @param[in]   src       Source memory address\n  @param[in]   wOffset   Source starting X offset\n  @param[in]   hOffset   Source starting Y offset\n  @param[in]   width     Width of matrix transfer (columns in bytes)\n  @param[in]   height    Height of matrix transfer (rows)\n  @param[in]   kind      Type of transfer\n  @return      #hipSuccess, #hipErrorInvalidValue, #hipErrorInvalidPitchValue,\n #hipErrorInvalidDevicePointer, #hipErrorInvalidMemcpyDirection\n\n  @see hipMemcpy, hipMemcpy2DToArray, hipMemcpy2D, hipMemcpyFromArray, hipMemcpyToSymbol,\n hipMemcpyAsync"]
    pub fn hipMemcpy2DFromArray(
        dst: *mut ::std::os::raw::c_void,
        dpitch: usize,
        src: hipArray_const_t,
        wOffset: usize,
        hOffset: usize,
        width: usize,
        height: usize,
        kind: hipMemcpyKind,
    ) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Copies data between host and device asynchronously.\n\n  @param[in]   dst       Destination memory address\n  @param[in]   dpitch    Pitch of destination memory\n  @param[in]   src       Source memory address\n  @param[in]   wOffset   Source starting X offset\n  @param[in]   hOffset   Source starting Y offset\n  @param[in]   width     Width of matrix transfer (columns in bytes)\n  @param[in]   height    Height of matrix transfer (rows)\n  @param[in]   kind      Type of transfer\n  @param[in]   stream    Accelerator view which the copy is being enqueued\n  @return      #hipSuccess, #hipErrorInvalidValue, #hipErrorInvalidPitchValue,\n #hipErrorInvalidDevicePointer, #hipErrorInvalidMemcpyDirection\n\n  @see hipMemcpy, hipMemcpy2DToArray, hipMemcpy2D, hipMemcpyFromArray, hipMemcpyToSymbol,\n hipMemcpyAsync"]
    pub fn hipMemcpy2DFromArrayAsync(
        dst: *mut ::std::os::raw::c_void,
        dpitch: usize,
        src: hipArray_const_t,
        wOffset: usize,
        hOffset: usize,
        width: usize,
        height: usize,
        kind: hipMemcpyKind,
        stream: hipStream_t,
    ) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Copies data between host and device.\n\n  @param[in]   dst       Destination memory address\n  @param[in]   srcArray  Source array\n  @param[in]   srcoffset Offset in bytes of source array\n  @param[in]   count     Size of memory copy in bytes\n  @return      #hipSuccess, #hipErrorInvalidValue, #hipErrorInvalidPitchValue,\n #hipErrorInvalidDevicePointer, #hipErrorInvalidMemcpyDirection\n\n  @see hipMemcpy, hipMemcpy2DToArray, hipMemcpy2D, hipMemcpyFromArray, hipMemcpyToSymbol,\n hipMemcpyAsync"]
    pub fn hipMemcpyAtoH(
        dst: *mut ::std::os::raw::c_void,
        srcArray: hipArray_t,
        srcOffset: usize,
        count: usize,
    ) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Copies data between host and device.\n\n  @param[in]   dstArray   Destination memory address\n  @param[in]   dstOffset  Offset in bytes of destination array\n  @param[in]   srcHost    Source host pointer\n  @param[in]   count      Size of memory copy in bytes\n  @return      #hipSuccess, #hipErrorInvalidValue, #hipErrorInvalidPitchValue,\n #hipErrorInvalidDevicePointer, #hipErrorInvalidMemcpyDirection\n\n  @see hipMemcpy, hipMemcpy2DToArray, hipMemcpy2D, hipMemcpyFromArray, hipMemcpyToSymbol,\n hipMemcpyAsync"]
    pub fn hipMemcpyHtoA(
        dstArray: hipArray_t,
        dstOffset: usize,
        srcHost: *const ::std::os::raw::c_void,
        count: usize,
    ) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Copies data between host and device.\n\n  @param[in]   p   3D memory copy parameters\n  @return      #hipSuccess, #hipErrorInvalidValue, #hipErrorInvalidPitchValue,\n #hipErrorInvalidDevicePointer, #hipErrorInvalidMemcpyDirection\n\n  @see hipMemcpy, hipMemcpy2DToArray, hipMemcpy2D, hipMemcpyFromArray, hipMemcpyToSymbol,\n hipMemcpyAsync"]
    pub fn hipMemcpy3D(p: *const hipMemcpy3DParms) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Copies data between host and device asynchronously.\n\n  @param[in]   p        3D memory copy parameters\n  @param[in]   stream   Stream to use\n  @return      #hipSuccess, #hipErrorInvalidValue, #hipErrorInvalidPitchValue,\n #hipErrorInvalidDevicePointer, #hipErrorInvalidMemcpyDirection\n\n  @see hipMemcpy, hipMemcpy2DToArray, hipMemcpy2D, hipMemcpyFromArray, hipMemcpyToSymbol,\n hipMemcpyAsync"]
    pub fn hipMemcpy3DAsync(p: *const hipMemcpy3DParms, stream: hipStream_t) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Copies data between host and device.\n\n  @param[in]   pCopy   3D memory copy parameters\n  @return      #hipSuccess, #hipErrorInvalidValue, #hipErrorInvalidPitchValue,\n  #hipErrorInvalidDevicePointer, #hipErrorInvalidMemcpyDirection\n\n  @see hipMemcpy, hipMemcpy2DToArray, hipMemcpy2D, hipMemcpyFromArray, hipMemcpyToSymbol,\n hipMemcpyAsync"]
    pub fn hipDrvMemcpy3D(pCopy: *const HIP_MEMCPY3D) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Copies data between host and device asynchronously.\n\n  @param[in]   pCopy    3D memory copy parameters\n  @param[in]   stream   Stream to use\n  @return      #hipSuccess, #hipErrorInvalidValue, #hipErrorInvalidPitchValue,\n  #hipErrorInvalidDevicePointer, #hipErrorInvalidMemcpyDirection\n\n  @see hipMemcpy, hipMemcpy2DToArray, hipMemcpy2D, hipMemcpyFromArray, hipMemcpyToSymbol,\n hipMemcpyAsync"]
    pub fn hipDrvMemcpy3DAsync(pCopy: *const HIP_MEMCPY3D, stream: hipStream_t) -> hipError_t;
}
extern "C" {
    #[doc = " @}\n/\n/**\n-------------------------------------------------------------------------------------------------\n-------------------------------------------------------------------------------------------------\n  @defgroup PeerToPeer PeerToPeer Device Memory Access\n  @{\n  @warning PeerToPeer support is experimental.\n  This section describes the PeerToPeer device memory access functions of HIP runtime API.\n/\n/**\n @brief Determine if a device can access a peer's memory.\n\n @param [out] canAccessPeer Returns the peer access capability (0 or 1)\n @param [in] deviceId - device from where memory may be accessed.\n @param [in] peerDeviceId - device where memory is physically located\n\n Returns \"1\" in @p canAccessPeer if the specified @p device is capable\n of directly accessing memory physically located on peerDevice , or \"0\" if not.\n\n Returns \"0\" in @p canAccessPeer if deviceId == peerDeviceId, and both are valid devices : a\n device is not a peer of itself.\n\n @returns #hipSuccess,\n @returns #hipErrorInvalidDevice if deviceId or peerDeviceId are not valid devices"]
    pub fn hipDeviceCanAccessPeer(
        canAccessPeer: *mut ::std::os::raw::c_int,
        deviceId: ::std::os::raw::c_int,
        peerDeviceId: ::std::os::raw::c_int,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Enable direct access from current device's virtual address space to memory allocations\n physically located on a peer device.\n\n Memory which already allocated on peer device will be mapped into the address space of the\n current device.  In addition, all future memory allocations on peerDeviceId will be mapped into\n the address space of the current device when the memory is allocated. The peer memory remains\n accessible from the current device until a call to hipDeviceDisablePeerAccess or hipDeviceReset.\n\n\n @param [in] peerDeviceId  Peer device to enable direct access to from the current device\n @param [in] flags  Reserved for future use, must be zero\n\n Returns #hipSuccess, #hipErrorInvalidDevice, #hipErrorInvalidValue,\n @returns #hipErrorPeerAccessAlreadyEnabled if peer access is already enabled for this device."]
    pub fn hipDeviceEnablePeerAccess(
        peerDeviceId: ::std::os::raw::c_int,
        flags: ::std::os::raw::c_uint,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Disable direct access from current device's virtual address space to memory allocations\n physically located on a peer device.\n\n Returns hipErrorPeerAccessNotEnabled if direct access to memory on peerDevice has not yet been\n enabled from the current device.\n\n @param [in] peerDeviceId  Peer device to disable direct access to\n\n @returns #hipSuccess, #hipErrorPeerAccessNotEnabled"]
    pub fn hipDeviceDisablePeerAccess(peerDeviceId: ::std::os::raw::c_int) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Get information on memory allocations.\n\n @param [out] pbase - BAse pointer address\n @param [out] psize - Size of allocation\n @param [in]  dptr- Device Pointer\n\n @returns #hipSuccess, #hipErrorInvalidDevicePointer\n\n @see hipCtxCreate, hipCtxDestroy, hipCtxGetFlags, hipCtxPopCurrent, hipCtxGetCurrent,\n hipCtxSetCurrent, hipCtxPushCurrent, hipCtxSetCacheConfig, hipCtxSynchronize, hipCtxGetDevice"]
    pub fn hipMemGetAddressRange(
        pbase: *mut hipDeviceptr_t,
        psize: *mut usize,
        dptr: hipDeviceptr_t,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Copies memory from one device to memory on another device.\n\n @param [out] dst - Destination device pointer.\n @param [in] dstDeviceId - Destination device\n @param [in] src - Source device pointer\n @param [in] srcDeviceId - Source device\n @param [in] sizeBytes - Size of memory copy in bytes\n\n @returns #hipSuccess, #hipErrorInvalidValue, #hipErrorInvalidDevice"]
    pub fn hipMemcpyPeer(
        dst: *mut ::std::os::raw::c_void,
        dstDeviceId: ::std::os::raw::c_int,
        src: *const ::std::os::raw::c_void,
        srcDeviceId: ::std::os::raw::c_int,
        sizeBytes: usize,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Copies memory from one device to memory on another device.\n\n @param [out] dst - Destination device pointer.\n @param [in] dstDeviceId - Destination device\n @param [in] src - Source device pointer\n @param [in] srcDevice - Source device\n @param [in] sizeBytes - Size of memory copy in bytes\n @param [in] stream - Stream identifier\n\n @returns #hipSuccess, #hipErrorInvalidValue, #hipErrorInvalidDevice"]
    pub fn hipMemcpyPeerAsync(
        dst: *mut ::std::os::raw::c_void,
        dstDeviceId: ::std::os::raw::c_int,
        src: *const ::std::os::raw::c_void,
        srcDevice: ::std::os::raw::c_int,
        sizeBytes: usize,
        stream: hipStream_t,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @}\n/\n/**\n-------------------------------------------------------------------------------------------------\n-------------------------------------------------------------------------------------------------\n  @defgroup Context Context Management\n  @{\n  This section describes the context management functions of HIP runtime API.\n/\n/**\n\n  @addtogroup ContextD Context Management [Deprecated]\n  @{\n  @ingroup Context\n  This section describes the deprecated context management functions of HIP runtime API.\n/\n/**\n @brief Create a context and set it as current/default context\n\n @param [out] ctx  Context to create\n @param [in] flags  Context creation flags\n @param [in] device  device handle\n\n @return #hipSuccess\n\n @see hipCtxDestroy, hipCtxGetFlags, hipCtxPopCurrent, hipCtxGetCurrent, hipCtxPushCurrent,\n hipCtxSetCacheConfig, hipCtxSynchronize, hipCtxGetDevice\n\n @warning : This HIP API is deprecated."]
    pub fn hipCtxCreate(
        ctx: *mut hipCtx_t,
        flags: ::std::os::raw::c_uint,
        device: hipDevice_t,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Destroy a HIP context.\n\n @param [in] ctx Context to destroy\n\n @returns #hipSuccess, #hipErrorInvalidValue\n\n @see hipCtxCreate, hipCtxGetFlags, hipCtxPopCurrent, hipCtxGetCurrent,hipCtxSetCurrent,\n hipCtxPushCurrent, hipCtxSetCacheConfig, hipCtxSynchronize , hipCtxGetDevice\n\n @warning : This HIP API is deprecated."]
    pub fn hipCtxDestroy(ctx: hipCtx_t) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Pop the current/default context and return the popped context.\n\n @param [out] ctx  The current context to pop\n\n @returns #hipSuccess, #hipErrorInvalidContext\n\n @see hipCtxCreate, hipCtxDestroy, hipCtxGetFlags, hipCtxSetCurrent, hipCtxGetCurrent,\n hipCtxPushCurrent, hipCtxSetCacheConfig, hipCtxSynchronize, hipCtxGetDevice\n\n @warning : This HIP API is deprecated."]
    pub fn hipCtxPopCurrent(ctx: *mut hipCtx_t) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Push the context to be set as current/ default context\n\n @param [in] ctx  The current context to push\n\n @returns #hipSuccess, #hipErrorInvalidContext\n\n @see hipCtxCreate, hipCtxDestroy, hipCtxGetFlags, hipCtxPopCurrent, hipCtxGetCurrent,\n hipCtxPushCurrent, hipCtxSetCacheConfig, hipCtxSynchronize , hipCtxGetDevice\n\n @warning : This HIP API is deprecated."]
    pub fn hipCtxPushCurrent(ctx: hipCtx_t) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Set the passed context as current/default\n\n @param [in] ctx The context to set as current\n\n @returns #hipSuccess, #hipErrorInvalidContext\n\n @see hipCtxCreate, hipCtxDestroy, hipCtxGetFlags, hipCtxPopCurrent, hipCtxGetCurrent,\n hipCtxPushCurrent, hipCtxSetCacheConfig, hipCtxSynchronize , hipCtxGetDevice\n\n @warning : This HIP API is deprecated."]
    pub fn hipCtxSetCurrent(ctx: hipCtx_t) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Get the handle of the current/ default context\n\n @param [out] ctx  The context to get as current\n\n @returns #hipSuccess, #hipErrorInvalidContext\n\n @see hipCtxCreate, hipCtxDestroy, hipCtxGetDevice, hipCtxGetFlags, hipCtxPopCurrent,\n hipCtxPushCurrent, hipCtxSetCacheConfig, hipCtxSynchronize, hipCtxGetDevice\n\n @warning : This HIP API is deprecated."]
    pub fn hipCtxGetCurrent(ctx: *mut hipCtx_t) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Get the handle of the device associated with current/default context\n\n @param [out] device The device from the current context\n\n @returns #hipSuccess, #hipErrorInvalidContext\n\n @see hipCtxCreate, hipCtxDestroy, hipCtxGetFlags, hipCtxPopCurrent, hipCtxGetCurrent,\n hipCtxPushCurrent, hipCtxSetCacheConfig, hipCtxSynchronize\n\n @warning : This HIP API is deprecated."]
    pub fn hipCtxGetDevice(device: *mut hipDevice_t) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Returns the approximate HIP api version.\n\n @param [in]  ctx Context to check\n @param [out] apiVersion API version to get\n\n @return #hipSuccess\n\n @warning The HIP feature set does not correspond to an exact CUDA SDK api revision.\n This function always set *apiVersion to 4 as an approximation though HIP supports\n some features which were introduced in later CUDA SDK revisions.\n HIP apps code should not rely on the api revision number here and should\n use arch feature flags to test device capabilities or conditional compilation.\n\n @see hipCtxCreate, hipCtxDestroy, hipCtxGetDevice, hipCtxGetFlags, hipCtxPopCurrent,\n hipCtxPushCurrent, hipCtxSetCacheConfig, hipCtxSynchronize, hipCtxGetDevice\n\n @warning : This HIP API is deprecated."]
    pub fn hipCtxGetApiVersion(ctx: hipCtx_t, apiVersion: *mut ::std::os::raw::c_int)
        -> hipError_t;
}
extern "C" {
    #[doc = " @brief Get Cache configuration for a specific function\n\n @param [out] cacheConfig  Cache configuration\n\n @return #hipSuccess\n\n @warning AMD devices and some Nvidia GPUS do not support reconfigurable cache.  This hint is\n ignored on those architectures.\n\n @see hipCtxCreate, hipCtxDestroy, hipCtxGetFlags, hipCtxPopCurrent, hipCtxGetCurrent,\n hipCtxSetCurrent, hipCtxPushCurrent, hipCtxSetCacheConfig, hipCtxSynchronize, hipCtxGetDevice\n\n @warning : This HIP API is deprecated."]
    pub fn hipCtxGetCacheConfig(cacheConfig: *mut hipFuncCache_t) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Set L1/Shared cache partition.\n\n @param [in] cacheConfig  Cache configuration to set\n\n @return #hipSuccess\n\n @warning AMD devices and some Nvidia GPUS do not support reconfigurable cache.  This hint is\n ignored on those architectures.\n\n @see hipCtxCreate, hipCtxDestroy, hipCtxGetFlags, hipCtxPopCurrent, hipCtxGetCurrent,\n hipCtxSetCurrent, hipCtxPushCurrent, hipCtxSetCacheConfig, hipCtxSynchronize, hipCtxGetDevice\n\n @warning : This HIP API is deprecated."]
    pub fn hipCtxSetCacheConfig(cacheConfig: hipFuncCache_t) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Set Shared memory bank configuration.\n\n @param [in] config  Shared memory configuration to set\n\n @return #hipSuccess\n\n @warning AMD devices and some Nvidia GPUS do not support shared cache banking, and the hint is\n ignored on those architectures.\n\n @see hipCtxCreate, hipCtxDestroy, hipCtxGetFlags, hipCtxPopCurrent, hipCtxGetCurrent,\n hipCtxSetCurrent, hipCtxPushCurrent, hipCtxSetCacheConfig, hipCtxSynchronize, hipCtxGetDevice\n\n @warning : This HIP API is deprecated."]
    pub fn hipCtxSetSharedMemConfig(config: hipSharedMemConfig) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Get Shared memory bank configuration.\n\n @param [out] pConfig  Pointer of shared memory configuration\n\n @return #hipSuccess\n\n @warning AMD devices and some Nvidia GPUS do not support shared cache banking, and the hint is\n ignored on those architectures.\n\n @see hipCtxCreate, hipCtxDestroy, hipCtxGetFlags, hipCtxPopCurrent, hipCtxGetCurrent,\n hipCtxSetCurrent, hipCtxPushCurrent, hipCtxSetCacheConfig, hipCtxSynchronize, hipCtxGetDevice\n\n @warning : This HIP API is deprecated."]
    pub fn hipCtxGetSharedMemConfig(pConfig: *mut hipSharedMemConfig) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Blocks until the default context has completed all preceding requested tasks.\n\n @return #hipSuccess\n\n @warning This function waits for all streams on the default context to complete execution, and\n then returns.\n\n @see hipCtxCreate, hipCtxDestroy, hipCtxGetFlags, hipCtxPopCurrent, hipCtxGetCurrent,\n hipCtxSetCurrent, hipCtxPushCurrent, hipCtxSetCacheConfig, hipCtxGetDevice\n\n @warning : This HIP API is deprecated."]
    pub fn hipCtxSynchronize() -> hipError_t;
}
extern "C" {
    #[doc = " @brief Return flags used for creating default context.\n\n @param [out] flags  Pointer of flags\n\n @returns #hipSuccess\n\n @see hipCtxCreate, hipCtxDestroy, hipCtxPopCurrent, hipCtxGetCurrent, hipCtxGetCurrent,\n hipCtxSetCurrent, hipCtxPushCurrent, hipCtxSetCacheConfig, hipCtxSynchronize, hipCtxGetDevice\n\n @warning : This HIP API is deprecated."]
    pub fn hipCtxGetFlags(flags: *mut ::std::os::raw::c_uint) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Enables direct access to memory allocations in a peer context.\n\n Memory which already allocated on peer device will be mapped into the address space of the\n current device.  In addition, all future memory allocations on peerDeviceId will be mapped into\n the address space of the current device when the memory is allocated. The peer memory remains\n accessible from the current device until a call to hipDeviceDisablePeerAccess or hipDeviceReset.\n\n\n @param [in] peerCtx  Peer context\n @param [in] flags  flags, need to set as 0\n\n @returns #hipSuccess, #hipErrorInvalidDevice, #hipErrorInvalidValue,\n #hipErrorPeerAccessAlreadyEnabled\n\n @see hipCtxCreate, hipCtxDestroy, hipCtxGetFlags, hipCtxPopCurrent, hipCtxGetCurrent,\n hipCtxSetCurrent, hipCtxPushCurrent, hipCtxSetCacheConfig, hipCtxSynchronize, hipCtxGetDevice\n @warning PeerToPeer support is experimental.\n\n @warning : This HIP API is deprecated."]
    pub fn hipCtxEnablePeerAccess(peerCtx: hipCtx_t, flags: ::std::os::raw::c_uint) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Disable direct access from current context's virtual address space to memory allocations\n physically located on a peer context.Disables direct access to memory allocations in a peer\n context and unregisters any registered allocations.\n\n Returns #hipErrorPeerAccessNotEnabled if direct access to memory on peerDevice has not yet been\n enabled from the current device.\n\n @param [in] peerCtx  Peer context to be disabled\n\n @returns #hipSuccess, #hipErrorPeerAccessNotEnabled\n\n @see hipCtxCreate, hipCtxDestroy, hipCtxGetFlags, hipCtxPopCurrent, hipCtxGetCurrent,\n hipCtxSetCurrent, hipCtxPushCurrent, hipCtxSetCacheConfig, hipCtxSynchronize, hipCtxGetDevice\n @warning PeerToPeer support is experimental.\n\n @warning : This HIP API is deprecated."]
    pub fn hipCtxDisablePeerAccess(peerCtx: hipCtx_t) -> hipError_t;
}
extern "C" {
    #[doc = " @}\n/\n/**\n @brief Get the state of the primary context.\n\n @param [in] dev  Device to get primary context flags for\n @param [out] flags  Pointer to store flags\n @param [out] active  Pointer to store context state; 0 = inactive, 1 = active\n\n @returns #hipSuccess\n\n @see hipCtxCreate, hipCtxDestroy, hipCtxGetFlags, hipCtxPopCurrent, hipCtxGetCurrent,\n hipCtxSetCurrent, hipCtxPushCurrent, hipCtxSetCacheConfig, hipCtxSynchronize, hipCtxGetDevice"]
    pub fn hipDevicePrimaryCtxGetState(
        dev: hipDevice_t,
        flags: *mut ::std::os::raw::c_uint,
        active: *mut ::std::os::raw::c_int,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Release the primary context on the GPU.\n\n @param [in] dev  Device which primary context is released\n\n @returns #hipSuccess\n\n @see hipCtxCreate, hipCtxDestroy, hipCtxGetFlags, hipCtxPopCurrent, hipCtxGetCurrent,\n hipCtxSetCurrent, hipCtxPushCurrent, hipCtxSetCacheConfig, hipCtxSynchronize, hipCtxGetDevice\n @warning This function return #hipSuccess though doesn't release the primaryCtx by design on\n HIP/HCC path."]
    pub fn hipDevicePrimaryCtxRelease(dev: hipDevice_t) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Retain the primary context on the GPU.\n\nhipError_t hipDevicePrimaryCtxRetain(hipCtx_t* pctx, hipDevice_t dev);\n @param [out] pctx  Returned context handle of the new context\n @param [in] dev  Device which primary context is released\n\n @returns #hipSuccess\n\n @see hipCtxCreate, hipCtxDestroy, hipCtxGetFlags, hipCtxPopCurrent, hipCtxGetCurrent,\n hipCtxSetCurrent, hipCtxPushCurrent, hipCtxSetCacheConfig, hipCtxSynchronize, hipCtxGetDevice"]
    pub fn hipDevicePrimaryCtxRetain(pctx: *mut hipCtx_t, dev: hipDevice_t) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Resets the primary context on the GPU.\n\n @param [in] dev  Device which primary context is reset\n\n @returns #hipSuccess\n\n @see hipCtxCreate, hipCtxDestroy, hipCtxGetFlags, hipCtxPopCurrent, hipCtxGetCurrent,\n hipCtxSetCurrent, hipCtxPushCurrent, hipCtxSetCacheConfig, hipCtxSynchronize, hipCtxGetDevice"]
    pub fn hipDevicePrimaryCtxReset(dev: hipDevice_t) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Set flags for the primary context.\n\n @param [in] dev  Device for which the primary context flags are set\n @param [in] flags  New flags for the device\n\n @returns #hipSuccess, #hipErrorContextAlreadyInUse\n\n @see hipCtxCreate, hipCtxDestroy, hipCtxGetFlags, hipCtxPopCurrent, hipCtxGetCurrent,\n hipCtxSetCurrent, hipCtxPushCurrent, hipCtxSetCacheConfig, hipCtxSynchronize, hipCtxGetDevice"]
    pub fn hipDevicePrimaryCtxSetFlags(
        dev: hipDevice_t,
        flags: ::std::os::raw::c_uint,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @}\n/\n/**\n-------------------------------------------------------------------------------------------------\n-------------------------------------------------------------------------------------------------\n\n  @defgroup Module Module Management\n  @{\n  @ingroup API\n  This section describes the module management functions of HIP runtime API.\n\n/\n/**\n @brief Loads code object from file into a module the currrent context.\n\n @param [in] fname  Filename of code object to load\n\n @param [out] module  Module\n\n @warning File/memory resources allocated in this function are released only in hipModuleUnload.\n\n @returns #hipSuccess, #hipErrorInvalidValue, #hipErrorInvalidContext, #hipErrorFileNotFound,\n #hipErrorOutOfMemory, #hipErrorSharedObjectInitFailed, #hipErrorNotInitialized\n"]
    pub fn hipModuleLoad(
        module: *mut hipModule_t,
        fname: *const ::std::os::raw::c_char,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Frees the module\n\n @param [in] module  Module to free\n\n @returns #hipSuccess, #hipErrorInvalidResourceHandle\n\n The module is freed, and the code objects associated with it are destroyed."]
    pub fn hipModuleUnload(module: hipModule_t) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Function with kname will be extracted if present in module\n\n @param [in] module  Module to get function from\n @param [in] kname  Pointer to the name of function\n @param [out] function  Pointer to function handle\n\n @returns #hipSuccess, #hipErrorInvalidValue, #hipErrorInvalidContext, #hipErrorNotInitialized,\n #hipErrorNotFound,"]
    pub fn hipModuleGetFunction(
        function: *mut hipFunction_t,
        module: hipModule_t,
        kname: *const ::std::os::raw::c_char,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Find out attributes for a given function.\n\n @param [out] attr  Attributes of funtion\n @param [in] func  Pointer to the function handle\n\n @returns #hipSuccess, #hipErrorInvalidValue, #hipErrorInvalidDeviceFunction"]
    pub fn hipFuncGetAttributes(
        attr: *mut hipFuncAttributes,
        func: *const ::std::os::raw::c_void,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Find out a specific attribute for a given function.\n\n @param [out] value  Pointer to the value\n @param [in]  attrib  Attributes of the given funtion\n @param [in]  hfunc  Function to get attributes from\n\n @returns #hipSuccess, #hipErrorInvalidValue, #hipErrorInvalidDeviceFunction"]
    pub fn hipFuncGetAttribute(
        value: *mut ::std::os::raw::c_int,
        attrib: hipFunction_attribute,
        hfunc: hipFunction_t,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief returns the handle of the texture reference with the name from the module.\n\n @param [in] hmod  Module\n @param [in] name  Pointer of name of texture reference\n @param [out] texRef  Pointer of texture reference\n\n @returns #hipSuccess, #hipErrorNotInitialized, #hipErrorNotFound, #hipErrorInvalidValue"]
    pub fn hipModuleGetTexRef(
        texRef: *mut *mut textureReference,
        hmod: hipModule_t,
        name: *const ::std::os::raw::c_char,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief builds module from code object which resides in host memory. Image is pointer to that\n location.\n\n @param [in] image  The pointer to the location of data\n @param [out] module  Retuned module\n\n @returns hipSuccess, hipErrorNotInitialized, hipErrorOutOfMemory, hipErrorNotInitialized"]
    pub fn hipModuleLoadData(
        module: *mut hipModule_t,
        image: *const ::std::os::raw::c_void,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief builds module from code object which resides in host memory. Image is pointer to that\n location. Options are not used. hipModuleLoadData is called.\n\n @param [in] image  The pointer to the location of data\n @param [out] module  Retuned module\n @param [in] numOptions Number of options\n @param [in] options Options for JIT\n @param [in] optionValues  Option values for JIT\n\n @returns hipSuccess, hipErrorNotInitialized, hipErrorOutOfMemory, hipErrorNotInitialized"]
    pub fn hipModuleLoadDataEx(
        module: *mut hipModule_t,
        image: *const ::std::os::raw::c_void,
        numOptions: ::std::os::raw::c_uint,
        options: *mut hipJitOption,
        optionValues: *mut *mut ::std::os::raw::c_void,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief launches kernel f with launch parameters and shared memory on stream with arguments passed\n to kernelparams or extra\n\n @param [in] f         Kernel to launch.\n @param [in] gridDimX  X grid dimension specified as multiple of blockDimX.\n @param [in] gridDimY  Y grid dimension specified as multiple of blockDimY.\n @param [in] gridDimZ  Z grid dimension specified as multiple of blockDimZ.\n @param [in] blockDimX X block dimensions specified in work-items\n @param [in] blockDimY Y grid dimension specified in work-items\n @param [in] blockDimZ Z grid dimension specified in work-items\n @param [in] sharedMemBytes Amount of dynamic shared memory to allocate for this kernel. The\n HIP-Clang compiler provides support for extern shared declarations.\n @param [in] stream    Stream where the kernel should be dispatched.  May be 0, in which case th\n default stream is used with associated synchronization rules.\n @param [in] kernelParams  Kernel parameters to launch\n @param [in] extra     Pointer to kernel arguments.   These are passed directly to the kernel and\n must be in the memory layout and alignment expected by the kernel.\n All passed arguments must be naturally aligned according to their type. The memory address of each\n argument should be a multiple of its size in bytes. Please refer to hip_porting_driver_api.md\n for sample usage.\n\n Please note, HIP does not support kernel launch with total work items defined in dimension with\n size gridDim x blockDim >= 2^32. So gridDim.x * blockDim.x, gridDim.y * blockDim.y\n and gridDim.z * blockDim.z are always less than 2^32.\n\n @returns hipSuccess, hipInvalidDevice, hipErrorNotInitialized, hipErrorInvalidValue"]
    pub fn hipModuleLaunchKernel(
        f: hipFunction_t,
        gridDimX: ::std::os::raw::c_uint,
        gridDimY: ::std::os::raw::c_uint,
        gridDimZ: ::std::os::raw::c_uint,
        blockDimX: ::std::os::raw::c_uint,
        blockDimY: ::std::os::raw::c_uint,
        blockDimZ: ::std::os::raw::c_uint,
        sharedMemBytes: ::std::os::raw::c_uint,
        stream: hipStream_t,
        kernelParams: *mut *mut ::std::os::raw::c_void,
        extra: *mut *mut ::std::os::raw::c_void,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief launches kernel f with launch parameters and shared memory on stream with arguments passed\n to kernelParams, where thread blocks can cooperate and synchronize as they execute\n\n @param [in] f              Kernel to launch.\n @param [in] gridDimX       X grid dimension specified as multiple of blockDimX.\n @param [in] gridDimY       Y grid dimension specified as multiple of blockDimY.\n @param [in] gridDimZ       Z grid dimension specified as multiple of blockDimZ.\n @param [in] blockDimX      X block dimension specified in work-items.\n @param [in] blockDimY      Y block dimension specified in work-items.\n @param [in] blockDimZ      Z block dimension specified in work-items.\n @param [in] sharedMemBytes Amount of dynamic shared memory to allocate for this kernel. The\n HIP-Clang compiler provides support for extern shared declarations.\n @param [in] stream         Stream where the kernel should be dispatched. May be 0,\n in which case the default stream is used with associated synchronization rules.\n @param [in] kernelParams   A list of kernel arguments.\n\n Please note, HIP does not support kernel launch with total work items defined in dimension with\n size gridDim x blockDim >= 2^32.\n\n @returns hipSuccess, hipErrorDeinitialized, hipErrorNotInitialized, hipErrorInvalidContext,\n hipErrorInvalidHandle, hipErrorInvalidImage, hipErrorInvalidValue, hipInvalidDevice,\n hipErrorInvalidConfiguration, hipErrorLaunchFailure, hipErrorLaunchOutOfResources,\n hipErrorLaunchTimeOut, hipErrorCooperativeLaunchTooLarge, hipErrorSharedObjectInitFailed"]
    pub fn hipModuleLaunchCooperativeKernel(
        f: hipFunction_t,
        gridDimX: ::std::os::raw::c_uint,
        gridDimY: ::std::os::raw::c_uint,
        gridDimZ: ::std::os::raw::c_uint,
        blockDimX: ::std::os::raw::c_uint,
        blockDimY: ::std::os::raw::c_uint,
        blockDimZ: ::std::os::raw::c_uint,
        sharedMemBytes: ::std::os::raw::c_uint,
        stream: hipStream_t,
        kernelParams: *mut *mut ::std::os::raw::c_void,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Launches kernels on multiple devices where thread blocks can cooperate and\n synchronize as they execute.\n\n @param [in] launchParamsList         List of launch parameters, one per device.\n @param [in] numDevices               Size of the launchParamsList array.\n @param [in] flags                    Flags to control launch behavior.\n\n @returns hipSuccess, hipErrorDeinitialized, hipErrorNotInitialized, hipErrorInvalidContext,\n hipErrorInvalidHandle, hipErrorInvalidImage, hipErrorInvalidValue, hipInvalidDevice,\n hipErrorInvalidConfiguration, hipErrorInvalidResourceHandle, hipErrorLaunchFailure,\n hipErrorLaunchOutOfResources, hipErrorLaunchTimeOut, hipErrorCooperativeLaunchTooLarge,\n hipErrorSharedObjectInitFailed"]
    pub fn hipModuleLaunchCooperativeKernelMultiDevice(
        launchParamsList: *mut hipFunctionLaunchParams,
        numDevices: ::std::os::raw::c_uint,
        flags: ::std::os::raw::c_uint,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief launches kernel f with launch parameters and shared memory on stream with arguments passed\n to kernelparams or extra, where thread blocks can cooperate and synchronize as they execute\n\n @param [in] f         Kernel to launch.\n @param [in] gridDim   Grid dimensions specified as multiple of blockDim.\n @param [in] blockDimX  Block dimensions specified in work-items\n @param [in] kernelParams A list of kernel arguments\n @param [in] sharedMemBytes Amount of dynamic shared memory to allocate for this kernel. The\n HIP-Clang compiler provides support for extern shared declarations.\n @param [in] stream    Stream where the kernel should be dispatched.  May be 0, in which case th\n default stream is used with associated synchronization rules.\n\n Please note, HIP does not support kernel launch with total work items defined in dimension with\n size gridDim x blockDim >= 2^32.\n\n @returns hipSuccess, hipInvalidDevice, hipErrorNotInitialized, hipErrorInvalidValue, hipErrorCooperativeLaunchTooLarge"]
    pub fn hipLaunchCooperativeKernel(
        f: *const ::std::os::raw::c_void,
        gridDim: dim3,
        blockDimX: dim3,
        kernelParams: *mut *mut ::std::os::raw::c_void,
        sharedMemBytes: ::std::os::raw::c_uint,
        stream: hipStream_t,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Launches kernels on multiple devices where thread blocks can cooperate and\n synchronize as they execute.\n\n @param [in] launchParamsList         List of launch parameters, one per device.\n @param [in] numDevices               Size of the launchParamsList array.\n @param [in] flags                    Flags to control launch behavior.\n\n @returns hipSuccess, hipInvalidDevice, hipErrorNotInitialized, hipErrorInvalidValue, hipErrorCooperativeLaunchTooLarge"]
    pub fn hipLaunchCooperativeKernelMultiDevice(
        launchParamsList: *mut hipLaunchParams,
        numDevices: ::std::os::raw::c_int,
        flags: ::std::os::raw::c_uint,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Launches kernels on multiple devices and guarantees all specified kernels are dispatched\n on respective streams before enqueuing any other work on the specified streams from any other threads\n\n\n @param [in] launchParamsList          List of launch parameters, one per device.\n @param [in] numDevices               Size of the launchParamsList array.\n @param [in] flags                    Flags to control launch behavior.\n\n @returns hipSuccess, hipInvalidDevice, hipErrorNotInitialized, hipErrorInvalidValue"]
    pub fn hipExtLaunchMultiKernelMultiDevice(
        launchParamsList: *mut hipLaunchParams,
        numDevices: ::std::os::raw::c_int,
        flags: ::std::os::raw::c_uint,
    ) -> hipError_t;
}
extern "C" {
    #[doc = "-------------------------------------------------------------------------------------------------\n-------------------------------------------------------------------------------------------------\n  @defgroup Occupancy Occupancy\n  @{\n  This section describes the occupancy functions of HIP runtime API.\n\n/\n/**\n @brief determine the grid and block sizes to achieves maximum occupancy for a kernel\n\n @param [out] gridSize           minimum grid size for maximum potential occupancy\n @param [out] blockSize          block size for maximum potential occupancy\n @param [in]  f                  kernel function for which occupancy is calulated\n @param [in]  dynSharedMemPerBlk dynamic shared memory usage (in bytes) intended for each block\n @param [in]  blockSizeLimit     the maximum block size for the kernel, use 0 for no limit\n\n Please note, HIP does not support kernel launch with total work items defined in dimension with\n size gridDim x blockDim >= 2^32.\n\n @returns hipSuccess, hipInvalidDevice, hipErrorInvalidValue"]
    pub fn hipModuleOccupancyMaxPotentialBlockSize(
        gridSize: *mut ::std::os::raw::c_int,
        blockSize: *mut ::std::os::raw::c_int,
        f: hipFunction_t,
        dynSharedMemPerBlk: usize,
        blockSizeLimit: ::std::os::raw::c_int,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief determine the grid and block sizes to achieves maximum occupancy for a kernel\n\n @param [out] gridSize           minimum grid size for maximum potential occupancy\n @param [out] blockSize          block size for maximum potential occupancy\n @param [in]  f                  kernel function for which occupancy is calulated\n @param [in]  dynSharedMemPerBlk dynamic shared memory usage (in bytes) intended for each block\n @param [in]  blockSizeLimit     the maximum block size for the kernel, use 0 for no limit\n @param [in]  flags            Extra flags for occupancy calculation (only default supported)\n\n Please note, HIP does not support kernel launch with total work items defined in dimension with\n size gridDim x blockDim >= 2^32.\n\n @returns hipSuccess, hipInvalidDevice, hipErrorInvalidValue"]
    pub fn hipModuleOccupancyMaxPotentialBlockSizeWithFlags(
        gridSize: *mut ::std::os::raw::c_int,
        blockSize: *mut ::std::os::raw::c_int,
        f: hipFunction_t,
        dynSharedMemPerBlk: usize,
        blockSizeLimit: ::std::os::raw::c_int,
        flags: ::std::os::raw::c_uint,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Returns occupancy for a device function.\n\n @param [out] numBlocks        Returned occupancy\n @param [in]  f                Kernel function (hipFunction) for which occupancy is calulated\n @param [in]  blockSize        Block size the kernel is intended to be launched with\n @param [in]  dynSharedMemPerBlk Dynamic shared memory usage (in bytes) intended for each block\n @param [in]  dynSharedMemPerBlk dynamic shared memory usage (in bytes) intended for each block\n @returns  #hipSuccess, #hipInvalidDevice, #hipErrorInvalidValue"]
    pub fn hipModuleOccupancyMaxActiveBlocksPerMultiprocessor(
        numBlocks: *mut ::std::os::raw::c_int,
        f: hipFunction_t,
        blockSize: ::std::os::raw::c_int,
        dynSharedMemPerBlk: usize,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Returns occupancy for a device function.\n\n @param [out] numBlocks        Returned occupancy\n @param [in]  f                Kernel function(hipFunction_t) for which occupancy is calulated\n @param [in]  blockSize        Block size the kernel is intended to be launched with\n @param [in]  dynSharedMemPerBlk Dynamic shared memory usage (in bytes) intended for each block\n @param [in]  flags            Extra flags for occupancy calculation (only default supported)\n @returns  #hipSuccess, #hipInvalidDevice, #hipErrorInvalidValue"]
    pub fn hipModuleOccupancyMaxActiveBlocksPerMultiprocessorWithFlags(
        numBlocks: *mut ::std::os::raw::c_int,
        f: hipFunction_t,
        blockSize: ::std::os::raw::c_int,
        dynSharedMemPerBlk: usize,
        flags: ::std::os::raw::c_uint,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Returns occupancy for a device function.\n\n @param [out] numBlocks        Returned occupancy\n @param [in]  f                Kernel function for which occupancy is calulated\n @param [in]  blockSize        Block size the kernel is intended to be launched with\n @param [in]  dynSharedMemPerBlk Dynamic shared memory usage (in bytes) intended for each block\n @param [in]  dynSharedMemPerBlk dynamic shared memory usage (in bytes) intended for each block\n @returns  #hipSuccess, #hipInvalidDevice, #hipErrorInvalidDeviceFunction, #hipErrorInvalidValue"]
    pub fn hipOccupancyMaxActiveBlocksPerMultiprocessor(
        numBlocks: *mut ::std::os::raw::c_int,
        f: *const ::std::os::raw::c_void,
        blockSize: ::std::os::raw::c_int,
        dynSharedMemPerBlk: usize,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Returns occupancy for a device function.\n\n @param [out] numBlocks        Returned occupancy\n @param [in]  f                Kernel function for which occupancy is calulated\n @param [in]  blockSize        Block size the kernel is intended to be launched with\n @param [in]  dynSharedMemPerBlk Dynamic shared memory usage (in bytes) intended for each block\n @param [in]  flags            Extra flags for occupancy calculation (currently ignored)\n @returns  #hipSuccess, #hipInvalidDevice, #hipErrorInvalidDeviceFunction, #hipErrorInvalidValue"]
    pub fn hipOccupancyMaxActiveBlocksPerMultiprocessorWithFlags(
        numBlocks: *mut ::std::os::raw::c_int,
        f: *const ::std::os::raw::c_void,
        blockSize: ::std::os::raw::c_int,
        dynSharedMemPerBlk: usize,
        flags: ::std::os::raw::c_uint,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief determine the grid and block sizes to achieves maximum occupancy for a kernel\n\n @param [out] gridSize           minimum grid size for maximum potential occupancy\n @param [out] blockSize          block size for maximum potential occupancy\n @param [in]  f                  kernel function for which occupancy is calulated\n @param [in]  dynSharedMemPerBlk dynamic shared memory usage (in bytes) intended for each block\n @param [in]  blockSizeLimit     the maximum block size for the kernel, use 0 for no limit\n\n Please note, HIP does not support kernel launch with total work items defined in dimension with\n size gridDim x blockDim >= 2^32.\n\n @returns #hipSuccess, #hipInvalidDevice, #hipErrorInvalidValue"]
    pub fn hipOccupancyMaxPotentialBlockSize(
        gridSize: *mut ::std::os::raw::c_int,
        blockSize: *mut ::std::os::raw::c_int,
        f: *const ::std::os::raw::c_void,
        dynSharedMemPerBlk: usize,
        blockSizeLimit: ::std::os::raw::c_int,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Start recording of profiling information\n When using this API, start the profiler with profiling disabled.  (--startdisabled)\n @returns  #hipErrorNotSupported\n @warning : hipProfilerStart API is deprecated, use roctracer/rocTX instead."]
    pub fn hipProfilerStart() -> hipError_t;
}
extern "C" {
    #[doc = " @brief Stop recording of profiling information.\n When using this API, start the profiler with profiling disabled.  (--startdisabled)\n @returns  #hipErrorNotSupported\n @warning  hipProfilerStart API is deprecated, use roctracer/rocTX instead."]
    pub fn hipProfilerStop() -> hipError_t;
}
extern "C" {
    #[doc = " @}\n/\n/**\n-------------------------------------------------------------------------------------------------\n-------------------------------------------------------------------------------------------------\n  @defgroup Clang Launch API to support the triple-chevron syntax\n  @{\n  This section describes the API to support the triple-chevron syntax.\n/\n/**\n @brief Configure a kernel launch.\n\n @param [in] gridDim   grid dimension specified as multiple of blockDim.\n @param [in] blockDim  block dimensions specified in work-items\n @param [in] sharedMem Amount of dynamic shared memory to allocate for this kernel. The\n HIP-Clang compiler provides support for extern shared declarations.\n @param [in] stream    Stream where the kernel should be dispatched.  May be 0, in which case the\n default stream is used with associated synchronization rules.\n\n Please note, HIP does not support kernel launch with total work items defined in dimension with\n size gridDim x blockDim >= 2^32.\n\n @returns hipSuccess, hipInvalidDevice, hipErrorNotInitialized, hipErrorInvalidValue\n"]
    pub fn hipConfigureCall(
        gridDim: dim3,
        blockDim: dim3,
        sharedMem: usize,
        stream: hipStream_t,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Set a kernel argument.\n\n @returns hipSuccess, hipInvalidDevice, hipErrorNotInitialized, hipErrorInvalidValue\n\n @param [in] arg    Pointer the argument in host memory.\n @param [in] size   Size of the argument.\n @param [in] offset Offset of the argument on the argument stack.\n"]
    pub fn hipSetupArgument(
        arg: *const ::std::os::raw::c_void,
        size: usize,
        offset: usize,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Launch a kernel.\n\n @param [in] func Kernel to launch.\n\n @returns hipSuccess, hipInvalidDevice, hipErrorNotInitialized, hipErrorInvalidValue\n"]
    pub fn hipLaunchByPtr(func: *const ::std::os::raw::c_void) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Push configuration of a kernel launch.\n\n @param [in] gridDim   grid dimension specified as multiple of blockDim.\n @param [in] blockDim  block dimensions specified in work-items\n @param [in] sharedMem Amount of dynamic shared memory to allocate for this kernel. The\n HIP-Clang compiler provides support for extern shared declarations.\n @param [in] stream    Stream where the kernel should be dispatched.  May be 0, in which case the\n default stream is used with associated synchronization rules.\n\n Please note, HIP does not support kernel launch with total work items defined in dimension with\n size gridDim x blockDim >= 2^32.\n\n @returns hipSuccess, hipInvalidDevice, hipErrorNotInitialized, hipErrorInvalidValue\n"]
    pub fn __hipPushCallConfiguration(
        gridDim: dim3,
        blockDim: dim3,
        sharedMem: usize,
        stream: hipStream_t,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Pop configuration of a kernel launch.\n\n @param [out] gridDim   grid dimension specified as multiple of blockDim.\n @param [out] blockDim  block dimensions specified in work-items\n @param [out] sharedMem Amount of dynamic shared memory to allocate for this kernel.  The\n HIP-Clang compiler provides support for extern shared declarations.\n @param [out] stream    Stream where the kernel should be dispatched.  May be 0, in which case the\n default stream is used with associated synchronization rules.\n\n Please note, HIP does not support kernel launch with total work items defined in dimension with\n size gridDim x blockDim >= 2^32.\n\n Please note, HIP does not support kernel launch with total work items defined in dimension with\n size gridDim x blockDim >= 2^32.\n\n @returns hipSuccess, hipInvalidDevice, hipErrorNotInitialized, hipErrorInvalidValue\n"]
    pub fn __hipPopCallConfiguration(
        gridDim: *mut dim3,
        blockDim: *mut dim3,
        sharedMem: *mut usize,
        stream: *mut hipStream_t,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief C compliant kernel launch API\n\n @param [in] function_address - kernel stub function pointer.\n @param [in] numBlocks - number of blocks\n @param [in] dimBlocks - dimension of a block\n @param [in] args - kernel arguments\n @param [in] sharedMemBytes - Amount of dynamic shared memory to allocate for this kernel. The\n HIP-Clang compiler provides support for extern shared declarations.\n @param [in] stream - Stream where the kernel should be dispatched.  May be 0, in which case th\n  default stream is used with associated synchronization rules.\n\n @returns #hipSuccess, #hipErrorInvalidValue, hipInvalidDevice\n"]
    pub fn hipLaunchKernel(
        function_address: *const ::std::os::raw::c_void,
        numBlocks: dim3,
        dimBlocks: dim3,
        args: *mut *mut ::std::os::raw::c_void,
        sharedMemBytes: usize,
        stream: hipStream_t,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Enqueues a host function call in a stream.\n\n @param [in] stream - stream to enqueue work to.\n @param [in] fn - function to call once operations enqueued preceeding are complete.\n @param [in] userData - User-specified data to be passed to the function.\n @returns #hipSuccess, #hipErrorInvalidResourceHandle, #hipErrorInvalidValue,\n #hipErrorNotSupported\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues."]
    pub fn hipLaunchHostFunc(
        stream: hipStream_t,
        fn_: hipHostFn_t,
        userData: *mut ::std::os::raw::c_void,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " Copies memory for 2D arrays.\n\n @param pCopy           - Parameters for the memory copy\n\n @returns #hipSuccess, #hipErrorInvalidValue"]
    pub fn hipDrvMemcpy2DUnaligned(pCopy: *const hip_Memcpy2D) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Launches kernel from the pointer address, with arguments and shared memory on stream.\n\n @param [in] function_address pointer to the Kernel to launch.\n @param [in] numBlocks number of blocks.\n @param [in] dimBlocks dimension of a block.\n @param [in] args pointer to kernel arguments.\n @param [in] sharedMemBytes  Amount of dynamic shared memory to allocate for this kernel.\n HIP-Clang compiler provides support for extern shared declarations.\n @param [in] stream  Stream where the kernel should be dispatched.\n May be 0, in which case the default stream is used with associated synchronization rules.\n @param [in] startEvent  If non-null, specified event will be updated to track the start time of\n the kernel launch. The event must be created before calling this API.\n @param [in] stopEvent  If non-null, specified event will be updated to track the stop time of\n the kernel launch. The event must be created before calling this API.\n @param [in] flags. The value of hipExtAnyOrderLaunch, signifies if kernel can be\n launched in any order.\n @returns hipSuccess, hipInvalidDevice, hipErrorNotInitialized, hipErrorInvalidValue.\n"]
    pub fn hipExtLaunchKernel(
        function_address: *const ::std::os::raw::c_void,
        numBlocks: dim3,
        dimBlocks: dim3,
        args: *mut *mut ::std::os::raw::c_void,
        sharedMemBytes: usize,
        stream: hipStream_t,
        startEvent: hipEvent_t,
        stopEvent: hipEvent_t,
        flags: ::std::os::raw::c_int,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Creates a texture object.\n\n @param [out] pTexObject  pointer to the texture object to create\n @param [in] pResDesc  pointer to resource descriptor\n @param [in] pTexDesc  pointer to texture descriptor\n @param [in] pResViewDesc  pointer to resource view descriptor\n\n @returns #hipSuccess, #hipErrorInvalidValue, #hipErrorNotSupported, #hipErrorOutOfMemory\n\n @note 3D liner filter isn't supported on GFX90A boards, on which the API @p hipCreateTextureObject will\n return hipErrorNotSupported.\n"]
    pub fn hipCreateTextureObject(
        pTexObject: *mut hipTextureObject_t,
        pResDesc: *const hipResourceDesc,
        pTexDesc: *const hipTextureDesc,
        pResViewDesc: *const hipResourceViewDesc,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Destroys a texture object.\n\n @param [in] textureObject  texture object to destroy\n\n @returns #hipSuccess, #hipErrorInvalidValue\n"]
    pub fn hipDestroyTextureObject(textureObject: hipTextureObject_t) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Gets the channel descriptor in an array.\n\n @param [in] desc  pointer to channel format descriptor\n @param [out] array  memory array on the device\n\n @returns #hipSuccess, #hipErrorInvalidValue\n"]
    pub fn hipGetChannelDesc(
        desc: *mut hipChannelFormatDesc,
        array: hipArray_const_t,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Gets resource descriptor for the texture object.\n\n @param [out] pResDesc  pointer to resource descriptor\n @param [in] textureObject  texture object\n\n @returns #hipSuccess, #hipErrorInvalidValue\n"]
    pub fn hipGetTextureObjectResourceDesc(
        pResDesc: *mut hipResourceDesc,
        textureObject: hipTextureObject_t,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Gets resource view descriptor for the texture object.\n\n @param [out] pResViewDesc  pointer to resource view descriptor\n @param [in] textureObject  texture object\n\n @returns #hipSuccess, #hipErrorInvalidValue\n"]
    pub fn hipGetTextureObjectResourceViewDesc(
        pResViewDesc: *mut hipResourceViewDesc,
        textureObject: hipTextureObject_t,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Gets texture descriptor for the texture object.\n\n @param [out] pTexDesc  pointer to texture descriptor\n @param [in] textureObject  texture object\n\n @returns #hipSuccess, #hipErrorInvalidValue\n"]
    pub fn hipGetTextureObjectTextureDesc(
        pTexDesc: *mut hipTextureDesc,
        textureObject: hipTextureObject_t,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Creates a texture object.\n\n @param [out] pTexObject  pointer to texture object to create\n @param [in] pResDesc  pointer to resource descriptor\n @param [in] pTexDesc  pointer to texture descriptor\n @param [in] pResViewDesc  pointer to resource view descriptor\n\n @returns #hipSuccess, #hipErrorInvalidValue\n"]
    pub fn hipTexObjectCreate(
        pTexObject: *mut hipTextureObject_t,
        pResDesc: *const HIP_RESOURCE_DESC,
        pTexDesc: *const HIP_TEXTURE_DESC,
        pResViewDesc: *const HIP_RESOURCE_VIEW_DESC,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Destroys a texture object.\n\n @param [in] texObject  texture object to destroy\n\n @returns #hipSuccess, #hipErrorInvalidValue\n"]
    pub fn hipTexObjectDestroy(texObject: hipTextureObject_t) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Gets resource descriptor of a texture object.\n\n @param [out] pResDesc  pointer to resource descriptor\n @param [in] texObject  texture object\n\n @returns #hipSuccess, #hipErrorNotSupported, #hipErrorInvalidValue\n"]
    pub fn hipTexObjectGetResourceDesc(
        pResDesc: *mut HIP_RESOURCE_DESC,
        texObject: hipTextureObject_t,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Gets resource view descriptor of a texture object.\n\n @param [out] pResViewDesc  pointer to resource view descriptor\n @param [in] texObject  texture object\n\n @returns #hipSuccess, #hipErrorNotSupported, #hipErrorInvalidValue\n"]
    pub fn hipTexObjectGetResourceViewDesc(
        pResViewDesc: *mut HIP_RESOURCE_VIEW_DESC,
        texObject: hipTextureObject_t,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Gets texture descriptor of a texture object.\n\n @param [out] pTexDesc  pointer to texture descriptor\n @param [in] texObject  texture object\n\n @returns #hipSuccess, #hipErrorNotSupported, #hipErrorInvalidValue\n"]
    pub fn hipTexObjectGetTextureDesc(
        pTexDesc: *mut HIP_TEXTURE_DESC,
        texObject: hipTextureObject_t,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Allocate a mipmapped array on the device.\n\n @param[out] mipmappedArray  - Pointer to allocated mipmapped array in device memory\n @param[in]  desc            - Requested channel format\n @param[in]  extent          - Requested allocation size (width field in elements)\n @param[in]  numLevels       - Number of mipmap levels to allocate\n @param[in]  flags           - Flags for extensions\n\n @return #hipSuccess, #hipErrorInvalidValue, #hipErrorMemoryAllocation\n\n @note  This API is implemented on Windows, under development on Linux.\n"]
    pub fn hipMallocMipmappedArray(
        mipmappedArray: *mut hipMipmappedArray_t,
        desc: *const hipChannelFormatDesc,
        extent: hipExtent,
        numLevels: ::std::os::raw::c_uint,
        flags: ::std::os::raw::c_uint,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Frees a mipmapped array on the device.\n\n @param[in] mipmappedArray - Pointer to mipmapped array to free\n\n @return #hipSuccess, #hipErrorInvalidValue\n\n @note  This API is implemented on Windows, under development on Linux.\n"]
    pub fn hipFreeMipmappedArray(mipmappedArray: hipMipmappedArray_t) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Gets a mipmap level of a HIP mipmapped array.\n\n @param[out] levelArray     - Returned mipmap level HIP array\n @param[in]  mipmappedArray - HIP mipmapped array\n @param[in]  level          - Mipmap level\n\n @return #hipSuccess, #hipErrorInvalidValue\n\n @note  This API is implemented on Windows, under development on Linux.\n"]
    pub fn hipGetMipmappedArrayLevel(
        levelArray: *mut hipArray_t,
        mipmappedArray: hipMipmappedArray_const_t,
        level: ::std::os::raw::c_uint,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Create a mipmapped array.\n\n @param [out] pHandle  pointer to mipmapped array\n @param [in] pMipmappedArrayDesc  mipmapped array descriptor\n @param [in] numMipmapLevels  mipmap level\n\n @returns #hipSuccess, #hipErrorNotSupported, #hipErrorInvalidValue\n\n @note  This API is implemented on Windows, under development on Linux."]
    pub fn hipMipmappedArrayCreate(
        pHandle: *mut hipMipmappedArray_t,
        pMipmappedArrayDesc: *mut HIP_ARRAY3D_DESCRIPTOR,
        numMipmapLevels: ::std::os::raw::c_uint,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Destroy a mipmapped array.\n\n @param [out] hMipmappedArray  pointer to mipmapped array to destroy\n\n @returns #hipSuccess, #hipErrorInvalidValue\n\n @note  This API is implemented on Windows, under development on Linux.\n"]
    pub fn hipMipmappedArrayDestroy(hMipmappedArray: hipMipmappedArray_t) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Get a mipmapped array on a mipmapped level.\n\n @param [in] pLevelArray Pointer of array\n @param [out] hMipMappedArray Pointer of mipmapped array on the requested mipmap level\n @param [out] level  Mipmap level\n\n @returns #hipSuccess, #hipErrorInvalidValue\n\n @note  This API is implemented on Windows, under development on Linux.\n"]
    pub fn hipMipmappedArrayGetLevel(
        pLevelArray: *mut hipArray_t,
        hMipMappedArray: hipMipmappedArray_t,
        level: ::std::os::raw::c_uint,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief  Binds a mipmapped array to a texture.\n\n @param [in] tex  pointer to the texture reference to bind\n @param [in] mipmappedArray memory mipmapped array on the device\n @param [in] desc  opointer to the channel format\n\n @returns #hipSuccess, #hipErrorInvalidValue\n"]
    pub fn hipBindTextureToMipmappedArray(
        tex: *const textureReference,
        mipmappedArray: hipMipmappedArray_const_t,
        desc: *const hipChannelFormatDesc,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Gets the texture reference related with the symbol.\n\n @param [out] texref  texture reference\n @param [in] symbol  pointer to the symbol related with the texture for the reference\n\n @returns #hipSuccess, #hipErrorInvalidValue\n @warning This API is deprecated.\n"]
    pub fn hipGetTextureReference(
        texref: *mut *const textureReference,
        symbol: *const ::std::os::raw::c_void,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Sets address mode for a texture reference.\n\n @param [in] texRef  texture reference.\n @param [in] dim  Dimension of the texture.\n @param [in] am  Value of the texture address mode.\n\n @returns #hipSuccess, #hipErrorInvalidValue\n @warning This API is deprecated.\n"]
    pub fn hipTexRefSetAddressMode(
        texRef: *mut textureReference,
        dim: ::std::os::raw::c_int,
        am: hipTextureAddressMode,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Binds an array as a texture reference.\n\n @param [in] tex  Pointer texture reference.\n @param [in] array  Array to bind.\n @param [in] flags  Flags should be set as HIP_TRSA_OVERRIDE_FORMAT, as a valid value.\n\n @returns #hipSuccess, #hipErrorInvalidValue\n\n @warning This API is deprecated.\n"]
    pub fn hipTexRefSetArray(
        tex: *mut textureReference,
        array: hipArray_const_t,
        flags: ::std::os::raw::c_uint,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Set filter mode for a texture reference.\n\n @param [in] texRef  Pointer texture reference.\n @param [in] fm  Value of texture filter mode.\n\n @returns #hipSuccess, #hipErrorInvalidValue\n\n @warning This API is deprecated.\n"]
    pub fn hipTexRefSetFilterMode(
        texRef: *mut textureReference,
        fm: hipTextureFilterMode,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Set flags for a texture reference.\n\n @param [in] texRef  Pointer texture reference.\n @param [in] Flags  Value of flags.\n\n @returns #hipSuccess, #hipErrorInvalidValue\n\n @warning This API is deprecated.\n"]
    pub fn hipTexRefSetFlags(
        texRef: *mut textureReference,
        Flags: ::std::os::raw::c_uint,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Set format for a texture reference.\n\n @param [in] texRef  Pointer texture reference.\n @param [in] fmt  Value of format.\n @param [in] NumPackedComponents  Number of components per array.\n\n @returns #hipSuccess, #hipErrorInvalidValue\n\n @warning This API is deprecated.\n"]
    pub fn hipTexRefSetFormat(
        texRef: *mut textureReference,
        fmt: hipArray_Format,
        NumPackedComponents: ::std::os::raw::c_int,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Binds a memory area to a texture.\n\n @param [in] offset  Offset in bytes.\n @param [in] tex  Texture to bind.\n @param [in] devPtr  Pointer of memory on the device.\n @param [in] desc  Pointer of channel format descriptor.\n @param [in] size  Size of memory in bites.\n\n @returns #hipSuccess, #hipErrorInvalidValue, #hipErrorNotSupported\n\n @warning This API is deprecated.\n"]
    pub fn hipBindTexture(
        offset: *mut usize,
        tex: *const textureReference,
        devPtr: *const ::std::os::raw::c_void,
        desc: *const hipChannelFormatDesc,
        size: usize,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Binds a 2D memory area to a texture.\n\n @param [in] offset  Offset in bytes.\n @param [in] tex  Texture to bind.\n @param [in] devPtr  Pointer of 2D memory area on the device.\n @param [in] desc  Pointer of channel format descriptor.\n @param [in] width  Width in texel units.\n @param [in] height  Height in texel units.\n @param [in] pitch  Pitch in bytes.\n\n @returns #hipSuccess, #hipErrorInvalidValue, #hipErrorNotSupported\n\n @warning This API is deprecated.\n"]
    pub fn hipBindTexture2D(
        offset: *mut usize,
        tex: *const textureReference,
        devPtr: *const ::std::os::raw::c_void,
        desc: *const hipChannelFormatDesc,
        width: usize,
        height: usize,
        pitch: usize,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Binds a memory area to a texture.\n\n @param [in] tex  Pointer of texture reference.\n @param [in] array  Array to bind.\n @param [in] desc  Pointer of channel format descriptor.\n\n @returns #hipSuccess, #hipErrorInvalidValue, #hipErrorNotSupported\n\n @warning This API is deprecated.\n"]
    pub fn hipBindTextureToArray(
        tex: *const textureReference,
        array: hipArray_const_t,
        desc: *const hipChannelFormatDesc,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Get the offset of the alignment in a texture.\n\n @param [in] offset  Offset in bytes.\n @param [in] texref  Pointer of texture reference.\n\n @returns #hipSuccess, #hipErrorInvalidValue, #hipErrorNotSupported\n\n @warning This API is deprecated.\n"]
    pub fn hipGetTextureAlignmentOffset(
        offset: *mut usize,
        texref: *const textureReference,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Unbinds a texture.\n\n @param [in] tex  Texture to unbind.\n\n @returns #hipSuccess, #hipErrorInvalidValue, #hipErrorNotSupported\n\n @warning This API is deprecated.\n"]
    pub fn hipUnbindTexture(tex: *const textureReference) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Gets the the address for a texture reference.\n\n @param [out] dev_ptr  Pointer of device address.\n @param [in] texRef  Pointer of texture reference.\n\n @returns #hipSuccess, #hipErrorInvalidValue, #hipErrorNotSupported\n\n @warning This API is deprecated.\n"]
    pub fn hipTexRefGetAddress(
        dev_ptr: *mut hipDeviceptr_t,
        texRef: *const textureReference,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Gets the address mode for a texture reference.\n\n @param [out] pam  Pointer of address mode.\n @param [in] texRef  Pointer of texture reference.\n @param [in] dim  Dimension.\n\n @returns #hipSuccess, #hipErrorInvalidValue, #hipErrorNotSupported\n\n @warning This API is deprecated.\n"]
    pub fn hipTexRefGetAddressMode(
        pam: *mut hipTextureAddressMode,
        texRef: *const textureReference,
        dim: ::std::os::raw::c_int,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Gets filter mode for a texture reference.\n\n @param [out] pfm  Pointer of filter mode.\n @param [in] texRef  Pointer of texture reference.\n\n @returns #hipSuccess, #hipErrorInvalidValue, #hipErrorNotSupported\n\n @warning This API is deprecated.\n"]
    pub fn hipTexRefGetFilterMode(
        pfm: *mut hipTextureFilterMode,
        texRef: *const textureReference,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Gets flags for a texture reference.\n\n @param [out] pFlags  Pointer of flags.\n @param [in] texRef  Pointer of texture reference.\n\n @returns #hipSuccess, #hipErrorInvalidValue, #hipErrorNotSupported\n\n @warning This API is deprecated.\n"]
    pub fn hipTexRefGetFlags(
        pFlags: *mut ::std::os::raw::c_uint,
        texRef: *const textureReference,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Gets texture format for a texture reference.\n\n @param [out] pFormat  Pointer of the format.\n @param [out] pNumChannels  Pointer of number of channels.\n @param [in] texRef  Pointer of texture reference.\n\n @returns #hipSuccess, #hipErrorInvalidValue, #hipErrorNotSupported\n\n @warning This API is deprecated.\n"]
    pub fn hipTexRefGetFormat(
        pFormat: *mut hipArray_Format,
        pNumChannels: *mut ::std::os::raw::c_int,
        texRef: *const textureReference,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Gets the maximum anisotropy for a texture reference.\n\n @param [out] pmaxAnsio  Pointer of the maximum anisotropy.\n @param [in] texRef  Pointer of texture reference.\n\n @returns #hipErrorInvalidValue, #hipErrorNotSupported\n\n @warning This API is deprecated.\n"]
    pub fn hipTexRefGetMaxAnisotropy(
        pmaxAnsio: *mut ::std::os::raw::c_int,
        texRef: *const textureReference,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Gets the mipmap filter mode for a texture reference.\n\n @param [out] pfm  Pointer of the mipmap filter mode.\n @param [in] texRef  Pointer of texture reference.\n\n @returns #hipErrorInvalidValue, #hipErrorNotSupported\n\n @warning This API is deprecated.\n"]
    pub fn hipTexRefGetMipmapFilterMode(
        pfm: *mut hipTextureFilterMode,
        texRef: *const textureReference,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Gets the mipmap level bias for a texture reference.\n\n @param [out] pbias  Pointer of the mipmap level bias.\n @param [in] texRef  Pointer of texture reference.\n\n @returns #hipErrorInvalidValue, #hipErrorNotSupported\n\n @warning This API is deprecated.\n"]
    pub fn hipTexRefGetMipmapLevelBias(
        pbias: *mut f32,
        texRef: *const textureReference,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Gets the minimum and maximum mipmap level clamps for a texture reference.\n\n @param [out] pminMipmapLevelClamp  Pointer of the minimum mipmap level clamp.\n @param [out] pmaxMipmapLevelClamp  Pointer of the maximum mipmap level clamp.\n @param [in] texRef  Pointer of texture reference.\n\n @returns #hipErrorInvalidValue, #hipErrorNotSupported\n\n @warning This API is deprecated.\n"]
    pub fn hipTexRefGetMipmapLevelClamp(
        pminMipmapLevelClamp: *mut f32,
        pmaxMipmapLevelClamp: *mut f32,
        texRef: *const textureReference,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Gets the mipmapped array bound to a texture reference.\n\n @param [out] pArray  Pointer of the mipmapped array.\n @param [in] texRef  Pointer of texture reference.\n\n @returns #hipSuccess, #hipErrorInvalidValue, #hipErrorNotSupported\n\n @warning This API is deprecated.\n"]
    pub fn hipTexRefGetMipMappedArray(
        pArray: *mut hipMipmappedArray_t,
        texRef: *const textureReference,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Sets an bound address for a texture reference.\n\n @param [out] ByteOffset  Pointer of the offset in bytes.\n @param [in] texRef  Pointer of texture reference.\n @param [in] dptr  Pointer of device address to bind.\n @param [in] bytes  Size in bytes.\n\n @returns #hipSuccess, #hipErrorInvalidValue\n\n @warning This API is deprecated.\n"]
    pub fn hipTexRefSetAddress(
        ByteOffset: *mut usize,
        texRef: *mut textureReference,
        dptr: hipDeviceptr_t,
        bytes: usize,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Set a bind an address as a 2D texture reference.\n\n @param [in] texRef  Pointer of texture reference.\n @param [in] desc  Pointer of array descriptor.\n @param [in] dptr  Pointer of device address to bind.\n @param [in] Pitch  Pitch in bytes.\n\n @returns #hipSuccess, #hipErrorInvalidValue, #hipErrorNotSupported\n\n @warning This API is deprecated.\n"]
    pub fn hipTexRefSetAddress2D(
        texRef: *mut textureReference,
        desc: *const HIP_ARRAY_DESCRIPTOR,
        dptr: hipDeviceptr_t,
        Pitch: usize,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Sets the maximum anisotropy for a texture reference.\n\n @param [in] texRef  Pointer of texture reference.\n @param [out] maxAniso  Value of the maximum anisotropy.\n\n @returns #hipSuccess, #hipErrorInvalidValue, #hipErrorNotSupported\n\n @warning This API is deprecated.\n"]
    pub fn hipTexRefSetMaxAnisotropy(
        texRef: *mut textureReference,
        maxAniso: ::std::os::raw::c_uint,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Sets border color for a texture reference.\n\n @param [in] texRef  Pointer of texture reference.\n @param [in] pBorderColor  Pointer of border color.\n\n @returns #hipSuccess, #hipErrorInvalidValue, #hipErrorNotSupported\n\n @warning This API is deprecated.\n"]
    pub fn hipTexRefSetBorderColor(
        texRef: *mut textureReference,
        pBorderColor: *mut f32,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Sets mipmap filter mode for a texture reference.\n\n @param [in] texRef  Pointer of texture reference.\n @param [in] fm  Value of filter mode.\n\n @returns #hipSuccess, #hipErrorInvalidValue, #hipErrorNotSupported\n\n @warning This API is deprecated.\n"]
    pub fn hipTexRefSetMipmapFilterMode(
        texRef: *mut textureReference,
        fm: hipTextureFilterMode,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Sets mipmap level bias for a texture reference.\n\n @param [in] texRef  Pointer of texture reference.\n @param [in] bias  Value of mipmap bias.\n\n @returns #hipSuccess, #hipErrorInvalidValue, #hipErrorNotSupported\n\n @warning This API is deprecated.\n"]
    pub fn hipTexRefSetMipmapLevelBias(texRef: *mut textureReference, bias: f32) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Sets mipmap level clamp for a texture reference.\n\n @param [in] texRef  Pointer of texture reference.\n @param [in] minMipMapLevelClamp  Value of minimum mipmap level clamp.\n @param [in] maxMipMapLevelClamp  Value of maximum mipmap level clamp.\n\n @returns #hipSuccess, #hipErrorInvalidValue, #hipErrorNotSupported\n\n @warning This API is deprecated.\n"]
    pub fn hipTexRefSetMipmapLevelClamp(
        texRef: *mut textureReference,
        minMipMapLevelClamp: f32,
        maxMipMapLevelClamp: f32,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Binds mipmapped array to a texture reference.\n\n @param [in] texRef  Pointer of texture reference to bind.\n @param [in] mipmappedArray  Pointer of mipmapped array to bind.\n @param [in] Flags  Flags should be set as HIP_TRSA_OVERRIDE_FORMAT, as a valid value.\n\n @returns #hipSuccess, #hipErrorInvalidValue\n\n @warning This API is deprecated.\n"]
    pub fn hipTexRefSetMipmappedArray(
        texRef: *mut textureReference,
        mipmappedArray: *mut hipMipmappedArray,
        Flags: ::std::os::raw::c_uint,
    ) -> hipError_t;
}
extern "C" {
    #[doc = "  @defgroup Callback Callback Activity APIs\n  @{\n  This section describes the callback/Activity of HIP runtime API.\n/\n/**\n @brief Returns HIP API name by ID.\n\n @param [in] id ID of HIP API\n\n @returns #hipSuccess, #hipErrorInvalidValue\n"]
    pub fn hipApiName(id: u32) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @brief Returns kernel name reference by function name.\n\n @param [in] f Name of function\n\n @returns #hipSuccess, #hipErrorInvalidValue\n"]
    pub fn hipKernelNameRef(f: hipFunction_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @brief Retrives kernel for a given host pointer, unless stated otherwise.\n\n @param [in] hostFunction Pointer of host function.\n @param [in] stream Stream the kernel is executed on.\n\n @returns #hipSuccess, #hipErrorInvalidValue\n"]
    pub fn hipKernelNameRefByPtr(
        hostFunction: *const ::std::os::raw::c_void,
        stream: hipStream_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @brief Returns device ID on the stream.\n\n @param [in] stream Stream of device executed on.\n\n @returns #hipSuccess, #hipErrorInvalidValue\n"]
    pub fn hipGetStreamDeviceId(stream: hipStream_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Begins graph capture on a stream.\n\n @param [in] stream - Stream to initiate capture.\n @param [in] mode - Controls the interaction of this capture sequence with other API calls that\n are not safe.\n\n @returns #hipSuccess, #hipErrorInvalidValue\n\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues.\n"]
    pub fn hipStreamBeginCapture(stream: hipStream_t, mode: hipStreamCaptureMode) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Ends capture on a stream, returning the captured graph.\n\n @param [in] stream - Stream to end capture.\n @param [out] pGraph - returns the graph captured.\n\n @returns #hipSuccess, #hipErrorInvalidValue\n\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues.\n"]
    pub fn hipStreamEndCapture(stream: hipStream_t, pGraph: *mut hipGraph_t) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Get capture status of a stream.\n\n @param [in] stream - Stream under capture.\n @param [out] pCaptureStatus - returns current status of the capture.\n @param [out] pId - unique ID of the capture.\n\n @returns #hipSuccess, #hipErrorStreamCaptureImplicit\n\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues.\n"]
    pub fn hipStreamGetCaptureInfo(
        stream: hipStream_t,
        pCaptureStatus: *mut hipStreamCaptureStatus,
        pId: *mut ::std::os::raw::c_ulonglong,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Get stream's capture state\n\n @param [in] stream - Stream under capture.\n @param [out] captureStatus_out - returns current status of the capture.\n @param [out] id_out - unique ID of the capture.\n @param [in] graph_out - returns the graph being captured into.\n @param [out] dependencies_out - returns pointer to an array of nodes.\n @param [out] numDependencies_out - returns size of the array returned in dependencies_out.\n\n @returns #hipSuccess, #hipErrorInvalidValue, #hipErrorStreamCaptureImplicit\n\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues.\n"]
    pub fn hipStreamGetCaptureInfo_v2(
        stream: hipStream_t,
        captureStatus_out: *mut hipStreamCaptureStatus,
        id_out: *mut ::std::os::raw::c_ulonglong,
        graph_out: *mut hipGraph_t,
        dependencies_out: *mut *const hipGraphNode_t,
        numDependencies_out: *mut usize,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Get stream's capture state\n\n @param [in] stream - Stream under capture.\n @param [out] pCaptureStatus - returns current status of the capture.\n\n @returns #hipSuccess, #hipErrorInvalidValue, #hipErrorStreamCaptureImplicit\n\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues.\n"]
    pub fn hipStreamIsCapturing(
        stream: hipStream_t,
        pCaptureStatus: *mut hipStreamCaptureStatus,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Update the set of dependencies in a capturing stream\n\n @param [in] stream - Stream under capture.\n @param [in] dependencies - pointer to an array of nodes to Add/Replace.\n @param [in] numDependencies - size of the array in dependencies.\n @returns #hipSuccess, #hipErrorInvalidValue, #hipErrorIllegalState\n\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues.\n"]
    pub fn hipStreamUpdateCaptureDependencies(
        stream: hipStream_t,
        dependencies: *mut hipGraphNode_t,
        numDependencies: usize,
        flags: ::std::os::raw::c_uint,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Swaps the stream capture mode of a thread.\n\n @param [in] mode - Pointer to mode value to swap with the current mode\n @returns #hipSuccess, #hipErrorInvalidValue\n\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues.\n"]
    pub fn hipThreadExchangeStreamCaptureMode(mode: *mut hipStreamCaptureMode) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Creates a graph\n\n @param [out] pGraph - pointer to graph to create.\n @param [in] flags - flags for graph creation, must be 0.\n\n @returns #hipSuccess, #hipErrorInvalidValue, #hipErrorMemoryAllocation\n\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues.\n"]
    pub fn hipGraphCreate(pGraph: *mut hipGraph_t, flags: ::std::os::raw::c_uint) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Destroys a graph\n\n @param [in] graph - instance of graph to destroy.\n\n @returns #hipSuccess, #hipErrorInvalidValue\n\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues.\n"]
    pub fn hipGraphDestroy(graph: hipGraph_t) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Adds dependency edges to a graph.\n\n @param [in] graph - instance of the graph to add dependencies.\n @param [in] from - pointer to the graph nodes with dependenties to add from.\n @param [in] to - pointer to the graph nodes to add dependenties to.\n @param [in] numDependencies - the number of dependencies to add.\n @returns #hipSuccess, #hipErrorInvalidValue\n\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues.\n"]
    pub fn hipGraphAddDependencies(
        graph: hipGraph_t,
        from: *const hipGraphNode_t,
        to: *const hipGraphNode_t,
        numDependencies: usize,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Removes dependency edges from a graph.\n\n @param [in] graph - instance of the graph to remove dependencies.\n @param [in] from - Array of nodes that provide the dependencies.\n @param [in] to - Array of dependent nodes.\n @param [in] numDependencies - the number of dependencies to remove.\n @returns #hipSuccess, #hipErrorInvalidValue\n\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues.\n"]
    pub fn hipGraphRemoveDependencies(
        graph: hipGraph_t,
        from: *const hipGraphNode_t,
        to: *const hipGraphNode_t,
        numDependencies: usize,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Returns a graph's dependency edges.\n\n @param [in] graph - instance of the graph to get the edges from.\n @param [out] from - pointer to the graph nodes to return edge endpoints.\n @param [out] to - pointer to the graph nodes to return edge endpoints.\n @param [out] numEdges - returns number of edges.\n @returns #hipSuccess, #hipErrorInvalidValue\n\n from and to may both be NULL, in which case this function only returns the number of edges in\n numEdges. Otherwise, numEdges entries will be filled in. If numEdges is higher than the actual\n number of edges, the remaining entries in from and to will be set to NULL, and the number of\n edges actually returned will be written to numEdges\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues.\n"]
    pub fn hipGraphGetEdges(
        graph: hipGraph_t,
        from: *mut hipGraphNode_t,
        to: *mut hipGraphNode_t,
        numEdges: *mut usize,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Returns graph nodes.\n\n @param [in] graph - instance of graph to get the nodes.\n @param [out] nodes - pointer to return the  graph nodes.\n @param [out] numNodes - returns number of graph nodes.\n @returns #hipSuccess, #hipErrorInvalidValue\n\n nodes may be NULL, in which case this function will return the number of nodes in numNodes.\n Otherwise, numNodes entries will be filled in. If numNodes is higher than the actual number of\n nodes, the remaining entries in nodes will be set to NULL, and the number of nodes actually\n obtained will be returned in numNodes.\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues.\n"]
    pub fn hipGraphGetNodes(
        graph: hipGraph_t,
        nodes: *mut hipGraphNode_t,
        numNodes: *mut usize,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Returns graph's root nodes.\n\n @param [in] graph - instance of the graph to get the nodes.\n @param [out] pRootNodes - pointer to return the graph's root nodes.\n @param [out] pNumRootNodes - returns the number of graph's root nodes.\n @returns #hipSuccess, #hipErrorInvalidValue\n\n pRootNodes may be NULL, in which case this function will return the number of root nodes in\n pNumRootNodes. Otherwise, pNumRootNodes entries will be filled in. If pNumRootNodes is higher\n than the actual number of root nodes, the remaining entries in pRootNodes will be set to NULL,\n and the number of nodes actually obtained will be returned in pNumRootNodes.\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues.\n"]
    pub fn hipGraphGetRootNodes(
        graph: hipGraph_t,
        pRootNodes: *mut hipGraphNode_t,
        pNumRootNodes: *mut usize,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Returns a node's dependencies.\n\n @param [in] node - graph node to get the dependencies from.\n @param [out] pDependencies - pointer to to return the dependencies.\n @param [out] pNumDependencies -  returns the number of graph node dependencies.\n @returns #hipSuccess, #hipErrorInvalidValue\n\n pDependencies may be NULL, in which case this function will return the number of dependencies in\n pNumDependencies. Otherwise, pNumDependencies entries will be filled in. If pNumDependencies is\n higher than the actual number of dependencies, the remaining entries in pDependencies will be set\n to NULL, and the number of nodes actually obtained will be returned in pNumDependencies.\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues.\n"]
    pub fn hipGraphNodeGetDependencies(
        node: hipGraphNode_t,
        pDependencies: *mut hipGraphNode_t,
        pNumDependencies: *mut usize,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Returns a node's dependent nodes.\n\n @param [in] node - graph node to get the Dependent nodes from.\n @param [out] pDependentNodes - pointer to return the graph dependent nodes.\n @param [out] pNumDependentNodes - returns the number of graph node dependent nodes.\n @returns #hipSuccess, #hipErrorInvalidValue\n\n DependentNodes may be NULL, in which case this function will return the number of dependent nodes\n in pNumDependentNodes. Otherwise, pNumDependentNodes entries will be filled in. If\n pNumDependentNodes is higher than the actual number of dependent nodes, the remaining entries in\n pDependentNodes will be set to NULL, and the number of nodes actually obtained will be returned\n in pNumDependentNodes.\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues.\n"]
    pub fn hipGraphNodeGetDependentNodes(
        node: hipGraphNode_t,
        pDependentNodes: *mut hipGraphNode_t,
        pNumDependentNodes: *mut usize,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Returns a node's type.\n\n @param [in] node - instance of the graph to add dependencies.\n @param [out] pType - pointer to the return the type\n @returns #hipSuccess, #hipErrorInvalidValue\n\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues.\n"]
    pub fn hipGraphNodeGetType(node: hipGraphNode_t, pType: *mut hipGraphNodeType) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Remove a node from the graph.\n\n @param [in] node - graph node to remove\n @returns #hipSuccess, #hipErrorInvalidValue\n\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues.\n"]
    pub fn hipGraphDestroyNode(node: hipGraphNode_t) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Clones a graph.\n\n @param [out] pGraphClone - Returns newly created cloned graph.\n @param [in] originalGraph - original graph to clone from.\n @returns #hipSuccess, #hipErrorInvalidValue, #hipErrorMemoryAllocation\n\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues.\n"]
    pub fn hipGraphClone(pGraphClone: *mut hipGraph_t, originalGraph: hipGraph_t) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Finds a cloned version of a node.\n\n @param [out] pNode - Returns the cloned node.\n @param [in] originalNode - original node handle.\n @param [in] clonedGraph - Cloned graph to query.\n @returns #hipSuccess, #hipErrorInvalidValue\n\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues.\n"]
    pub fn hipGraphNodeFindInClone(
        pNode: *mut hipGraphNode_t,
        originalNode: hipGraphNode_t,
        clonedGraph: hipGraph_t,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Creates an executable graph from a graph\n\n @param [out] pGraphExec - pointer to instantiated executable graph that is created.\n @param [in] graph - instance of graph to instantiate.\n @param [out] pErrorNode - pointer to error node in case error occured in graph instantiation,\n  it could modify the correponding node.\n @param [out] pLogBuffer - pointer to log buffer.\n @param [out] bufferSize - the size of log buffer.\n\n @returns #hipSuccess, #hipErrorOutOfMemory\n\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues.\n"]
    pub fn hipGraphInstantiate(
        pGraphExec: *mut hipGraphExec_t,
        graph: hipGraph_t,
        pErrorNode: *mut hipGraphNode_t,
        pLogBuffer: *mut ::std::os::raw::c_char,
        bufferSize: usize,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Creates an executable graph from a graph.\n\n @param [out] pGraphExec - pointer to instantiated executable graph that is created.\n @param [in] graph - instance of graph to instantiate.\n @param [in] flags - Flags to control instantiation.\n @returns #hipSuccess, #hipErrorInvalidValue\n\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues.It does not support\n any of flag and is behaving as hipGraphInstantiate."]
    pub fn hipGraphInstantiateWithFlags(
        pGraphExec: *mut hipGraphExec_t,
        graph: hipGraph_t,
        flags: ::std::os::raw::c_ulonglong,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief launches an executable graph in a stream\n\n @param [in] graphExec - instance of executable graph to launch.\n @param [in] stream - instance of stream in which to launch executable graph.\n @returns #hipSuccess, #hipErrorInvalidValue\n\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues."]
    pub fn hipGraphLaunch(graphExec: hipGraphExec_t, stream: hipStream_t) -> hipError_t;
}
extern "C" {
    #[doc = " @brief uploads an executable graph in a stream\n\n @param [in] graphExec - instance of executable graph to launch.\n @param [in] stream - instance of stream in which to launch executable graph.\n @returns #hipSuccess, #hipErrorInvalidValue\n\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues."]
    pub fn hipGraphUpload(graphExec: hipGraphExec_t, stream: hipStream_t) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Destroys an executable graph\n\n @param [in] graphExec - instance of executable graph to destry.\n\n @returns #hipSuccess.\n\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues."]
    pub fn hipGraphExecDestroy(graphExec: hipGraphExec_t) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Check whether an executable graph can be updated with a graph and perform the update if  *\n possible.\n\n @param [in] hGraphExec - instance of executable graph to update.\n @param [in] hGraph - graph that contains the updated parameters.\n @param [in] hErrorNode_out -  node which caused the permissibility check to forbid the update.\n @param [in] updateResult_out - Whether the graph update was permitted.\n @returns #hipSuccess, #hipErrorGraphExecUpdateFailure\n\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues."]
    pub fn hipGraphExecUpdate(
        hGraphExec: hipGraphExec_t,
        hGraph: hipGraph_t,
        hErrorNode_out: *mut hipGraphNode_t,
        updateResult_out: *mut hipGraphExecUpdateResult,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Creates a kernel execution node and adds it to a graph.\n\n @param [out] pGraphNode - pointer to graph node to create.\n @param [in] graph - instance of graph to add the created node.\n @param [in] pDependencies - pointer to the dependencies on the kernel execution node.\n @param [in] numDependencies - the number of the dependencies.\n @param [in] pNodeParams - pointer to the parameters to the kernel execution node on the GPU.\n @returns #hipSuccess, #hipErrorInvalidValue, #hipErrorInvalidDeviceFunction\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues."]
    pub fn hipGraphAddKernelNode(
        pGraphNode: *mut hipGraphNode_t,
        graph: hipGraph_t,
        pDependencies: *const hipGraphNode_t,
        numDependencies: usize,
        pNodeParams: *const hipKernelNodeParams,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Gets kernel node's parameters.\n\n @param [in] node - instance of the node to get parameters from.\n @param [out] pNodeParams - pointer to the parameters\n @returns #hipSuccess, #hipErrorInvalidValue\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues."]
    pub fn hipGraphKernelNodeGetParams(
        node: hipGraphNode_t,
        pNodeParams: *mut hipKernelNodeParams,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Sets a kernel node's parameters.\n\n @param [in] node - instance of the node to set parameters to.\n @param [in] pNodeParams - const pointer to the parameters.\n @returns #hipSuccess, #hipErrorInvalidValue\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues."]
    pub fn hipGraphKernelNodeSetParams(
        node: hipGraphNode_t,
        pNodeParams: *const hipKernelNodeParams,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Sets the parameters for a kernel node in the given graphExec.\n\n @param [in] hGraphExec - instance of the executable graph with the node.\n @param [in] node - instance of the node to set parameters to.\n @param [in] pNodeParams - const pointer to the kernel node parameters.\n @returns #hipSuccess, #hipErrorInvalidValue\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues."]
    pub fn hipGraphExecKernelNodeSetParams(
        hGraphExec: hipGraphExec_t,
        node: hipGraphNode_t,
        pNodeParams: *const hipKernelNodeParams,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Creates a memcpy node and adds it to a graph.\n\n @param [out] phGraphNode - pointer to graph node to create.\n @param [in] hGraph - instance of graph to add the created node.\n @param [in] dependencies - const pointer to the dependencies on the memcpy execution node.\n @param [in] numDependencies - the number of the dependencies.\n @param [in] copyParams - const pointer to the parameters for the memory copy.\n @param [in] ctx - cotext related to current device.\n @returns #hipSuccess, #hipErrorInvalidValue\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues."]
    pub fn hipDrvGraphAddMemcpyNode(
        phGraphNode: *mut hipGraphNode_t,
        hGraph: hipGraph_t,
        dependencies: *const hipGraphNode_t,
        numDependencies: usize,
        copyParams: *const HIP_MEMCPY3D,
        ctx: hipCtx_t,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Creates a memcpy node and adds it to a graph.\n\n @param [out] pGraphNode - pointer to graph node to create.\n @param [in] graph - instance of graph to add the created node.\n @param [in] pDependencies - const pointer to the dependencies on the memcpy execution node.\n @param [in] numDependencies - the number of the dependencies.\n @param [in] pCopyParams - const pointer to the parameters for the memory copy.\n @returns #hipSuccess, #hipErrorInvalidValue\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues."]
    pub fn hipGraphAddMemcpyNode(
        pGraphNode: *mut hipGraphNode_t,
        graph: hipGraph_t,
        pDependencies: *const hipGraphNode_t,
        numDependencies: usize,
        pCopyParams: *const hipMemcpy3DParms,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Gets a memcpy node's parameters.\n\n @param [in] node - instance of the node to get parameters from.\n @param [out] pNodeParams - pointer to the parameters.\n @returns #hipSuccess, #hipErrorInvalidValue\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues."]
    pub fn hipGraphMemcpyNodeGetParams(
        node: hipGraphNode_t,
        pNodeParams: *mut hipMemcpy3DParms,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Sets a memcpy node's parameters.\n\n @param [in] node - instance of the node to set parameters to.\n @param [in] pNodeParams - const pointer to the parameters.\n @returns #hipSuccess, #hipErrorInvalidValue\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues."]
    pub fn hipGraphMemcpyNodeSetParams(
        node: hipGraphNode_t,
        pNodeParams: *const hipMemcpy3DParms,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Sets a node attribute.\n\n @param [in] hNode - instance of the node to set parameters to.\n @param [in] attr - the attribute node is set to.\n @param [in] value - const pointer to the parameters.\n @returns #hipSuccess, #hipErrorInvalidValue\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues."]
    pub fn hipGraphKernelNodeSetAttribute(
        hNode: hipGraphNode_t,
        attr: hipKernelNodeAttrID,
        value: *const hipKernelNodeAttrValue,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Gets a node attribute.\n\n @param [in] hNode - instance of the node to set parameters to.\n @param [in] attr - the attribute node is set to.\n @param [in] value - const pointer to the parameters.\n @returns #hipSuccess, #hipErrorInvalidValue\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues."]
    pub fn hipGraphKernelNodeGetAttribute(
        hNode: hipGraphNode_t,
        attr: hipKernelNodeAttrID,
        value: *mut hipKernelNodeAttrValue,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Sets the parameters for a memcpy node in the given graphExec.\n\n @param [in] hGraphExec - instance of the executable graph with the node.\n @param [in] node - instance of the node to set parameters to.\n @param [in] pNodeParams - const pointer to the kernel node parameters.\n @returns #hipSuccess, #hipErrorInvalidValue\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues."]
    pub fn hipGraphExecMemcpyNodeSetParams(
        hGraphExec: hipGraphExec_t,
        node: hipGraphNode_t,
        pNodeParams: *mut hipMemcpy3DParms,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Creates a 1D memcpy node and adds it to a graph.\n\n @param [out] pGraphNode - pointer to graph node to create.\n @param [in] graph - instance of graph to add the created node.\n @param [in] pDependencies - const pointer to the dependencies on the memcpy execution node.\n @param [in] numDependencies - the number of the dependencies.\n @param [in] dst - pointer to memory address to the destination.\n @param [in] src - pointer to memory address to the source.\n @param [in] count - the size of the memory to copy.\n @param [in] kind - the type of memory copy.\n @returns #hipSuccess, #hipErrorInvalidValue\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues."]
    pub fn hipGraphAddMemcpyNode1D(
        pGraphNode: *mut hipGraphNode_t,
        graph: hipGraph_t,
        pDependencies: *const hipGraphNode_t,
        numDependencies: usize,
        dst: *mut ::std::os::raw::c_void,
        src: *const ::std::os::raw::c_void,
        count: usize,
        kind: hipMemcpyKind,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Sets a memcpy node's parameters to perform a 1-dimensional copy.\n\n @param [in] node - instance of the node to set parameters to.\n @param [in] dst - pointer to memory address to the destination.\n @param [in] src - pointer to memory address to the source.\n @param [in] count - the size of the memory to copy.\n @param [in] kind - the type of memory copy.\n @returns #hipSuccess, #hipErrorInvalidValue\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues."]
    pub fn hipGraphMemcpyNodeSetParams1D(
        node: hipGraphNode_t,
        dst: *mut ::std::os::raw::c_void,
        src: *const ::std::os::raw::c_void,
        count: usize,
        kind: hipMemcpyKind,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Sets the parameters for a memcpy node in the given graphExec to perform a 1-dimensional\n copy.\n\n @param [in] hGraphExec - instance of the executable graph with the node.\n @param [in] node - instance of the node to set parameters to.\n @param [in] dst - pointer to memory address to the destination.\n @param [in] src - pointer to memory address to the source.\n @param [in] count - the size of the memory to copy.\n @param [in] kind - the type of memory copy.\n @returns #hipSuccess, #hipErrorInvalidValue\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues."]
    pub fn hipGraphExecMemcpyNodeSetParams1D(
        hGraphExec: hipGraphExec_t,
        node: hipGraphNode_t,
        dst: *mut ::std::os::raw::c_void,
        src: *const ::std::os::raw::c_void,
        count: usize,
        kind: hipMemcpyKind,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Creates a memcpy node to copy from a symbol on the device and adds it to a graph.\n\n @param [out] pGraphNode - pointer to graph node to create.\n @param [in] graph - instance of graph to add the created node.\n @param [in] pDependencies - const pointer to the dependencies on the memcpy execution node.\n @param [in] numDependencies - the number of the dependencies.\n @param [in] dst - pointer to memory address to the destination.\n @param [in] symbol - Device symbol address.\n @param [in] count - the size of the memory to copy.\n @param [in] offset - Offset from start of symbol in bytes.\n @param [in] kind - the type of memory copy.\n @returns #hipSuccess, #hipErrorInvalidValue\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues."]
    pub fn hipGraphAddMemcpyNodeFromSymbol(
        pGraphNode: *mut hipGraphNode_t,
        graph: hipGraph_t,
        pDependencies: *const hipGraphNode_t,
        numDependencies: usize,
        dst: *mut ::std::os::raw::c_void,
        symbol: *const ::std::os::raw::c_void,
        count: usize,
        offset: usize,
        kind: hipMemcpyKind,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Sets a memcpy node's parameters to copy from a symbol on the device.\n\n @param [in] node - instance of the node to set parameters to.\n @param [in] dst - pointer to memory address to the destination.\n @param [in] symbol - Device symbol address.\n @param [in] count - the size of the memory to copy.\n @param [in] offset - Offset from start of symbol in bytes.\n @param [in] kind - the type of memory copy.\n @returns #hipSuccess, #hipErrorInvalidValue\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues."]
    pub fn hipGraphMemcpyNodeSetParamsFromSymbol(
        node: hipGraphNode_t,
        dst: *mut ::std::os::raw::c_void,
        symbol: *const ::std::os::raw::c_void,
        count: usize,
        offset: usize,
        kind: hipMemcpyKind,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Sets the parameters for a memcpy node in the given graphExec to copy from a symbol on the\n * device.\n\n @param [in] hGraphExec - instance of the executable graph with the node.\n @param [in] node - instance of the node to set parameters to.\n @param [in] dst - pointer to memory address to the destination.\n @param [in] symbol - Device symbol address.\n @param [in] count - the size of the memory to copy.\n @param [in] offset - Offset from start of symbol in bytes.\n @param [in] kind - the type of memory copy.\n @returns #hipSuccess, #hipErrorInvalidValue\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues."]
    pub fn hipGraphExecMemcpyNodeSetParamsFromSymbol(
        hGraphExec: hipGraphExec_t,
        node: hipGraphNode_t,
        dst: *mut ::std::os::raw::c_void,
        symbol: *const ::std::os::raw::c_void,
        count: usize,
        offset: usize,
        kind: hipMemcpyKind,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Creates a memcpy node to copy to a symbol on the device and adds it to a graph.\n\n @param [out] pGraphNode - pointer to graph node to create.\n @param [in] graph - instance of graph to add the created node.\n @param [in] pDependencies - const pointer to the dependencies on the memcpy execution node.\n @param [in] numDependencies - the number of the dependencies.\n @param [in] symbol - Device symbol address.\n @param [in] src - pointer to memory address of the src.\n @param [in] count - the size of the memory to copy.\n @param [in] offset - Offset from start of symbol in bytes.\n @param [in] kind - the type of memory copy.\n @returns #hipSuccess, #hipErrorInvalidValue\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues."]
    pub fn hipGraphAddMemcpyNodeToSymbol(
        pGraphNode: *mut hipGraphNode_t,
        graph: hipGraph_t,
        pDependencies: *const hipGraphNode_t,
        numDependencies: usize,
        symbol: *const ::std::os::raw::c_void,
        src: *const ::std::os::raw::c_void,
        count: usize,
        offset: usize,
        kind: hipMemcpyKind,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Sets a memcpy node's parameters to copy to a symbol on the device.\n\n @param [in] node - instance of the node to set parameters to.\n @param [in] symbol - Device symbol address.\n @param [in] src - pointer to memory address of the src.\n @param [in] count - the size of the memory to copy.\n @param [in] offset - Offset from start of symbol in bytes.\n @param [in] kind - the type of memory copy.\n @returns #hipSuccess, #hipErrorInvalidValue\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues."]
    pub fn hipGraphMemcpyNodeSetParamsToSymbol(
        node: hipGraphNode_t,
        symbol: *const ::std::os::raw::c_void,
        src: *const ::std::os::raw::c_void,
        count: usize,
        offset: usize,
        kind: hipMemcpyKind,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Sets the parameters for a memcpy node in the given graphExec to copy to a symbol on the\n device.\n @param [in] hGraphExec - instance of the executable graph with the node.\n @param [in] node - instance of the node to set parameters to.\n @param [in] symbol - Device symbol address.\n @param [in] src - pointer to memory address of the src.\n @param [in] count - the size of the memory to copy.\n @param [in] offset - Offset from start of symbol in bytes.\n @param [in] kind - the type of memory copy.\n @returns #hipSuccess, #hipErrorInvalidValue\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues."]
    pub fn hipGraphExecMemcpyNodeSetParamsToSymbol(
        hGraphExec: hipGraphExec_t,
        node: hipGraphNode_t,
        symbol: *const ::std::os::raw::c_void,
        src: *const ::std::os::raw::c_void,
        count: usize,
        offset: usize,
        kind: hipMemcpyKind,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Creates a memset node and adds it to a graph.\n\n @param [out] pGraphNode - pointer to the graph node to create.\n @param [in] graph - instance of the graph to add the created node.\n @param [in] pDependencies - const pointer to the dependencies on the memset execution node.\n @param [in] numDependencies - the number of the dependencies.\n @param [in] pMemsetParams - const pointer to the parameters for the memory set.\n @returns #hipSuccess, #hipErrorInvalidValue\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues."]
    pub fn hipGraphAddMemsetNode(
        pGraphNode: *mut hipGraphNode_t,
        graph: hipGraph_t,
        pDependencies: *const hipGraphNode_t,
        numDependencies: usize,
        pMemsetParams: *const hipMemsetParams,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Gets a memset node's parameters.\n\n @param [in] node - instane of the node to get parameters from.\n @param [out] pNodeParams - pointer to the parameters.\n @returns #hipSuccess, #hipErrorInvalidValue\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues."]
    pub fn hipGraphMemsetNodeGetParams(
        node: hipGraphNode_t,
        pNodeParams: *mut hipMemsetParams,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Sets a memset node's parameters.\n\n @param [in] node - instance of the node to set parameters to.\n @param [in] pNodeParams - pointer to the parameters.\n @returns #hipSuccess, #hipErrorInvalidValue\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues."]
    pub fn hipGraphMemsetNodeSetParams(
        node: hipGraphNode_t,
        pNodeParams: *const hipMemsetParams,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Sets the parameters for a memset node in the given graphExec.\n\n @param [in] hGraphExec - instance of the executable graph with the node.\n @param [in] node - instance of the node to set parameters to.\n @param [in] pNodeParams - pointer to the parameters.\n @returns #hipSuccess, #hipErrorInvalidValue\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues."]
    pub fn hipGraphExecMemsetNodeSetParams(
        hGraphExec: hipGraphExec_t,
        node: hipGraphNode_t,
        pNodeParams: *const hipMemsetParams,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Creates a host execution node and adds it to a graph.\n\n @param [out] pGraphNode - pointer to the graph node to create.\n @param [in] graph - instance of the graph to add the created node.\n @param [in] pDependencies - const pointer to the dependencies on the memset execution node.\n @param [in] numDependencies - the number of the dependencies.\n @param [in] pNodeParams -pointer to the parameters.\n @returns #hipSuccess, #hipErrorInvalidValue\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues."]
    pub fn hipGraphAddHostNode(
        pGraphNode: *mut hipGraphNode_t,
        graph: hipGraph_t,
        pDependencies: *const hipGraphNode_t,
        numDependencies: usize,
        pNodeParams: *const hipHostNodeParams,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Returns a host node's parameters.\n\n @param [in] node - instane of the node to get parameters from.\n @param [out] pNodeParams - pointer to the parameters.\n @returns #hipSuccess, #hipErrorInvalidValue\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues."]
    pub fn hipGraphHostNodeGetParams(
        node: hipGraphNode_t,
        pNodeParams: *mut hipHostNodeParams,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Sets a host node's parameters.\n\n @param [in] node - instance of the node to set parameters to.\n @param [in] pNodeParams - pointer to the parameters.\n @returns #hipSuccess, #hipErrorInvalidValue\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues."]
    pub fn hipGraphHostNodeSetParams(
        node: hipGraphNode_t,
        pNodeParams: *const hipHostNodeParams,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Sets the parameters for a host node in the given graphExec.\n\n @param [in] hGraphExec - instance of the executable graph with the node.\n @param [in] node - instance of the node to set parameters to.\n @param [in] pNodeParams - pointer to the parameters.\n @returns #hipSuccess, #hipErrorInvalidValue\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues."]
    pub fn hipGraphExecHostNodeSetParams(
        hGraphExec: hipGraphExec_t,
        node: hipGraphNode_t,
        pNodeParams: *const hipHostNodeParams,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Creates a child graph node and adds it to a graph.\n\n @param [out] pGraphNode - pointer to the graph node to create.\n @param [in] graph - instance of the graph to add the created node.\n @param [in] pDependencies - const pointer to the dependencies on the memset execution node.\n @param [in] numDependencies - the number of the dependencies.\n @param [in] childGraph - the graph to clone into this node\n @returns #hipSuccess, #hipErrorInvalidValue\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues."]
    pub fn hipGraphAddChildGraphNode(
        pGraphNode: *mut hipGraphNode_t,
        graph: hipGraph_t,
        pDependencies: *const hipGraphNode_t,
        numDependencies: usize,
        childGraph: hipGraph_t,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Gets a handle to the embedded graph of a child graph node.\n\n @param [in] node - instane of the node to get child graph.\n @param [out] pGraph - pointer to get the graph.\n @returns #hipSuccess, #hipErrorInvalidValue\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues."]
    pub fn hipGraphChildGraphNodeGetGraph(
        node: hipGraphNode_t,
        pGraph: *mut hipGraph_t,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Updates node parameters in the child graph node in the given graphExec.\n\n @param [in] hGraphExec - instance of the executable graph with the node.\n @param [in] node - node from the graph which was used to instantiate graphExec.\n @param [in] childGraph - child graph with updated parameters.\n @returns #hipSuccess, #hipErrorInvalidValue\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues."]
    pub fn hipGraphExecChildGraphNodeSetParams(
        hGraphExec: hipGraphExec_t,
        node: hipGraphNode_t,
        childGraph: hipGraph_t,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Creates an empty node and adds it to a graph.\n\n @param [out] pGraphNode - pointer to the graph node to create and add to the graph.\n @param [in] graph - instane of the graph the node is add to.\n @param [in] pDependencies - const pointer to the node dependenties.\n @param [in] numDependencies - the number of dependencies.\n @returns #hipSuccess, #hipErrorInvalidValue\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues."]
    pub fn hipGraphAddEmptyNode(
        pGraphNode: *mut hipGraphNode_t,
        graph: hipGraph_t,
        pDependencies: *const hipGraphNode_t,
        numDependencies: usize,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Creates an event record node and adds it to a graph.\n\n @param [out] pGraphNode - pointer to the graph node to create and add to the graph.\n @param [in] graph - instane of the graph the node to be added.\n @param [in] pDependencies - const pointer to the node dependenties.\n @param [in] numDependencies - the number of dependencies.\n @param [in] event - Event for the node.\n @returns #hipSuccess, #hipErrorInvalidValue\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues."]
    pub fn hipGraphAddEventRecordNode(
        pGraphNode: *mut hipGraphNode_t,
        graph: hipGraph_t,
        pDependencies: *const hipGraphNode_t,
        numDependencies: usize,
        event: hipEvent_t,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Returns the event associated with an event record node.\n\n @param [in] node -  instane of the node to get event from.\n @param [out] event_out - Pointer to return the event.\n @returns #hipSuccess, #hipErrorInvalidValue\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues."]
    pub fn hipGraphEventRecordNodeGetEvent(
        node: hipGraphNode_t,
        event_out: *mut hipEvent_t,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Sets an event record node's event.\n\n @param [in] node - instane of the node to set event to.\n @param [in] event - pointer to the event.\n @returns #hipSuccess, #hipErrorInvalidValue\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues."]
    pub fn hipGraphEventRecordNodeSetEvent(node: hipGraphNode_t, event: hipEvent_t) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Sets the event for an event record node in the given graphExec.\n\n @param [in] hGraphExec - instance of the executable graph with the node.\n @param [in] hNode - node from the graph which was used to instantiate graphExec.\n @param [in] event - pointer to the event.\n @returns #hipSuccess, #hipErrorInvalidValue\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues."]
    pub fn hipGraphExecEventRecordNodeSetEvent(
        hGraphExec: hipGraphExec_t,
        hNode: hipGraphNode_t,
        event: hipEvent_t,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Creates an event wait node and adds it to a graph.\n\n @param [out] pGraphNode - pointer to the graph node to create and add to the graph.\n @param [in] graph - instane of the graph the node to be added.\n @param [in] pDependencies - const pointer to the node dependenties.\n @param [in] numDependencies - the number of dependencies.\n @param [in] event - Event for the node.\n @returns #hipSuccess, #hipErrorInvalidValue\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues."]
    pub fn hipGraphAddEventWaitNode(
        pGraphNode: *mut hipGraphNode_t,
        graph: hipGraph_t,
        pDependencies: *const hipGraphNode_t,
        numDependencies: usize,
        event: hipEvent_t,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Returns the event associated with an event wait node.\n\n @param [in] node -  instane of the node to get event from.\n @param [out] event_out - Pointer to return the event.\n @returns #hipSuccess, #hipErrorInvalidValue\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues."]
    pub fn hipGraphEventWaitNodeGetEvent(
        node: hipGraphNode_t,
        event_out: *mut hipEvent_t,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Sets an event wait node's event.\n\n @param [in] node - instane of the node to set event to.\n @param [in] event - pointer to the event.\n @returns #hipSuccess, #hipErrorInvalidValue\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues."]
    pub fn hipGraphEventWaitNodeSetEvent(node: hipGraphNode_t, event: hipEvent_t) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Sets the event for an event record node in the given graphExec.\n\n @param [in] hGraphExec - instance of the executable graph with the node.\n @param [in] hNode - node from the graph which was used to instantiate graphExec.\n @param [in] event - pointer to the event.\n @returns #hipSuccess, #hipErrorInvalidValue\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues."]
    pub fn hipGraphExecEventWaitNodeSetEvent(
        hGraphExec: hipGraphExec_t,
        hNode: hipGraphNode_t,
        event: hipEvent_t,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Creates a memory allocation node and adds it to a graph\n\n @param [out] pGraphNode      - Pointer to the graph node to create and add to the graph\n @param [in] graph            - Instane of the graph the node to be added\n @param [in] pDependencies    - Const pointer to the node dependenties\n @param [in] numDependencies  - The number of dependencies\n @param [in] pNodeParams      - Node parameters for memory allocation\n @returns #hipSuccess, #hipErrorInvalidValue\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues."]
    pub fn hipGraphAddMemAllocNode(
        pGraphNode: *mut hipGraphNode_t,
        graph: hipGraph_t,
        pDependencies: *const hipGraphNode_t,
        numDependencies: usize,
        pNodeParams: *mut hipMemAllocNodeParams,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Returns parameters for memory allocation node\n\n @param [in] node         - Memory allocation node for a query\n @param [out] pNodeParams - Parameters for the specified memory allocation node\n @returns #hipSuccess, #hipErrorInvalidValue\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues."]
    pub fn hipGraphMemAllocNodeGetParams(
        node: hipGraphNode_t,
        pNodeParams: *mut hipMemAllocNodeParams,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Creates a memory free node and adds it to a graph\n\n @param [out] pGraphNode      - Pointer to the graph node to create and add to the graph\n @param [in] graph            - Instane of the graph the node to be added\n @param [in] pDependencies    - Const pointer to the node dependenties\n @param [in] numDependencies  - The number of dependencies\n @param [in] dev_ptr          - Pointer to the memory to be freed\n @returns #hipSuccess, #hipErrorInvalidValue\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues."]
    pub fn hipGraphAddMemFreeNode(
        pGraphNode: *mut hipGraphNode_t,
        graph: hipGraph_t,
        pDependencies: *const hipGraphNode_t,
        numDependencies: usize,
        dev_ptr: *mut ::std::os::raw::c_void,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Returns parameters for memory free node\n\n @param [in] node     - Memory free node for a query\n @param [out] dev_ptr - Device pointer for the specified memory free node\n @returns #hipSuccess, #hipErrorInvalidValue\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues."]
    pub fn hipGraphMemFreeNodeGetParams(
        node: hipGraphNode_t,
        dev_ptr: *mut ::std::os::raw::c_void,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Get the mem attribute for graphs.\n\n @param [in] device - device the attr is get for.\n @param [in] attr - attr to get.\n @param [out] value - value for specific attr.\n @returns #hipSuccess, #hipErrorInvalidDevice\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues."]
    pub fn hipDeviceGetGraphMemAttribute(
        device: ::std::os::raw::c_int,
        attr: hipGraphMemAttributeType,
        value: *mut ::std::os::raw::c_void,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Set the mem attribute for graphs.\n\n @param [in] device - device the attr is set for.\n @param [in] attr - attr to set.\n @param [in] value - value for specific attr.\n @returns #hipSuccess, #hipErrorInvalidDevice\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues."]
    pub fn hipDeviceSetGraphMemAttribute(
        device: ::std::os::raw::c_int,
        attr: hipGraphMemAttributeType,
        value: *mut ::std::os::raw::c_void,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Free unused memory on specific device used for graph back to OS.\n\n @param [in] device - device the memory is used for graphs\n @returns #hipSuccess, #hipErrorInvalidDevice\n\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues."]
    pub fn hipDeviceGraphMemTrim(device: ::std::os::raw::c_int) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Create an instance of userObject to manage lifetime of a resource.\n\n @param [out] object_out - pointer to instace of userobj.\n @param [in] ptr - pointer to pass to destroy function.\n @param [in] destroy - destroy callback to remove resource.\n @param [in] initialRefcount - reference to resource.\n @param [in] flags - flags passed to API.\n @returns #hipSuccess, #hipErrorInvalidValue\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues."]
    pub fn hipUserObjectCreate(
        object_out: *mut hipUserObject_t,
        ptr: *mut ::std::os::raw::c_void,
        destroy: hipHostFn_t,
        initialRefcount: ::std::os::raw::c_uint,
        flags: ::std::os::raw::c_uint,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Release number of references to resource.\n\n @param [in] object - pointer to instace of userobj.\n @param [in] count - reference to resource to be retained.\n @returns #hipSuccess, #hipErrorInvalidValue\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues."]
    pub fn hipUserObjectRelease(
        object: hipUserObject_t,
        count: ::std::os::raw::c_uint,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Retain number of references to resource.\n\n @param [in] object - pointer to instace of userobj.\n @param [in] count - reference to resource to be retained.\n @returns #hipSuccess, #hipErrorInvalidValue\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues."]
    pub fn hipUserObjectRetain(
        object: hipUserObject_t,
        count: ::std::os::raw::c_uint,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Retain user object for graphs.\n\n @param [in] graph - pointer to graph to retain the user object for.\n @param [in] object - pointer to instace of userobj.\n @param [in] count - reference to resource to be retained.\n @param [in] flags - flags passed to API.\n @returns #hipSuccess, #hipErrorInvalidValue\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues."]
    pub fn hipGraphRetainUserObject(
        graph: hipGraph_t,
        object: hipUserObject_t,
        count: ::std::os::raw::c_uint,
        flags: ::std::os::raw::c_uint,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Release user object from graphs.\n\n @param [in] graph - pointer to graph to retain the user object for.\n @param [in] object - pointer to instace of userobj.\n @param [in] count - reference to resource to be retained.\n @returns #hipSuccess, #hipErrorInvalidValue\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues."]
    pub fn hipGraphReleaseUserObject(
        graph: hipGraph_t,
        object: hipUserObject_t,
        count: ::std::os::raw::c_uint,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Write a DOT file describing graph structure.\n\n @param [in] graph - graph object for which DOT file has to be generated.\n @param [in] path - path to write the DOT file.\n @param [in] flags - Flags from hipGraphDebugDotFlags to get additional node information.\n @returns #hipSuccess, #hipErrorInvalidValue, #hipErrorOperatingSystem\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues."]
    pub fn hipGraphDebugDotPrint(
        graph: hipGraph_t,
        path: *const ::std::os::raw::c_char,
        flags: ::std::os::raw::c_uint,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Copies attributes from source node to destination node.\n\n Copies attributes from source node to destination node.\n Both node must have the same context.\n\n @param [out] hDst - Destination node.\n @param [in] hSrc - Source node.\n For list of attributes see ::hipKernelNodeAttrID.\n\n @returns #hipSuccess, #hipErrorInvalidContext\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues."]
    pub fn hipGraphKernelNodeCopyAttributes(
        hSrc: hipGraphNode_t,
        hDst: hipGraphNode_t,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Enables or disables the specified node in the given graphExec\n\n Sets hNode to be either enabled or disabled. Disabled nodes are functionally equivalent\n to empty nodes until they are reenabled. Existing node parameters are not affected by\n disabling/enabling the node.\n\n The node is identified by the corresponding hNode in the non-executable graph, from which the\n executable graph was instantiated.\n\n hNode must not have been removed from the original graph.\n\n @note Currently only kernel, memset and memcpy nodes are supported.\n\n @param [in] hGraphExec - The executable graph in which to set the specified node.\n @param [in] hNode      - Node from the graph from which graphExec was instantiated.\n @param [in] isEnabled  - Node is enabled if != 0, otherwise the node is disabled.\n\n @returns #hipSuccess, #hipErrorInvalidValue,\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues."]
    pub fn hipGraphNodeSetEnabled(
        hGraphExec: hipGraphExec_t,
        hNode: hipGraphNode_t,
        isEnabled: ::std::os::raw::c_uint,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Query whether a node in the given graphExec is enabled\n\n Sets isEnabled to 1 if hNode is enabled, or 0 if it is disabled.\n\n The node is identified by the corresponding node in the non-executable graph, from which the\n executable graph was instantiated.\n\n hNode must not have been removed from the original graph.\n\n @note Currently only kernel, memset and memcpy nodes are supported.\n\n @param [in]  hGraphExec - The executable graph in which to set the specified node.\n @param [in]  hNode      - Node from the graph from which graphExec was instantiated.\n @param [out] isEnabled  - Location to return the enabled status of the node.\n\n @returns #hipSuccess, #hipErrorInvalidValue\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues."]
    pub fn hipGraphNodeGetEnabled(
        hGraphExec: hipGraphExec_t,
        hNode: hipGraphNode_t,
        isEnabled: *mut ::std::os::raw::c_uint,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Frees an address range reservation made via hipMemAddressReserve\n\n @param [in] devPtr - starting address of the range.\n @param [in] size - size of the range.\n @returns #hipSuccess, #hipErrorInvalidValue, #hipErrorNotSupported\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues.\n\n @note  This API is implemented on Linux, under development on Windows."]
    pub fn hipMemAddressFree(devPtr: *mut ::std::os::raw::c_void, size: usize) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Reserves an address range\n\n @param [out] ptr - starting address of the reserved range.\n @param [in] size - size of the reservation.\n @param [in] alignment - alignment of the address.\n @param [in] addr - requested starting address of the range.\n @param [in] flags - currently unused, must be zero.\n @returns #hipSuccess, #hipErrorInvalidValue, #hipErrorNotSupported\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues.\n\n @note  This API is implemented on Linux, under development on Windows."]
    pub fn hipMemAddressReserve(
        ptr: *mut *mut ::std::os::raw::c_void,
        size: usize,
        alignment: usize,
        addr: *mut ::std::os::raw::c_void,
        flags: ::std::os::raw::c_ulonglong,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Creates a memory allocation described by the properties and size\n\n @param [out] handle - value of the returned handle.\n @param [in] size - size of the allocation.\n @param [in] prop - properties of the allocation.\n @param [in] flags - currently unused, must be zero.\n @returns #hipSuccess, #hipErrorInvalidValue, #hipErrorNotSupported\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues.\n\n @note  This API is implemented on Linux, under development on Windows."]
    pub fn hipMemCreate(
        handle: *mut hipMemGenericAllocationHandle_t,
        size: usize,
        prop: *const hipMemAllocationProp,
        flags: ::std::os::raw::c_ulonglong,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Exports an allocation to a requested shareable handle type.\n\n @param [out] shareableHandle - value of the returned handle.\n @param [in] handle - handle to share.\n @param [in] handleType - type of the shareable handle.\n @param [in] flags - currently unused, must be zero.\n @returns #hipSuccess, #hipErrorInvalidValue, #hipErrorNotSupported\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues.\n\n @note  This API is implemented on Linux, under development on Windows."]
    pub fn hipMemExportToShareableHandle(
        shareableHandle: *mut ::std::os::raw::c_void,
        handle: hipMemGenericAllocationHandle_t,
        handleType: hipMemAllocationHandleType,
        flags: ::std::os::raw::c_ulonglong,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Get the access flags set for the given location and ptr.\n\n @param [out] flags - flags for this location.\n @param [in] location - target location.\n @param [in] ptr - address to check the access flags.\n @returns #hipSuccess, #hipErrorInvalidValue, #hipErrorNotSupported\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues.\n\n @note  This API is implemented on Linux, under development on Windows."]
    pub fn hipMemGetAccess(
        flags: *mut ::std::os::raw::c_ulonglong,
        location: *const hipMemLocation,
        ptr: *mut ::std::os::raw::c_void,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Calculates either the minimal or recommended granularity.\n\n @param [out] granularity - returned granularity.\n @param [in] prop - location properties.\n @param [in] option - determines which granularity to return.\n @returns #hipSuccess, #hipErrorInvalidValue, #hipErrorNotSupported\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues.\n\n @note  This API is implemented on Linux, under development on Windows.\n"]
    pub fn hipMemGetAllocationGranularity(
        granularity: *mut usize,
        prop: *const hipMemAllocationProp,
        option: hipMemAllocationGranularity_flags,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Retrieve the property structure of the given handle.\n\n @param [out] prop - properties of the given handle.\n @param [in] handle - handle to perform the query on.\n @returns #hipSuccess, #hipErrorInvalidValue, #hipErrorNotSupported\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues.\n\n @note  This API is implemented on Linux under development on Windows."]
    pub fn hipMemGetAllocationPropertiesFromHandle(
        prop: *mut hipMemAllocationProp,
        handle: hipMemGenericAllocationHandle_t,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Imports an allocation from a requested shareable handle type.\n\n @param [out] handle - returned value.\n @param [in] osHandle - shareable handle representing the memory allocation.\n @param [in] shHandleType - handle type.\n @returns #hipSuccess, #hipErrorInvalidValue, #hipErrorNotSupported\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues.\n\n @note  This API is implemented on Linux, under development on Windows."]
    pub fn hipMemImportFromShareableHandle(
        handle: *mut hipMemGenericAllocationHandle_t,
        osHandle: *mut ::std::os::raw::c_void,
        shHandleType: hipMemAllocationHandleType,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Maps an allocation handle to a reserved virtual address range.\n\n @param [in] ptr - address where the memory will be mapped.\n @param [in] size - size of the mapping.\n @param [in] offset - offset into the memory, currently must be zero.\n @param [in] handle - memory allocation to be mapped.\n @param [in] flags - currently unused, must be zero.\n @returns #hipSuccess, #hipErrorInvalidValue, #hipErrorNotSupported\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues.\n\n @note  This API is implemented on Linux, under development on Windows."]
    pub fn hipMemMap(
        ptr: *mut ::std::os::raw::c_void,
        size: usize,
        offset: usize,
        handle: hipMemGenericAllocationHandle_t,
        flags: ::std::os::raw::c_ulonglong,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Maps or unmaps subregions of sparse HIP arrays and sparse HIP mipmapped arrays.\n\n @param [in] mapInfoList - list of hipArrayMapInfo.\n @param [in] count - number of hipArrayMapInfo in mapInfoList.\n @param [in] stream - stream identifier for the stream to use for map or unmap operations.\n @returns #hipSuccess, #hipErrorInvalidValue, #hipErrorNotSupported\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues.\n\n @note  This API is implemented on Linux, under development on Windows."]
    pub fn hipMemMapArrayAsync(
        mapInfoList: *mut hipArrayMapInfo,
        count: ::std::os::raw::c_uint,
        stream: hipStream_t,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Release a memory handle representing a memory allocation which was previously allocated through hipMemCreate.\n\n @param [in] handle - handle of the memory allocation.\n @returns #hipSuccess, #hipErrorInvalidValue, #hipErrorNotSupported\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues.\n\n @note  This API is implemented on Linux, under development on Windows."]
    pub fn hipMemRelease(handle: hipMemGenericAllocationHandle_t) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Returns the allocation handle of the backing memory allocation given the address.\n\n @param [out] handle - handle representing addr.\n @param [in] addr - address to look up.\n @returns #hipSuccess, #hipErrorInvalidValue, #hipErrorNotSupported\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues.\n\n @note  This API is implemented on Linux, under development on Windows."]
    pub fn hipMemRetainAllocationHandle(
        handle: *mut hipMemGenericAllocationHandle_t,
        addr: *mut ::std::os::raw::c_void,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Set the access flags for each location specified in desc for the given virtual address range.\n\n @param [in] ptr - starting address of the virtual address range.\n @param [in] size - size of the range.\n @param [in] desc - array of hipMemAccessDesc.\n @param [in] count - number of hipMemAccessDesc in desc.\n @returns #hipSuccess, #hipErrorInvalidValue, #hipErrorNotSupported\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues.\n\n @note  This API is implemented on Linux, under development on Windows."]
    pub fn hipMemSetAccess(
        ptr: *mut ::std::os::raw::c_void,
        size: usize,
        desc: *const hipMemAccessDesc,
        count: usize,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Unmap memory allocation of a given address range.\n\n @param [in] ptr - starting address of the range to unmap.\n @param [in] size - size of the virtual address range.\n @returns #hipSuccess, #hipErrorInvalidValue, #hipErrorNotSupported\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues.\n\n @note  This API is implemented on Linux, under development on Windows."]
    pub fn hipMemUnmap(ptr: *mut ::std::os::raw::c_void, size: usize) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Maps a graphics resource for access.\n\n @param [in] count - Number of resources to map.\n @param [in] resources - Pointer of resources to map.\n @param [in] stream - Stream for synchronization.\n\n @returns #hipSuccess, #hipErrorInvalidValue, #hipErrorUnknown, #hipErrorInvalidResourceHandle\n"]
    pub fn hipGraphicsMapResources(
        count: ::std::os::raw::c_int,
        resources: *mut hipGraphicsResource_t,
        stream: hipStream_t,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Get an array through which to access a subresource of a mapped graphics resource.\n\n @param [out] array - Pointer of array through which a subresource of resource may be accessed.\n @param [in] resource - Mapped resource to access.\n @param [in] arrayIndex - Array index for the subresource to access.\n @param [in] mipLevel - Mipmap level for the subresource to access.\n\n @returns #hipSuccess, #hipErrorInvalidValue\n\n @note  In this API, the value of arrayIndex higher than zero is currently not supported.\n"]
    pub fn hipGraphicsSubResourceGetMappedArray(
        array: *mut hipArray_t,
        resource: hipGraphicsResource_t,
        arrayIndex: ::std::os::raw::c_uint,
        mipLevel: ::std::os::raw::c_uint,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Gets device accessible address of a graphics resource.\n\n @param [out] devPtr - Pointer of device through which graphic resource may be accessed.\n @param [out] size - Size of the buffer accessible from devPtr.\n @param [in] resource - Mapped resource to access.\n\n @returns #hipSuccess, #hipErrorInvalidValue\n"]
    pub fn hipGraphicsResourceGetMappedPointer(
        devPtr: *mut *mut ::std::os::raw::c_void,
        size: *mut usize,
        resource: hipGraphicsResource_t,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Unmaps graphics resources.\n\n @param [in] count - Number of resources to unmap.\n @param [in] resources - Pointer of resources to unmap.\n @param [in] stream - Stream for synchronization.\n\n @returns #hipSuccess, #hipErrorInvalidValue, #hipErrorUnknown, #hipErrorContextIsDestroyed\n"]
    pub fn hipGraphicsUnmapResources(
        count: ::std::os::raw::c_int,
        resources: *mut hipGraphicsResource_t,
        stream: hipStream_t,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Unregisters a graphics resource.\n\n @param [in] resource - Graphics resources to unregister.\n\n @returns #hipSuccess\n"]
    pub fn hipGraphicsUnregisterResource(resource: hipGraphicsResource_t) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Create a surface object.\n\n @param [out] pSurfObject  Pointer of surface object to be created.\n @param [in] pResDesc  Pointer of suface object descriptor.\n\n @returns #hipSuccess, #hipErrorInvalidValue\n"]
    pub fn hipCreateSurfaceObject(
        pSurfObject: *mut hipSurfaceObject_t,
        pResDesc: *const hipResourceDesc,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Destroy a surface object.\n\n @param [in] surfaceObject  Surface object to be destroyed.\n\n @returns #hipSuccess, #hipErrorInvalidValue"]
    pub fn hipDestroySurfaceObject(surfaceObject: hipSurfaceObject_t) -> hipError_t;
}
extern "C" {
    pub fn hipMemcpy_spt(
        dst: *mut ::std::os::raw::c_void,
        src: *const ::std::os::raw::c_void,
        sizeBytes: usize,
        kind: hipMemcpyKind,
    ) -> hipError_t;
}
extern "C" {
    pub fn hipMemcpyToSymbol_spt(
        symbol: *const ::std::os::raw::c_void,
        src: *const ::std::os::raw::c_void,
        sizeBytes: usize,
        offset: usize,
        kind: hipMemcpyKind,
    ) -> hipError_t;
}
extern "C" {
    pub fn hipMemcpyFromSymbol_spt(
        dst: *mut ::std::os::raw::c_void,
        symbol: *const ::std::os::raw::c_void,
        sizeBytes: usize,
        offset: usize,
        kind: hipMemcpyKind,
    ) -> hipError_t;
}
extern "C" {
    pub fn hipMemcpy2D_spt(
        dst: *mut ::std::os::raw::c_void,
        dpitch: usize,
        src: *const ::std::os::raw::c_void,
        spitch: usize,
        width: usize,
        height: usize,
        kind: hipMemcpyKind,
    ) -> hipError_t;
}
extern "C" {
    pub fn hipMemcpy2DFromArray_spt(
        dst: *mut ::std::os::raw::c_void,
        dpitch: usize,
        src: hipArray_const_t,
        wOffset: usize,
        hOffset: usize,
        width: usize,
        height: usize,
        kind: hipMemcpyKind,
    ) -> hipError_t;
}
extern "C" {
    pub fn hipMemcpy3D_spt(p: *const hipMemcpy3DParms) -> hipError_t;
}
extern "C" {
    pub fn hipMemset_spt(
        dst: *mut ::std::os::raw::c_void,
        value: ::std::os::raw::c_int,
        sizeBytes: usize,
    ) -> hipError_t;
}
extern "C" {
    pub fn hipMemsetAsync_spt(
        dst: *mut ::std::os::raw::c_void,
        value: ::std::os::raw::c_int,
        sizeBytes: usize,
        stream: hipStream_t,
    ) -> hipError_t;
}
extern "C" {
    pub fn hipMemset2D_spt(
        dst: *mut ::std::os::raw::c_void,
        pitch: usize,
        value: ::std::os::raw::c_int,
        width: usize,
        height: usize,
    ) -> hipError_t;
}
extern "C" {
    pub fn hipMemset2DAsync_spt(
        dst: *mut ::std::os::raw::c_void,
        pitch: usize,
        value: ::std::os::raw::c_int,
        width: usize,
        height: usize,
        stream: hipStream_t,
    ) -> hipError_t;
}
extern "C" {
    pub fn hipMemset3DAsync_spt(
        pitchedDevPtr: hipPitchedPtr,
        value: ::std::os::raw::c_int,
        extent: hipExtent,
        stream: hipStream_t,
    ) -> hipError_t;
}
extern "C" {
    pub fn hipMemset3D_spt(
        pitchedDevPtr: hipPitchedPtr,
        value: ::std::os::raw::c_int,
        extent: hipExtent,
    ) -> hipError_t;
}
extern "C" {
    pub fn hipMemcpyAsync_spt(
        dst: *mut ::std::os::raw::c_void,
        src: *const ::std::os::raw::c_void,
        sizeBytes: usize,
        kind: hipMemcpyKind,
        stream: hipStream_t,
    ) -> hipError_t;
}
extern "C" {
    pub fn hipMemcpy3DAsync_spt(p: *const hipMemcpy3DParms, stream: hipStream_t) -> hipError_t;
}
extern "C" {
    pub fn hipMemcpy2DAsync_spt(
        dst: *mut ::std::os::raw::c_void,
        dpitch: usize,
        src: *const ::std::os::raw::c_void,
        spitch: usize,
        width: usize,
        height: usize,
        kind: hipMemcpyKind,
        stream: hipStream_t,
    ) -> hipError_t;
}
extern "C" {
    pub fn hipMemcpyFromSymbolAsync_spt(
        dst: *mut ::std::os::raw::c_void,
        symbol: *const ::std::os::raw::c_void,
        sizeBytes: usize,
        offset: usize,
        kind: hipMemcpyKind,
        stream: hipStream_t,
    ) -> hipError_t;
}
extern "C" {
    pub fn hipMemcpyToSymbolAsync_spt(
        symbol: *const ::std::os::raw::c_void,
        src: *const ::std::os::raw::c_void,
        sizeBytes: usize,
        offset: usize,
        kind: hipMemcpyKind,
        stream: hipStream_t,
    ) -> hipError_t;
}
extern "C" {
    pub fn hipMemcpyFromArray_spt(
        dst: *mut ::std::os::raw::c_void,
        src: hipArray_const_t,
        wOffsetSrc: usize,
        hOffset: usize,
        count: usize,
        kind: hipMemcpyKind,
    ) -> hipError_t;
}
extern "C" {
    pub fn hipMemcpy2DToArray_spt(
        dst: hipArray_t,
        wOffset: usize,
        hOffset: usize,
        src: *const ::std::os::raw::c_void,
        spitch: usize,
        width: usize,
        height: usize,
        kind: hipMemcpyKind,
    ) -> hipError_t;
}
extern "C" {
    pub fn hipMemcpy2DFromArrayAsync_spt(
        dst: *mut ::std::os::raw::c_void,
        dpitch: usize,
        src: hipArray_const_t,
        wOffsetSrc: usize,
        hOffsetSrc: usize,
        width: usize,
        height: usize,
        kind: hipMemcpyKind,
        stream: hipStream_t,
    ) -> hipError_t;
}
extern "C" {
    pub fn hipMemcpy2DToArrayAsync_spt(
        dst: hipArray_t,
        wOffset: usize,
        hOffset: usize,
        src: *const ::std::os::raw::c_void,
        spitch: usize,
        width: usize,
        height: usize,
        kind: hipMemcpyKind,
        stream: hipStream_t,
    ) -> hipError_t;
}
extern "C" {
    pub fn hipStreamQuery_spt(stream: hipStream_t) -> hipError_t;
}
extern "C" {
    pub fn hipStreamSynchronize_spt(stream: hipStream_t) -> hipError_t;
}
extern "C" {
    pub fn hipStreamGetPriority_spt(
        stream: hipStream_t,
        priority: *mut ::std::os::raw::c_int,
    ) -> hipError_t;
}
extern "C" {
    pub fn hipStreamWaitEvent_spt(
        stream: hipStream_t,
        event: hipEvent_t,
        flags: ::std::os::raw::c_uint,
    ) -> hipError_t;
}
extern "C" {
    pub fn hipStreamGetFlags_spt(
        stream: hipStream_t,
        flags: *mut ::std::os::raw::c_uint,
    ) -> hipError_t;
}
extern "C" {
    pub fn hipStreamAddCallback_spt(
        stream: hipStream_t,
        callback: hipStreamCallback_t,
        userData: *mut ::std::os::raw::c_void,
        flags: ::std::os::raw::c_uint,
    ) -> hipError_t;
}
extern "C" {
    pub fn hipEventRecord_spt(event: hipEvent_t, stream: hipStream_t) -> hipError_t;
}
extern "C" {
    pub fn hipLaunchCooperativeKernel_spt(
        f: *const ::std::os::raw::c_void,
        gridDim: dim3,
        blockDim: dim3,
        kernelParams: *mut *mut ::std::os::raw::c_void,
        sharedMemBytes: u32,
        hStream: hipStream_t,
    ) -> hipError_t;
}
extern "C" {
    pub fn hipLaunchKernel_spt(
        function_address: *const ::std::os::raw::c_void,
        numBlocks: dim3,
        dimBlocks: dim3,
        args: *mut *mut ::std::os::raw::c_void,
        sharedMemBytes: usize,
        stream: hipStream_t,
    ) -> hipError_t;
}
extern "C" {
    pub fn hipGraphLaunch_spt(graphExec: hipGraphExec_t, stream: hipStream_t) -> hipError_t;
}
extern "C" {
    pub fn hipStreamBeginCapture_spt(stream: hipStream_t, mode: hipStreamCaptureMode)
        -> hipError_t;
}
extern "C" {
    pub fn hipStreamEndCapture_spt(stream: hipStream_t, pGraph: *mut hipGraph_t) -> hipError_t;
}
extern "C" {
    pub fn hipStreamIsCapturing_spt(
        stream: hipStream_t,
        pCaptureStatus: *mut hipStreamCaptureStatus,
    ) -> hipError_t;
}
extern "C" {
    pub fn hipStreamGetCaptureInfo_spt(
        stream: hipStream_t,
        pCaptureStatus: *mut hipStreamCaptureStatus,
        pId: *mut ::std::os::raw::c_ulonglong,
    ) -> hipError_t;
}
extern "C" {
    pub fn hipStreamGetCaptureInfo_v2_spt(
        stream: hipStream_t,
        captureStatus_out: *mut hipStreamCaptureStatus,
        id_out: *mut ::std::os::raw::c_ulonglong,
        graph_out: *mut hipGraph_t,
        dependencies_out: *mut *const hipGraphNode_t,
        numDependencies_out: *mut usize,
    ) -> hipError_t;
}
extern "C" {
    pub fn hipLaunchHostFunc_spt(
        stream: hipStream_t,
        fn_: hipHostFn_t,
        userData: *mut ::std::os::raw::c_void,
    ) -> hipError_t;
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum hipDataType {
    HIP_R_32F = 0,
    HIP_R_64F = 1,
    HIP_R_16F = 2,
    HIP_R_8I = 3,
    HIP_C_32F = 4,
    HIP_C_64F = 5,
    HIP_C_16F = 6,
    HIP_C_8I = 7,
    HIP_R_8U = 8,
    HIP_C_8U = 9,
    HIP_R_32I = 10,
    HIP_C_32I = 11,
    HIP_R_32U = 12,
    HIP_C_32U = 13,
    HIP_R_16BF = 14,
    HIP_C_16BF = 15,
    HIP_R_4I = 16,
    HIP_C_4I = 17,
    HIP_R_4U = 18,
    HIP_C_4U = 19,
    HIP_R_16I = 20,
    HIP_C_16I = 21,
    HIP_R_16U = 22,
    HIP_C_16U = 23,
    HIP_R_64I = 24,
    HIP_C_64I = 25,
    HIP_R_64U = 26,
    HIP_C_64U = 27,
    HIP_R_8F_E4M3_FNUZ = 1000,
    HIP_R_8F_E5M2_FNUZ = 1001,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum hipLibraryPropertyType {
    HIP_LIBRARY_MAJOR_VERSION = 0,
    HIP_LIBRARY_MINOR_VERSION = 1,
    HIP_LIBRARY_PATCH_LEVEL = 2,
}
pub type hipFloatComplex = float2;
pub type hipDoubleComplex = double2;
pub type hipComplex = hipFloatComplex;
#[doc = " \\brief hipblasHanlde_t is a void pointer, to store the library context (either rocBLAS or cuBLAS)"]
pub type hipblasHandle_t = *mut ::std::os::raw::c_void;
pub type hipblasHalf = u16;
#[doc = " \\brief  To specify the datatype to be signed char"]
pub type hipblasInt8 = i8;
#[doc = " \\brief  Stride between matrices or vectors in strided_batched functions."]
pub type hipblasStride = i64;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hipblasBfloat16 {
    pub data: u16,
}
#[doc = " \\brief Struct to represent a complex number with single precision real and imaginary parts."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hipblasComplex {
    pub x: f32,
    pub y: f32,
}
#[doc = " \\brief Struct to represent a complex number with double precision real and imaginary parts."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hipblasDoubleComplex {
    pub x: f64,
    pub y: f64,
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " \\brief hipblas status codes definition"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum hipblasStatus_t {
    #[doc = "< Function succeeds"]
    HIPBLAS_STATUS_SUCCESS = 0,
    #[doc = "< HIPBLAS library not initialized"]
    HIPBLAS_STATUS_NOT_INITIALIZED = 1,
    #[doc = "< resource allocation failed"]
    HIPBLAS_STATUS_ALLOC_FAILED = 2,
    #[doc = "< unsupported numerical value was passed to function"]
    HIPBLAS_STATUS_INVALID_VALUE = 3,
    #[doc = "< access to GPU memory space failed"]
    HIPBLAS_STATUS_MAPPING_ERROR = 4,
    #[doc = "< GPU program failed to execute"]
    HIPBLAS_STATUS_EXECUTION_FAILED = 5,
    #[doc = "< an internal HIPBLAS operation failed"]
    HIPBLAS_STATUS_INTERNAL_ERROR = 6,
    #[doc = "< function not implemented"]
    HIPBLAS_STATUS_NOT_SUPPORTED = 7,
    #[doc = "< architecture mismatch"]
    HIPBLAS_STATUS_ARCH_MISMATCH = 8,
    #[doc = "< hipBLAS handle is null pointer"]
    HIPBLAS_STATUS_HANDLE_IS_NULLPTR = 9,
    #[doc = "<  unsupported enum value was passed to function"]
    HIPBLAS_STATUS_INVALID_ENUM = 10,
    #[doc = "<  back-end returned an unsupported status code"]
    HIPBLAS_STATUS_UNKNOWN = 11,
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " \\brief Indicates if scalar pointers are on host or device. This is used for scalars alpha and beta and for scalar function return values."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum hipblasPointerMode_t {
    #[doc = "< Scalar values affected by this variable will be located on the host."]
    HIPBLAS_POINTER_MODE_HOST = 0,
    #[doc = "<  Scalar values affected by this variable will be located on the device."]
    HIPBLAS_POINTER_MODE_DEVICE = 1,
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " \\brief Used to specify whether the matrix is to be transposed or not."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum hipblasOperation_t {
    #[doc = "<  Operate with the matrix."]
    HIPBLAS_OP_N = 111,
    #[doc = "<  Operate with the transpose of the matrix."]
    HIPBLAS_OP_T = 112,
    #[doc = "< Operate with the conjugate transpose of the matrix."]
    HIPBLAS_OP_C = 113,
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " \\brief Used by the Hermitian, symmetric and triangular matrix routines to specify whether the upper or lower triangle is being referenced."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum hipblasFillMode_t {
    #[doc = "<  Upper triangle"]
    HIPBLAS_FILL_MODE_UPPER = 121,
    #[doc = "<  Lower triangle"]
    HIPBLAS_FILL_MODE_LOWER = 122,
    HIPBLAS_FILL_MODE_FULL = 123,
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " \\brief It is used by the triangular matrix routines to specify whether the matrix is unit triangular."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum hipblasDiagType_t {
    #[doc = "<  Non-unit triangular."]
    HIPBLAS_DIAG_NON_UNIT = 131,
    #[doc = "<  Unit triangular."]
    HIPBLAS_DIAG_UNIT = 132,
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " \\brief Indicates the side matrix A is located relative to matrix B during multiplication."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum hipblasSideMode_t {
    HIPBLAS_SIDE_LEFT = 141,
    HIPBLAS_SIDE_RIGHT = 142,
    HIPBLAS_SIDE_BOTH = 143,
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " \\brief Indicates the precision of data used. hipblasDatatype_t is deprecated as of hipBLAS 2.0.0 and will\nbe removed in a future release as generally replaced by hipDataType."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum hipblasDatatype_t {
    #[doc = "< 16 bit floating point, real"]
    HIPBLAS_R_16F = 150,
    #[doc = "< 32 bit floating point, real"]
    HIPBLAS_R_32F = 151,
    #[doc = "< 64 bit floating point, real"]
    HIPBLAS_R_64F = 152,
    #[doc = "< 16 bit floating point, complex"]
    HIPBLAS_C_16F = 153,
    #[doc = "< 32 bit floating point, complex"]
    HIPBLAS_C_32F = 154,
    #[doc = "< 64 bit floating point, complex"]
    HIPBLAS_C_64F = 155,
    #[doc = "<  8 bit signed integer, real"]
    HIPBLAS_R_8I = 160,
    #[doc = "<  8 bit unsigned integer, real"]
    HIPBLAS_R_8U = 161,
    #[doc = "< 32 bit signed integer, real"]
    HIPBLAS_R_32I = 162,
    #[doc = "< 32 bit unsigned integer, real"]
    HIPBLAS_R_32U = 163,
    #[doc = "<  8 bit signed integer, complex"]
    HIPBLAS_C_8I = 164,
    #[doc = "<  8 bit unsigned integer, complex"]
    HIPBLAS_C_8U = 165,
    #[doc = "< 32 bit signed integer, complex"]
    HIPBLAS_C_32I = 166,
    #[doc = "< 32 bit unsigned integer, complex"]
    HIPBLAS_C_32U = 167,
    #[doc = "< 16 bit bfloat, real"]
    HIPBLAS_R_16B = 168,
    #[doc = "< 16 bit bfloat, complex"]
    HIPBLAS_C_16B = 169,
    #[doc = "< Invalid datatype value, do not use"]
    HIPBLAS_DATATYPE_INVALID = 255,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum hipblasComputeType_t {
    #[doc = "< compute will be at least 16-bit precision"]
    HIPBLAS_COMPUTE_16F = 0,
    #[doc = "< compute will be exactly 16-bit precision"]
    HIPBLAS_COMPUTE_16F_PEDANTIC = 1,
    #[doc = "< compute will be at least 32-bit precision"]
    HIPBLAS_COMPUTE_32F = 2,
    #[doc = "< compute will be exactly 32-bit precision"]
    HIPBLAS_COMPUTE_32F_PEDANTIC = 3,
    #[doc = "< 32-bit input can use 16-bit compute"]
    HIPBLAS_COMPUTE_32F_FAST_16F = 4,
    #[doc = "< 32-bit input can is bf16 compute"]
    HIPBLAS_COMPUTE_32F_FAST_16BF = 5,
    HIPBLAS_COMPUTE_32F_FAST_TF32 = 6,
    #[doc = "< compute will be at least 64-bit precision"]
    HIPBLAS_COMPUTE_64F = 7,
    #[doc = "< compute will be exactly 64-bit precision"]
    HIPBLAS_COMPUTE_64F_PEDANTIC = 8,
    #[doc = "< compute will be at least 32-bit integer precision"]
    HIPBLAS_COMPUTE_32I = 9,
    #[doc = "< compute will be exactly 32-bit integer precision"]
    HIPBLAS_COMPUTE_32I_PEDANTIC = 10,
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " \\brief Indicates if layer is active with bitmask."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum hipblasGemmAlgo_t {
    #[doc = "<  enumerator rocblas_gemm_algo_standard"]
    HIPBLAS_GEMM_DEFAULT = 160,
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " \\brief Indicates if atomics operations are allowed. Not allowing atomic operations may generally improve determinism and repeatability of results at a cost of performance.\n         By default, the rocBLAS backend will allow atomic operations while the cuBLAS backend will disallow atomic operations. See backend documentation\n         for more detail."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum hipblasAtomicsMode_t {
    #[doc = "<  Algorithms will refrain from atomics where applicable."]
    HIPBLAS_ATOMICS_NOT_ALLOWED = 0,
    #[doc = "< Algorithms will take advantage of atomics where applicable."]
    HIPBLAS_ATOMICS_ALLOWED = 1,
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " \\brief Control flags passed into gemm ex with flags algorithms. Only relevant with rocBLAS backend. See rocBLAS documentation\n         for more information."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum hipblasGemmFlags_t {
    #[doc = "< Default empty flags"]
    HIPBLAS_GEMM_FLAGS_NONE = 0,
    HIPBLAS_GEMM_FLAGS_USE_CU_EFFICIENCY = 2,
    #[doc = "< enumerator rocblas_gemm_flags_fp16_alt_impl"]
    HIPBLAS_GEMM_FLAGS_FP16_ALT_IMPL = 4,
    HIPBLAS_GEMM_FLAGS_CHECK_SOLUTION_INDEX = 8,
    HIPBLAS_GEMM_FLAGS_FP16_ALT_IMPL_RNZ = 16,
}
extern "C" {
    #[doc = " \\brief Create hipblas handle."]
    pub fn hipblasCreate(handle: *mut hipblasHandle_t) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " \\brief Destroys the library context created using hipblasCreate()"]
    pub fn hipblasDestroy(handle: hipblasHandle_t) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " \\brief Set stream for handle"]
    pub fn hipblasSetStream(handle: hipblasHandle_t, streamId: hipStream_t) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " \\brief Get stream[0] for handle"]
    pub fn hipblasGetStream(handle: hipblasHandle_t, streamId: *mut hipStream_t)
        -> hipblasStatus_t;
}
extern "C" {
    #[doc = " \\brief Set hipblas pointer mode"]
    pub fn hipblasSetPointerMode(
        handle: hipblasHandle_t,
        mode: hipblasPointerMode_t,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " \\brief Get hipblas pointer mode"]
    pub fn hipblasGetPointerMode(
        handle: hipblasHandle_t,
        mode: *mut hipblasPointerMode_t,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " \\brief copy vector from host to device\n@param[in]\nn           [int]\nnumber of elements in the vector\n@param[in]\nelemSize    [int]\nSize of both vectors in bytes\n@param[in]\nx           pointer to vector on the host\n@param[in]\nincx        [int]\nspecifies the increment for the elements of the vector\n@param[out]\ny           pointer to vector on the device\n@param[in]\nincy        [int]\nspecifies the increment for the elements of the vector"]
    pub fn hipblasSetVector(
        n: ::std::os::raw::c_int,
        elemSize: ::std::os::raw::c_int,
        x: *const ::std::os::raw::c_void,
        incx: ::std::os::raw::c_int,
        y: *mut ::std::os::raw::c_void,
        incy: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " \\brief copy vector from device to host\n@param[in]\nn           [int]\nnumber of elements in the vector\n@param[in]\nelemSize    [int]\nSize of both vectors in bytes\n@param[in]\nx           pointer to vector on the device\n@param[in]\nincx        [int]\nspecifies the increment for the elements of the vector\n@param[out]\ny           pointer to vector on the host\n@param[in]\nincy        [int]\nspecifies the increment for the elements of the vector"]
    pub fn hipblasGetVector(
        n: ::std::os::raw::c_int,
        elemSize: ::std::os::raw::c_int,
        x: *const ::std::os::raw::c_void,
        incx: ::std::os::raw::c_int,
        y: *mut ::std::os::raw::c_void,
        incy: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " \\brief copy matrix from host to device\n@param[in]\nrows        [int]\nnumber of rows in matrices\n@param[in]\ncols        [int]\nnumber of columns in matrices\n@param[in]\nelemSize   [int]\nnumber of bytes per element in the matrix\n@param[in]\nAP          pointer to matrix on the host\n@param[in]\nlda         [int]\nspecifies the leading dimension of A, lda >= rows\n@param[out]\nBP           pointer to matrix on the GPU\n@param[in]\nldb         [int]\nspecifies the leading dimension of B, ldb >= rows"]
    pub fn hipblasSetMatrix(
        rows: ::std::os::raw::c_int,
        cols: ::std::os::raw::c_int,
        elemSize: ::std::os::raw::c_int,
        AP: *const ::std::os::raw::c_void,
        lda: ::std::os::raw::c_int,
        BP: *mut ::std::os::raw::c_void,
        ldb: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " \\brief copy matrix from device to host\n@param[in]\nrows        [int]\nnumber of rows in matrices\n@param[in]\ncols        [int]\nnumber of columns in matrices\n@param[in]\nelemSize   [int]\nnumber of bytes per element in the matrix\n@param[in]\nAP          pointer to matrix on the GPU\n@param[in]\nlda         [int]\nspecifies the leading dimension of A, lda >= rows\n@param[out]\nBP          pointer to matrix on the host\n@param[in]\nldb         [int]\nspecifies the leading dimension of B, ldb >= rows"]
    pub fn hipblasGetMatrix(
        rows: ::std::os::raw::c_int,
        cols: ::std::os::raw::c_int,
        elemSize: ::std::os::raw::c_int,
        AP: *const ::std::os::raw::c_void,
        lda: ::std::os::raw::c_int,
        BP: *mut ::std::os::raw::c_void,
        ldb: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " \\brief asynchronously copy vector from host to device\n\\details\nhipblasSetVectorAsync copies a vector from pinned host memory to device memory asynchronously.\nMemory on the host must be allocated with hipHostMalloc or the transfer will be synchronous.\n@param[in]\nn           [int]\nnumber of elements in the vector\n@param[in]\nelemSize   [int]\nnumber of bytes per element in the matrix\n@param[in]\nx           pointer to vector on the host\n@param[in]\nincx        [int]\nspecifies the increment for the elements of the vector\n@param[out]\ny           pointer to vector on the device\n@param[in]\nincy        [int]\nspecifies the increment for the elements of the vector\n@param[in]\nstream      specifies the stream into which this transfer request is queued"]
    pub fn hipblasSetVectorAsync(
        n: ::std::os::raw::c_int,
        elemSize: ::std::os::raw::c_int,
        x: *const ::std::os::raw::c_void,
        incx: ::std::os::raw::c_int,
        y: *mut ::std::os::raw::c_void,
        incy: ::std::os::raw::c_int,
        stream: hipStream_t,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " \\brief asynchronously copy vector from device to host\n\\details\nhipblasGetVectorAsync copies a vector from pinned host memory to device memory asynchronously.\nMemory on the host must be allocated with hipHostMalloc or the transfer will be synchronous.\n@param[in]\nn           [int]\nnumber of elements in the vector\n@param[in]\nelemSize   [int]\nnumber of bytes per element in the matrix\n@param[in]\nx           pointer to vector on the device\n@param[in]\nincx        [int]\nspecifies the increment for the elements of the vector\n@param[out]\ny           pointer to vector on the host\n@param[in]\nincy        [int]\nspecifies the increment for the elements of the vector\n@param[in]\nstream      specifies the stream into which this transfer request is queued"]
    pub fn hipblasGetVectorAsync(
        n: ::std::os::raw::c_int,
        elemSize: ::std::os::raw::c_int,
        x: *const ::std::os::raw::c_void,
        incx: ::std::os::raw::c_int,
        y: *mut ::std::os::raw::c_void,
        incy: ::std::os::raw::c_int,
        stream: hipStream_t,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " \\brief asynchronously copy matrix from host to device\n\\details\nhipblasSetMatrixAsync copies a matrix from pinned host memory to device memory asynchronously.\nMemory on the host must be allocated with hipHostMalloc or the transfer will be synchronous.\n@param[in]\nrows        [int]\nnumber of rows in matrices\n@param[in]\ncols        [int]\nnumber of columns in matrices\n@param[in]\nelemSize   [int]\nnumber of bytes per element in the matrix\n@param[in]\nAP           pointer to matrix on the host\n@param[in]\nlda         [int]\nspecifies the leading dimension of A, lda >= rows\n@param[out]\nBP           pointer to matrix on the GPU\n@param[in]\nldb         [int]\nspecifies the leading dimension of B, ldb >= rows\n@param[in]\nstream      specifies the stream into which this transfer request is queued"]
    pub fn hipblasSetMatrixAsync(
        rows: ::std::os::raw::c_int,
        cols: ::std::os::raw::c_int,
        elemSize: ::std::os::raw::c_int,
        AP: *const ::std::os::raw::c_void,
        lda: ::std::os::raw::c_int,
        BP: *mut ::std::os::raw::c_void,
        ldb: ::std::os::raw::c_int,
        stream: hipStream_t,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " \\brief asynchronously copy matrix from device to host\n\\details\nhipblasGetMatrixAsync copies a matrix from device memory to pinned host memory asynchronously.\nMemory on the host must be allocated with hipHostMalloc or the transfer will be synchronous.\n@param[in]\nrows        [int]\nnumber of rows in matrices\n@param[in]\ncols        [int]\nnumber of columns in matrices\n@param[in]\nelemSize   [int]\nnumber of bytes per element in the matrix\n@param[in]\nAP          pointer to matrix on the GPU\n@param[in]\nlda         [int]\nspecifies the leading dimension of A, lda >= rows\n@param[out]\nBP           pointer to matrix on the host\n@param[in]\nldb         [int]\nspecifies the leading dimension of B, ldb >= rows\n@param[in]\nstream      specifies the stream into which this transfer request is queued"]
    pub fn hipblasGetMatrixAsync(
        rows: ::std::os::raw::c_int,
        cols: ::std::os::raw::c_int,
        elemSize: ::std::os::raw::c_int,
        AP: *const ::std::os::raw::c_void,
        lda: ::std::os::raw::c_int,
        BP: *mut ::std::os::raw::c_void,
        ldb: ::std::os::raw::c_int,
        stream: hipStream_t,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " \\brief Set hipblasSetAtomicsMode"]
    pub fn hipblasSetAtomicsMode(
        handle: hipblasHandle_t,
        atomics_mode: hipblasAtomicsMode_t,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " \\brief Get hipblasSetAtomicsMode"]
    pub fn hipblasGetAtomicsMode(
        handle: hipblasHandle_t,
        atomics_mode: *mut hipblasAtomicsMode_t,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 1 API\n\n\\details\namax finds the first index of the element of maximum magnitude of a vector x.\n\n- Supported precisions in rocBLAS : s,d,c,z.\n- Supported precisions in cuBLAS  : s,d,c,z.\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n@param[in]\nn         [int]\nthe number of elements in x.\n@param[in]\nx         device pointer storing vector x.\n@param[in]\nincx      [int]\nspecifies the increment for the elements of y.\n@param[inout]\nresult\ndevice pointer or host pointer to store the amax index.\nreturn is 0.0 if n, incx<=0."]
    pub fn hipblasIsamax(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        x: *const f32,
        incx: ::std::os::raw::c_int,
        result: *mut ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasIdamax(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        x: *const f64,
        incx: ::std::os::raw::c_int,
        result: *mut ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasIcamax(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        x: *const hipblasComplex,
        incx: ::std::os::raw::c_int,
        result: *mut ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasIzamax(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        x: *const hipblasDoubleComplex,
        incx: ::std::os::raw::c_int,
        result: *mut ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasIcamax_v2(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        x: *const hipComplex,
        incx: ::std::os::raw::c_int,
        result: *mut ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasIzamax_v2(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        x: *const hipDoubleComplex,
        incx: ::std::os::raw::c_int,
        result: *mut ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 1 API\n\n\\details\namaxBatched finds the first index of the element of maximum magnitude of each vector x_i in a batch, for i = 1, ..., batchCount.\n\n- Supported precisions in rocBLAS : s,d,c,z.\n- Supported precisions in cuBLAS  : No support.\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n@param[in]\nn         [int]\nnumber of elements in each vector x_i\n@param[in]\nx         device array of device pointers storing each vector x_i.\n@param[in]\nincx      [int]\nspecifies the increment for the elements of each x_i. incx must be > 0.\n@param[in]\nbatchCount [int]\nnumber of instances in the batch, must be > 0.\n@param[out]\nresult\ndevice or host array of pointers of batchCount size for results.\nreturn is 0 if n, incx<=0."]
    pub fn hipblasIsamaxBatched(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        x: *const *const f32,
        incx: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
        result: *mut ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasIdamaxBatched(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        x: *const *const f64,
        incx: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
        result: *mut ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasIcamaxBatched(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        x: *const *const hipblasComplex,
        incx: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
        result: *mut ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasIzamaxBatched(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        x: *const *const hipblasDoubleComplex,
        incx: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
        result: *mut ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasIcamaxBatched_v2(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        x: *const *const hipComplex,
        incx: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
        result: *mut ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasIzamaxBatched_v2(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        x: *const *const hipDoubleComplex,
        incx: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
        result: *mut ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 1 API\n\n\\details\namaxStridedBatched finds the first index of the element of maximum magnitude of each vector x_i in a batch, for i = 1, ..., batchCount.\n\n- Supported precisions in rocBLAS : s,d,c,z\n- Supported precisions in cuBLAS  : No support\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n@param[in]\nn         [int]\nnumber of elements in each vector x_i\n@param[in]\nx         device pointer to the first vector x_1.\n@param[in]\nincx      [int]\nspecifies the increment for the elements of each x_i. incx must be > 0.\n@param[in]\nstridex   [hipblasStride]\nspecifies the pointer increment between one x_i and the next x_(i + 1).\n@param[in]\nbatchCount [int]\nnumber of instances in the batch\n@param[out]\nresult\ndevice or host pointer for storing contiguous batchCount results.\nreturn is 0 if n <= 0, incx<=0.\n"]
    pub fn hipblasIsamaxStridedBatched(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        x: *const f32,
        incx: ::std::os::raw::c_int,
        stridex: hipblasStride,
        batchCount: ::std::os::raw::c_int,
        result: *mut ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasIdamaxStridedBatched(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        x: *const f64,
        incx: ::std::os::raw::c_int,
        stridex: hipblasStride,
        batchCount: ::std::os::raw::c_int,
        result: *mut ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasIcamaxStridedBatched(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        x: *const hipblasComplex,
        incx: ::std::os::raw::c_int,
        stridex: hipblasStride,
        batchCount: ::std::os::raw::c_int,
        result: *mut ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasIzamaxStridedBatched(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        x: *const hipblasDoubleComplex,
        incx: ::std::os::raw::c_int,
        stridex: hipblasStride,
        batchCount: ::std::os::raw::c_int,
        result: *mut ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasIcamaxStridedBatched_v2(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        x: *const hipComplex,
        incx: ::std::os::raw::c_int,
        stridex: hipblasStride,
        batchCount: ::std::os::raw::c_int,
        result: *mut ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasIzamaxStridedBatched_v2(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        x: *const hipDoubleComplex,
        incx: ::std::os::raw::c_int,
        stridex: hipblasStride,
        batchCount: ::std::os::raw::c_int,
        result: *mut ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 1 API\n\n\\details\namin finds the first index of the element of minimum magnitude of a vector x.\n\n- Supported precisions in rocBLAS : s,d,c,z\n- Supported precisions in cuBLAS  : s,d,c,z\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n@param[in]\nn         [int]\nthe number of elements in x.\n@param[in]\nx         device pointer storing vector x.\n@param[in]\nincx      [int]\nspecifies the increment for the elements of y.\n@param[inout]\nresult\ndevice pointer or host pointer to store the amin index.\nreturn is 0.0 if n, incx<=0."]
    pub fn hipblasIsamin(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        x: *const f32,
        incx: ::std::os::raw::c_int,
        result: *mut ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasIdamin(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        x: *const f64,
        incx: ::std::os::raw::c_int,
        result: *mut ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasIcamin(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        x: *const hipblasComplex,
        incx: ::std::os::raw::c_int,
        result: *mut ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasIzamin(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        x: *const hipblasDoubleComplex,
        incx: ::std::os::raw::c_int,
        result: *mut ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasIcamin_v2(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        x: *const hipComplex,
        incx: ::std::os::raw::c_int,
        result: *mut ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasIzamin_v2(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        x: *const hipDoubleComplex,
        incx: ::std::os::raw::c_int,
        result: *mut ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 1 API\n\n\\details\naminBatched finds the first index of the element of minimum magnitude of each vector x_i in a batch, for i = 1, ..., batchCount.\n\n- Supported precisions in rocBLAS : s,d,c,z\n- Supported precisions in cuBLAS  : No support\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n@param[in]\nn         [int]\nnumber of elements in each vector x_i\n@param[in]\nx         device array of device pointers storing each vector x_i.\n@param[in]\nincx      [int]\nspecifies the increment for the elements of each x_i. incx must be > 0.\n@param[in]\nbatchCount [int]\nnumber of instances in the batch, must be > 0.\n@param[out]\nresult\ndevice or host pointers to array of batchCount size for results.\nreturn is 0 if n, incx<=0."]
    pub fn hipblasIsaminBatched(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        x: *const *const f32,
        incx: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
        result: *mut ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasIdaminBatched(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        x: *const *const f64,
        incx: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
        result: *mut ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasIcaminBatched(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        x: *const *const hipblasComplex,
        incx: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
        result: *mut ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasIzaminBatched(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        x: *const *const hipblasDoubleComplex,
        incx: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
        result: *mut ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasIcaminBatched_v2(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        x: *const *const hipComplex,
        incx: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
        result: *mut ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasIzaminBatched_v2(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        x: *const *const hipDoubleComplex,
        incx: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
        result: *mut ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 1 API\n\n\\details\naminStridedBatched finds the first index of the element of minimum magnitude of each vector x_i in a batch, for i = 1, ..., batchCount.\n\n- Supported precisions in rocBLAS : s,d,c,z\n- Supported precisions in cuBLAS  : No support\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n@param[in]\nn         [int]\nnumber of elements in each vector x_i\n@param[in]\nx         device pointer to the first vector x_1.\n@param[in]\nincx      [int]\nspecifies the increment for the elements of each x_i. incx must be > 0.\n@param[in]\nstridex   [hipblasStride]\nspecifies the pointer increment between one x_i and the next x_(i + 1)\n@param[in]\nbatchCount [int]\nnumber of instances in the batch\n@param[out]\nresult\ndevice or host pointer to array for storing contiguous batchCount results.\nreturn is 0 if n <= 0, incx<=0.\n"]
    pub fn hipblasIsaminStridedBatched(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        x: *const f32,
        incx: ::std::os::raw::c_int,
        stridex: hipblasStride,
        batchCount: ::std::os::raw::c_int,
        result: *mut ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasIdaminStridedBatched(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        x: *const f64,
        incx: ::std::os::raw::c_int,
        stridex: hipblasStride,
        batchCount: ::std::os::raw::c_int,
        result: *mut ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasIcaminStridedBatched(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        x: *const hipblasComplex,
        incx: ::std::os::raw::c_int,
        stridex: hipblasStride,
        batchCount: ::std::os::raw::c_int,
        result: *mut ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasIzaminStridedBatched(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        x: *const hipblasDoubleComplex,
        incx: ::std::os::raw::c_int,
        stridex: hipblasStride,
        batchCount: ::std::os::raw::c_int,
        result: *mut ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasIcaminStridedBatched_v2(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        x: *const hipComplex,
        incx: ::std::os::raw::c_int,
        stridex: hipblasStride,
        batchCount: ::std::os::raw::c_int,
        result: *mut ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasIzaminStridedBatched_v2(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        x: *const hipDoubleComplex,
        incx: ::std::os::raw::c_int,
        stridex: hipblasStride,
        batchCount: ::std::os::raw::c_int,
        result: *mut ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 1 API\n\n\\details\nasum computes the sum of the magnitudes of elements of a real vector x,\nor the sum of magnitudes of the real and imaginary parts of elements if x is a complex vector.\n\n- Supported precisions in rocBLAS : s,d,c,z\n- Supported precisions in cuBLAS  : s,d,c,z\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n@param[in]\nn         [int]\nthe number of elements in x and y.\n@param[in]\nx         device pointer storing vector x.\n@param[in]\nincx      [int]\nspecifies the increment for the elements of x. incx must be > 0.\n@param[inout]\nresult\ndevice pointer or host pointer to store the asum product.\nreturn is 0.0 if n <= 0.\n"]
    pub fn hipblasSasum(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        x: *const f32,
        incx: ::std::os::raw::c_int,
        result: *mut f32,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDasum(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        x: *const f64,
        incx: ::std::os::raw::c_int,
        result: *mut f64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasScasum(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        x: *const hipblasComplex,
        incx: ::std::os::raw::c_int,
        result: *mut f32,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDzasum(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        x: *const hipblasDoubleComplex,
        incx: ::std::os::raw::c_int,
        result: *mut f64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasScasum_v2(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        x: *const hipComplex,
        incx: ::std::os::raw::c_int,
        result: *mut f32,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDzasum_v2(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        x: *const hipDoubleComplex,
        incx: ::std::os::raw::c_int,
        result: *mut f64,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 1 API\n\n\\details\nasumBatched computes the sum of the magnitudes of the elements in a batch of real vectors x_i,\nor the sum of magnitudes of the real and imaginary parts of elements if x_i is a complex\nvector, for i = 1, ..., batchCount.\n\n- Supported precisions in rocBLAS : s,d,c,z\n- Supported precisions in cuBLAS  : No support\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n@param[in]\nn         [int]\nnumber of elements in each vector x_i\n@param[in]\nx         device array of device pointers storing each vector x_i.\n@param[in]\nincx      [int]\nspecifies the increment for the elements of each x_i. incx must be > 0.\n@param[in]\nbatchCount [int]\nnumber of instances in the batch.\n@param[out]\nresult\ndevice array or host array of batchCount size for results.\nreturn is 0.0 if n, incx<=0."]
    pub fn hipblasSasumBatched(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        x: *const *const f32,
        incx: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
        result: *mut f32,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDasumBatched(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        x: *const *const f64,
        incx: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
        result: *mut f64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasScasumBatched(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        x: *const *const hipblasComplex,
        incx: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
        result: *mut f32,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDzasumBatched(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        x: *const *const hipblasDoubleComplex,
        incx: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
        result: *mut f64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasScasumBatched_v2(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        x: *const *const hipComplex,
        incx: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
        result: *mut f32,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDzasumBatched_v2(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        x: *const *const hipDoubleComplex,
        incx: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
        result: *mut f64,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 1 API\n\n\\details\nasumStridedBatched computes the sum of the magnitudes of elements of a real vectors x_i,\nor the sum of magnitudes of the real and imaginary parts of elements if x_i is a complex\nvector, for i = 1, ..., batchCount.\n\n- Supported precisions in rocBLAS : s,d,c,z\n- Supported precisions in cuBLAS  : No support\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n@param[in]\nn         [int]\nnumber of elements in each vector x_i\n@param[in]\nx         device pointer to the first vector x_1.\n@param[in]\nincx      [int]\nspecifies the increment for the elements of each x_i. incx must be > 0.\n@param[in]\nstridex   [hipblasStride]\nstride from the start of one vector (x_i) and the next one (x_i+1).\nThere are no restrictions placed on stride_x, however the user should\ntake care to ensure that stride_x is of appropriate size, for a typical\ncase this means stride_x >= n * incx.\n@param[in]\nbatchCount [int]\nnumber of instances in the batch\n@param[out]\nresult\ndevice pointer or host pointer to array for storing contiguous batchCount results.\nreturn is 0.0 if n, incx<=0."]
    pub fn hipblasSasumStridedBatched(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        x: *const f32,
        incx: ::std::os::raw::c_int,
        stridex: hipblasStride,
        batchCount: ::std::os::raw::c_int,
        result: *mut f32,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDasumStridedBatched(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        x: *const f64,
        incx: ::std::os::raw::c_int,
        stridex: hipblasStride,
        batchCount: ::std::os::raw::c_int,
        result: *mut f64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasScasumStridedBatched(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        x: *const hipblasComplex,
        incx: ::std::os::raw::c_int,
        stridex: hipblasStride,
        batchCount: ::std::os::raw::c_int,
        result: *mut f32,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDzasumStridedBatched(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        x: *const hipblasDoubleComplex,
        incx: ::std::os::raw::c_int,
        stridex: hipblasStride,
        batchCount: ::std::os::raw::c_int,
        result: *mut f64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasScasumStridedBatched_v2(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        x: *const hipComplex,
        incx: ::std::os::raw::c_int,
        stridex: hipblasStride,
        batchCount: ::std::os::raw::c_int,
        result: *mut f32,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDzasumStridedBatched_v2(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        x: *const hipDoubleComplex,
        incx: ::std::os::raw::c_int,
        stridex: hipblasStride,
        batchCount: ::std::os::raw::c_int,
        result: *mut f64,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 1 API\n\n\\details\naxpy   computes constant alpha multiplied by vector x, plus vector y\n\ny := alpha * x + y\n\n- Supported precisions in rocBLAS : h,s,d,c,z\n- Supported precisions in cuBLAS  : s,d,c,z\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n@param[in]\nn         [int]\nthe number of elements in x and y.\n@param[in]\nalpha     device pointer or host pointer to specify the scalar alpha.\n@param[in]\nx         device pointer storing vector x.\n@param[in]\nincx      [int]\nspecifies the increment for the elements of x.\n@param[out]\ny         device pointer storing vector y.\n@param[inout]\nincy      [int]\nspecifies the increment for the elements of y.\n"]
    pub fn hipblasHaxpy(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        alpha: *const hipblasHalf,
        x: *const hipblasHalf,
        incx: ::std::os::raw::c_int,
        y: *mut hipblasHalf,
        incy: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSaxpy(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        alpha: *const f32,
        x: *const f32,
        incx: ::std::os::raw::c_int,
        y: *mut f32,
        incy: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDaxpy(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        alpha: *const f64,
        x: *const f64,
        incx: ::std::os::raw::c_int,
        y: *mut f64,
        incy: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCaxpy(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        alpha: *const hipblasComplex,
        x: *const hipblasComplex,
        incx: ::std::os::raw::c_int,
        y: *mut hipblasComplex,
        incy: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZaxpy(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        alpha: *const hipblasDoubleComplex,
        x: *const hipblasDoubleComplex,
        incx: ::std::os::raw::c_int,
        y: *mut hipblasDoubleComplex,
        incy: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCaxpy_v2(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        alpha: *const hipComplex,
        x: *const hipComplex,
        incx: ::std::os::raw::c_int,
        y: *mut hipComplex,
        incy: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZaxpy_v2(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        alpha: *const hipDoubleComplex,
        x: *const hipDoubleComplex,
        incx: ::std::os::raw::c_int,
        y: *mut hipDoubleComplex,
        incy: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 1 API\n\n\\details\naxpyBatched   compute y := alpha * x + y over a set of batched vectors.\n\n- Supported precisions in rocBLAS : h,s,d,c,z\n- Supported precisions in cuBLAS  : No support\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n@param[in]\nn         [int]\nthe number of elements in x and y.\n@param[in]\nalpha     specifies the scalar alpha.\n@param[in]\nx         pointer storing vector x on the GPU.\n@param[in]\nincx      [int]\nspecifies the increment for the elements of x.\n@param[out]\ny         pointer storing vector y on the GPU.\n@param[inout]\nincy      [int]\nspecifies the increment for the elements of y.\n\n@param[in]\nbatchCount [int]\nnumber of instances in the batch"]
    pub fn hipblasHaxpyBatched(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        alpha: *const hipblasHalf,
        x: *const *const hipblasHalf,
        incx: ::std::os::raw::c_int,
        y: *const *mut hipblasHalf,
        incy: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSaxpyBatched(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        alpha: *const f32,
        x: *const *const f32,
        incx: ::std::os::raw::c_int,
        y: *const *mut f32,
        incy: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDaxpyBatched(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        alpha: *const f64,
        x: *const *const f64,
        incx: ::std::os::raw::c_int,
        y: *const *mut f64,
        incy: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCaxpyBatched(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        alpha: *const hipblasComplex,
        x: *const *const hipblasComplex,
        incx: ::std::os::raw::c_int,
        y: *const *mut hipblasComplex,
        incy: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZaxpyBatched(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        alpha: *const hipblasDoubleComplex,
        x: *const *const hipblasDoubleComplex,
        incx: ::std::os::raw::c_int,
        y: *const *mut hipblasDoubleComplex,
        incy: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCaxpyBatched_v2(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        alpha: *const hipComplex,
        x: *const *const hipComplex,
        incx: ::std::os::raw::c_int,
        y: *const *mut hipComplex,
        incy: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZaxpyBatched_v2(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        alpha: *const hipDoubleComplex,
        x: *const *const hipDoubleComplex,
        incx: ::std::os::raw::c_int,
        y: *const *mut hipDoubleComplex,
        incy: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 1 API\n\n\\details\naxpyStridedBatched   compute y := alpha * x + y over a set of strided batched vectors.\n\n- Supported precisions in rocBLAS : h,s,d,c,z\n- Supported precisions in cuBLAS  : No support\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n@param[in]\nn         [int]\n@param[in]\nalpha     specifies the scalar alpha.\n@param[in]\nx         pointer storing vector x on the GPU.\n@param[in]\nincx      [int]\nspecifies the increment for the elements of x.\n@param[in]\nstridex   [hipblasStride]\nspecifies the increment between vectors of x.\n@param[out]\ny         pointer storing vector y on the GPU.\n@param[inout]\nincy      [int]\nspecifies the increment for the elements of y.\n@param[in]\nstridey   [hipblasStride]\nspecifies the increment between vectors of y.\n\n@param[in]\nbatchCount [int]\nnumber of instances in the batch\n"]
    pub fn hipblasHaxpyStridedBatched(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        alpha: *const hipblasHalf,
        x: *const hipblasHalf,
        incx: ::std::os::raw::c_int,
        stridex: hipblasStride,
        y: *mut hipblasHalf,
        incy: ::std::os::raw::c_int,
        stridey: hipblasStride,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSaxpyStridedBatched(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        alpha: *const f32,
        x: *const f32,
        incx: ::std::os::raw::c_int,
        stridex: hipblasStride,
        y: *mut f32,
        incy: ::std::os::raw::c_int,
        stridey: hipblasStride,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDaxpyStridedBatched(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        alpha: *const f64,
        x: *const f64,
        incx: ::std::os::raw::c_int,
        stridex: hipblasStride,
        y: *mut f64,
        incy: ::std::os::raw::c_int,
        stridey: hipblasStride,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCaxpyStridedBatched(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        alpha: *const hipblasComplex,
        x: *const hipblasComplex,
        incx: ::std::os::raw::c_int,
        stridex: hipblasStride,
        y: *mut hipblasComplex,
        incy: ::std::os::raw::c_int,
        stridey: hipblasStride,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZaxpyStridedBatched(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        alpha: *const hipblasDoubleComplex,
        x: *const hipblasDoubleComplex,
        incx: ::std::os::raw::c_int,
        stridex: hipblasStride,
        y: *mut hipblasDoubleComplex,
        incy: ::std::os::raw::c_int,
        stridey: hipblasStride,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCaxpyStridedBatched_v2(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        alpha: *const hipComplex,
        x: *const hipComplex,
        incx: ::std::os::raw::c_int,
        stridex: hipblasStride,
        y: *mut hipComplex,
        incy: ::std::os::raw::c_int,
        stridey: hipblasStride,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZaxpyStridedBatched_v2(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        alpha: *const hipDoubleComplex,
        x: *const hipDoubleComplex,
        incx: ::std::os::raw::c_int,
        stridex: hipblasStride,
        y: *mut hipDoubleComplex,
        incy: ::std::os::raw::c_int,
        stridey: hipblasStride,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 1 API\n\n\\details\ncopy  copies each element x[i] into y[i], for  i = 1 , ... , n\n\ny := x,\n\n- Supported precisions in rocBLAS : s,d,c,z\n- Supported precisions in cuBLAS  : s,d,c,z\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n@param[in]\nn         [int]\nthe number of elements in x to be copied to y.\n@param[in]\nx         device pointer storing vector x.\n@param[in]\nincx      [int]\nspecifies the increment for the elements of x.\n@param[out]\ny         device pointer storing vector y.\n@param[in]\nincy      [int]\nspecifies the increment for the elements of y.\n"]
    pub fn hipblasScopy(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        x: *const f32,
        incx: ::std::os::raw::c_int,
        y: *mut f32,
        incy: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDcopy(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        x: *const f64,
        incx: ::std::os::raw::c_int,
        y: *mut f64,
        incy: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCcopy(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        x: *const hipblasComplex,
        incx: ::std::os::raw::c_int,
        y: *mut hipblasComplex,
        incy: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZcopy(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        x: *const hipblasDoubleComplex,
        incx: ::std::os::raw::c_int,
        y: *mut hipblasDoubleComplex,
        incy: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCcopy_v2(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        x: *const hipComplex,
        incx: ::std::os::raw::c_int,
        y: *mut hipComplex,
        incy: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZcopy_v2(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        x: *const hipDoubleComplex,
        incx: ::std::os::raw::c_int,
        y: *mut hipDoubleComplex,
        incy: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 1 API\n\n\\details\ncopyBatched copies each element x_i[j] into y_i[j], for  j = 1 , ... , n; i = 1 , ... , batchCount\n\ny_i := x_i,\n\nwhere (x_i, y_i) is the i-th instance of the batch.\nx_i and y_i are vectors.\n\n- Supported precisions in rocBLAS : s,d,c,z\n- Supported precisions in cuBLAS  : No support\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n@param[in]\nn         [int]\nthe number of elements in each x_i to be copied to y_i.\n@param[in]\nx         device array of device pointers storing each vector x_i.\n@param[in]\nincx      [int]\nspecifies the increment for the elements of each vector x_i.\n@param[out]\ny         device array of device pointers storing each vector y_i.\n@param[in]\nincy      [int]\nspecifies the increment for the elements of each vector y_i.\n@param[in]\nbatchCount [int]\nnumber of instances in the batch\n"]
    pub fn hipblasScopyBatched(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        x: *const *const f32,
        incx: ::std::os::raw::c_int,
        y: *const *mut f32,
        incy: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDcopyBatched(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        x: *const *const f64,
        incx: ::std::os::raw::c_int,
        y: *const *mut f64,
        incy: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCcopyBatched(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        x: *const *const hipblasComplex,
        incx: ::std::os::raw::c_int,
        y: *const *mut hipblasComplex,
        incy: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZcopyBatched(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        x: *const *const hipblasDoubleComplex,
        incx: ::std::os::raw::c_int,
        y: *const *mut hipblasDoubleComplex,
        incy: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCcopyBatched_v2(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        x: *const *const hipComplex,
        incx: ::std::os::raw::c_int,
        y: *const *mut hipComplex,
        incy: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZcopyBatched_v2(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        x: *const *const hipDoubleComplex,
        incx: ::std::os::raw::c_int,
        y: *const *mut hipDoubleComplex,
        incy: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 1 API\n\n\\details\ncopyStridedBatched copies each element x_i[j] into y_i[j], for  j = 1 , ... , n; i = 1 , ... , batchCount\n\ny_i := x_i,\n\nwhere (x_i, y_i) is the i-th instance of the batch.\nx_i and y_i are vectors.\n\n- Supported precisions in rocBLAS : s,d,c,z\n- Supported precisions in cuBLAS  : No support\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n@param[in]\nn         [int]\nthe number of elements in each x_i to be copied to y_i.\n@param[in]\nx         device pointer to the first vector (x_1) in the batch.\n@param[in]\nincx      [int]\nspecifies the increments for the elements of vectors x_i.\n@param[in]\nstridex     [hipblasStride]\nstride from the start of one vector (x_i) and the next one (x_i+1).\nThere are no restrictions placed on stride_x, however the user should\ntake care to ensure that stride_x is of appropriate size, for a typical\ncase this means stride_x >= n * incx.\n@param[out]\ny         device pointer to the first vector (y_1) in the batch.\n@param[in]\nincy      [int]\nspecifies the increment for the elements of vectors y_i.\n@param[in]\nstridey     [hipblasStride]\nstride from the start of one vector (y_i) and the next one (y_i+1).\nThere are no restrictions placed on stride_y, however the user should\ntake care to ensure that stride_y is of appropriate size, for a typical\ncase this means stride_y >= n * incy. stridey should be non zero.\n@param[in]\nbatchCount [int]\nnumber of instances in the batch\n"]
    pub fn hipblasScopyStridedBatched(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        x: *const f32,
        incx: ::std::os::raw::c_int,
        stridex: hipblasStride,
        y: *mut f32,
        incy: ::std::os::raw::c_int,
        stridey: hipblasStride,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDcopyStridedBatched(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        x: *const f64,
        incx: ::std::os::raw::c_int,
        stridex: hipblasStride,
        y: *mut f64,
        incy: ::std::os::raw::c_int,
        stridey: hipblasStride,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCcopyStridedBatched(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        x: *const hipblasComplex,
        incx: ::std::os::raw::c_int,
        stridex: hipblasStride,
        y: *mut hipblasComplex,
        incy: ::std::os::raw::c_int,
        stridey: hipblasStride,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZcopyStridedBatched(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        x: *const hipblasDoubleComplex,
        incx: ::std::os::raw::c_int,
        stridex: hipblasStride,
        y: *mut hipblasDoubleComplex,
        incy: ::std::os::raw::c_int,
        stridey: hipblasStride,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCcopyStridedBatched_v2(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        x: *const hipComplex,
        incx: ::std::os::raw::c_int,
        stridex: hipblasStride,
        y: *mut hipComplex,
        incy: ::std::os::raw::c_int,
        stridey: hipblasStride,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZcopyStridedBatched_v2(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        x: *const hipDoubleComplex,
        incx: ::std::os::raw::c_int,
        stridex: hipblasStride,
        y: *mut hipDoubleComplex,
        incy: ::std::os::raw::c_int,
        stridey: hipblasStride,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 1 API\n\n\\details\ndot(u)  performs the dot product of vectors x and y\n\nresult = x * y;\n\ndotc  performs the dot product of the conjugate of complex vector x and complex vector y\n\nresult = conjugate (x) * y;\n\n- Supported precisions in rocBLAS : h,bf,s,d,c,z\n- Supported precisions in cuBLAS  : s,d,c,z\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n@param[in]\nn         [int]\nthe number of elements in x and y.\n@param[in]\nx         device pointer storing vector x.\n@param[in]\nincx      [int]\nspecifies the increment for the elements of y.\n@param[in]\ny         device pointer storing vector y.\n@param[in]\nincy      [int]\nspecifies the increment for the elements of y.\n@param[inout]\nresult\ndevice pointer or host pointer to store the dot product.\nreturn is 0.0 if n <= 0.\n"]
    pub fn hipblasHdot(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        x: *const hipblasHalf,
        incx: ::std::os::raw::c_int,
        y: *const hipblasHalf,
        incy: ::std::os::raw::c_int,
        result: *mut hipblasHalf,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasBfdot(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        x: *const hipblasBfloat16,
        incx: ::std::os::raw::c_int,
        y: *const hipblasBfloat16,
        incy: ::std::os::raw::c_int,
        result: *mut hipblasBfloat16,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSdot(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        x: *const f32,
        incx: ::std::os::raw::c_int,
        y: *const f32,
        incy: ::std::os::raw::c_int,
        result: *mut f32,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDdot(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        x: *const f64,
        incx: ::std::os::raw::c_int,
        y: *const f64,
        incy: ::std::os::raw::c_int,
        result: *mut f64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCdotc(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        x: *const hipblasComplex,
        incx: ::std::os::raw::c_int,
        y: *const hipblasComplex,
        incy: ::std::os::raw::c_int,
        result: *mut hipblasComplex,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCdotu(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        x: *const hipblasComplex,
        incx: ::std::os::raw::c_int,
        y: *const hipblasComplex,
        incy: ::std::os::raw::c_int,
        result: *mut hipblasComplex,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZdotc(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        x: *const hipblasDoubleComplex,
        incx: ::std::os::raw::c_int,
        y: *const hipblasDoubleComplex,
        incy: ::std::os::raw::c_int,
        result: *mut hipblasDoubleComplex,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZdotu(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        x: *const hipblasDoubleComplex,
        incx: ::std::os::raw::c_int,
        y: *const hipblasDoubleComplex,
        incy: ::std::os::raw::c_int,
        result: *mut hipblasDoubleComplex,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCdotc_v2(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        x: *const hipComplex,
        incx: ::std::os::raw::c_int,
        y: *const hipComplex,
        incy: ::std::os::raw::c_int,
        result: *mut hipComplex,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCdotu_v2(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        x: *const hipComplex,
        incx: ::std::os::raw::c_int,
        y: *const hipComplex,
        incy: ::std::os::raw::c_int,
        result: *mut hipComplex,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZdotc_v2(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        x: *const hipDoubleComplex,
        incx: ::std::os::raw::c_int,
        y: *const hipDoubleComplex,
        incy: ::std::os::raw::c_int,
        result: *mut hipDoubleComplex,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZdotu_v2(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        x: *const hipDoubleComplex,
        incx: ::std::os::raw::c_int,
        y: *const hipDoubleComplex,
        incy: ::std::os::raw::c_int,
        result: *mut hipDoubleComplex,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 1 API\n\n\\details\ndotBatched(u) performs a batch of dot products of vectors x and y\n\nresult_i = x_i * y_i;\n\ndotcBatched  performs a batch of dot products of the conjugate of complex vector x and complex vector y\n\nresult_i = conjugate (x_i) * y_i;\n\nwhere (x_i, y_i) is the i-th instance of the batch.\nx_i and y_i are vectors, for i = 1, ..., batchCount\n\n- Supported precisions in rocBLAS : h,bf,s,d,c,z\n- Supported precisions in cuBLAS  : No support\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n@param[in]\nn         [int]\nthe number of elements in each x_i and y_i.\n@param[in]\nx         device array of device pointers storing each vector x_i.\n@param[in]\nincx      [int]\nspecifies the increment for the elements of each x_i.\n@param[in]\ny         device array of device pointers storing each vector y_i.\n@param[in]\nincy      [int]\nspecifies the increment for the elements of each y_i.\n@param[in]\nbatchCount [int]\nnumber of instances in the batch\n@param[inout]\nresult\ndevice array or host array of batchCount size to store the dot products of each batch.\nreturn 0.0 for each element if n <= 0.\n"]
    pub fn hipblasHdotBatched(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        x: *const *const hipblasHalf,
        incx: ::std::os::raw::c_int,
        y: *const *const hipblasHalf,
        incy: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
        result: *mut hipblasHalf,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasBfdotBatched(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        x: *const *const hipblasBfloat16,
        incx: ::std::os::raw::c_int,
        y: *const *const hipblasBfloat16,
        incy: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
        result: *mut hipblasBfloat16,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSdotBatched(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        x: *const *const f32,
        incx: ::std::os::raw::c_int,
        y: *const *const f32,
        incy: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
        result: *mut f32,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDdotBatched(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        x: *const *const f64,
        incx: ::std::os::raw::c_int,
        y: *const *const f64,
        incy: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
        result: *mut f64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCdotcBatched(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        x: *const *const hipblasComplex,
        incx: ::std::os::raw::c_int,
        y: *const *const hipblasComplex,
        incy: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
        result: *mut hipblasComplex,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCdotuBatched(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        x: *const *const hipblasComplex,
        incx: ::std::os::raw::c_int,
        y: *const *const hipblasComplex,
        incy: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
        result: *mut hipblasComplex,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZdotcBatched(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        x: *const *const hipblasDoubleComplex,
        incx: ::std::os::raw::c_int,
        y: *const *const hipblasDoubleComplex,
        incy: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
        result: *mut hipblasDoubleComplex,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZdotuBatched(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        x: *const *const hipblasDoubleComplex,
        incx: ::std::os::raw::c_int,
        y: *const *const hipblasDoubleComplex,
        incy: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
        result: *mut hipblasDoubleComplex,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCdotcBatched_v2(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        x: *const *const hipComplex,
        incx: ::std::os::raw::c_int,
        y: *const *const hipComplex,
        incy: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
        result: *mut hipComplex,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCdotuBatched_v2(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        x: *const *const hipComplex,
        incx: ::std::os::raw::c_int,
        y: *const *const hipComplex,
        incy: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
        result: *mut hipComplex,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZdotcBatched_v2(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        x: *const *const hipDoubleComplex,
        incx: ::std::os::raw::c_int,
        y: *const *const hipDoubleComplex,
        incy: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
        result: *mut hipDoubleComplex,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZdotuBatched_v2(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        x: *const *const hipDoubleComplex,
        incx: ::std::os::raw::c_int,
        y: *const *const hipDoubleComplex,
        incy: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
        result: *mut hipDoubleComplex,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 1 API\n\n\\details\ndotStridedBatched(u)  performs a batch of dot products of vectors x and y\n\nresult_i = x_i * y_i;\n\ndotcStridedBatched  performs a batch of dot products of the conjugate of complex vector x and complex vector y\n\nresult_i = conjugate (x_i) * y_i;\n\nwhere (x_i, y_i) is the i-th instance of the batch.\nx_i and y_i are vectors, for i = 1, ..., batchCount\n\n- Supported precisions in rocBLAS : h,bf,s,d,c,z\n- Supported precisions in cuBLAS  : No support\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n@param[in]\nn         [int]\nthe number of elements in each x_i and y_i.\n@param[in]\nx         device pointer to the first vector (x_1) in the batch.\n@param[in]\nincx      [int]\nspecifies the increment for the elements of each x_i.\n@param[in]\nstridex     [hipblasStride]\nstride from the start of one vector (x_i) and the next one (x_i+1)\n@param[in]\ny         device pointer to the first vector (y_1) in the batch.\n@param[in]\nincy      [int]\nspecifies the increment for the elements of each y_i.\n@param[in]\nstridey     [hipblasStride]\nstride from the start of one vector (y_i) and the next one (y_i+1)\n@param[in]\nbatchCount [int]\nnumber of instances in the batch\n@param[inout]\nresult\ndevice array or host array of batchCount size to store the dot products of each batch.\nreturn 0.0 for each element if n <= 0.\n"]
    pub fn hipblasHdotStridedBatched(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        x: *const hipblasHalf,
        incx: ::std::os::raw::c_int,
        stridex: hipblasStride,
        y: *const hipblasHalf,
        incy: ::std::os::raw::c_int,
        stridey: hipblasStride,
        batchCount: ::std::os::raw::c_int,
        result: *mut hipblasHalf,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasBfdotStridedBatched(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        x: *const hipblasBfloat16,
        incx: ::std::os::raw::c_int,
        stridex: hipblasStride,
        y: *const hipblasBfloat16,
        incy: ::std::os::raw::c_int,
        stridey: hipblasStride,
        batchCount: ::std::os::raw::c_int,
        result: *mut hipblasBfloat16,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSdotStridedBatched(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        x: *const f32,
        incx: ::std::os::raw::c_int,
        stridex: hipblasStride,
        y: *const f32,
        incy: ::std::os::raw::c_int,
        stridey: hipblasStride,
        batchCount: ::std::os::raw::c_int,
        result: *mut f32,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDdotStridedBatched(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        x: *const f64,
        incx: ::std::os::raw::c_int,
        stridex: hipblasStride,
        y: *const f64,
        incy: ::std::os::raw::c_int,
        stridey: hipblasStride,
        batchCount: ::std::os::raw::c_int,
        result: *mut f64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCdotcStridedBatched(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        x: *const hipblasComplex,
        incx: ::std::os::raw::c_int,
        stridex: hipblasStride,
        y: *const hipblasComplex,
        incy: ::std::os::raw::c_int,
        stridey: hipblasStride,
        batchCount: ::std::os::raw::c_int,
        result: *mut hipblasComplex,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCdotuStridedBatched(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        x: *const hipblasComplex,
        incx: ::std::os::raw::c_int,
        stridex: hipblasStride,
        y: *const hipblasComplex,
        incy: ::std::os::raw::c_int,
        stridey: hipblasStride,
        batchCount: ::std::os::raw::c_int,
        result: *mut hipblasComplex,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZdotcStridedBatched(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        x: *const hipblasDoubleComplex,
        incx: ::std::os::raw::c_int,
        stridex: hipblasStride,
        y: *const hipblasDoubleComplex,
        incy: ::std::os::raw::c_int,
        stridey: hipblasStride,
        batchCount: ::std::os::raw::c_int,
        result: *mut hipblasDoubleComplex,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZdotuStridedBatched(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        x: *const hipblasDoubleComplex,
        incx: ::std::os::raw::c_int,
        stridex: hipblasStride,
        y: *const hipblasDoubleComplex,
        incy: ::std::os::raw::c_int,
        stridey: hipblasStride,
        batchCount: ::std::os::raw::c_int,
        result: *mut hipblasDoubleComplex,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCdotcStridedBatched_v2(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        x: *const hipComplex,
        incx: ::std::os::raw::c_int,
        stridex: hipblasStride,
        y: *const hipComplex,
        incy: ::std::os::raw::c_int,
        stridey: hipblasStride,
        batchCount: ::std::os::raw::c_int,
        result: *mut hipComplex,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCdotuStridedBatched_v2(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        x: *const hipComplex,
        incx: ::std::os::raw::c_int,
        stridex: hipblasStride,
        y: *const hipComplex,
        incy: ::std::os::raw::c_int,
        stridey: hipblasStride,
        batchCount: ::std::os::raw::c_int,
        result: *mut hipComplex,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZdotcStridedBatched_v2(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        x: *const hipDoubleComplex,
        incx: ::std::os::raw::c_int,
        stridex: hipblasStride,
        y: *const hipDoubleComplex,
        incy: ::std::os::raw::c_int,
        stridey: hipblasStride,
        batchCount: ::std::os::raw::c_int,
        result: *mut hipDoubleComplex,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZdotuStridedBatched_v2(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        x: *const hipDoubleComplex,
        incx: ::std::os::raw::c_int,
        stridex: hipblasStride,
        y: *const hipDoubleComplex,
        incy: ::std::os::raw::c_int,
        stridey: hipblasStride,
        batchCount: ::std::os::raw::c_int,
        result: *mut hipDoubleComplex,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 1 API\n\n\\details\nnrm2 computes the euclidean norm of a real or complex vector\n\nresult := sqrt( x'*x ) for real vectors\nresult := sqrt( x**H*x ) for complex vectors\n\n- Supported precisions in rocBLAS : s,d,c,z,sc,dz\n- Supported precisions in cuBLAS  : s,d,sc,dz\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n@param[in]\nn         [int]\nthe number of elements in x.\n@param[in]\nx         device pointer storing vector x.\n@param[in]\nincx      [int]\nspecifies the increment for the elements of y.\n@param[inout]\nresult\ndevice pointer or host pointer to store the nrm2 product.\nreturn is 0.0 if n, incx<=0."]
    pub fn hipblasSnrm2(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        x: *const f32,
        incx: ::std::os::raw::c_int,
        result: *mut f32,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDnrm2(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        x: *const f64,
        incx: ::std::os::raw::c_int,
        result: *mut f64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasScnrm2(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        x: *const hipblasComplex,
        incx: ::std::os::raw::c_int,
        result: *mut f32,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDznrm2(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        x: *const hipblasDoubleComplex,
        incx: ::std::os::raw::c_int,
        result: *mut f64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasScnrm2_v2(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        x: *const hipComplex,
        incx: ::std::os::raw::c_int,
        result: *mut f32,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDznrm2_v2(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        x: *const hipDoubleComplex,
        incx: ::std::os::raw::c_int,
        result: *mut f64,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 1 API\n\n\\details\nnrm2Batched computes the euclidean norm over a batch of real or complex vectors\n\nresult := sqrt( x_i'*x_i ) for real vectors x, for i = 1, ..., batchCount\nresult := sqrt( x_i**H*x_i ) for complex vectors x, for i = 1, ..., batchCount\n\n- Supported precisions in rocBLAS : s,d,c,z,sc,dz\n- Supported precisions in cuBLAS  : No support\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n@param[in]\nn         [int]\nnumber of elements in each x_i.\n@param[in]\nx         device array of device pointers storing each vector x_i.\n@param[in]\nincx      [int]\nspecifies the increment for the elements of each x_i. incx must be > 0.\n@param[in]\nbatchCount [int]\nnumber of instances in the batch\n@param[out]\nresult\ndevice pointer or host pointer to array of batchCount size for nrm2 results.\nreturn is 0.0 for each element if n <= 0, incx<=0.\n"]
    pub fn hipblasSnrm2Batched(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        x: *const *const f32,
        incx: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
        result: *mut f32,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDnrm2Batched(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        x: *const *const f64,
        incx: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
        result: *mut f64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasScnrm2Batched(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        x: *const *const hipblasComplex,
        incx: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
        result: *mut f32,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDznrm2Batched(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        x: *const *const hipblasDoubleComplex,
        incx: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
        result: *mut f64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasScnrm2Batched_v2(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        x: *const *const hipComplex,
        incx: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
        result: *mut f32,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDznrm2Batched_v2(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        x: *const *const hipDoubleComplex,
        incx: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
        result: *mut f64,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 1 API\n\n\\details\nnrm2StridedBatched computes the euclidean norm over a batch of real or complex vectors\n\n:= sqrt( x_i'*x_i ) for real vectors x, for i = 1, ..., batchCount\n:= sqrt( x_i**H*x_i ) for complex vectors, for i = 1, ..., batchCount\n\n- Supported precisions in rocBLAS : s,d,c,z,sc,dz\n- Supported precisions in cuBLAS  : No support\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n@param[in]\nn         [int]\nnumber of elements in each x_i.\n@param[in]\nx         device pointer to the first vector x_1.\n@param[in]\nincx      [int]\nspecifies the increment for the elements of each x_i. incx must be > 0.\n@param[in]\nstridex   [hipblasStride]\nstride from the start of one vector (x_i) and the next one (x_i+1).\nThere are no restrictions placed on stride_x, however the user should\ntake care to ensure that stride_x is of appropriate size, for a typical\ncase this means stride_x >= n * incx.\n@param[in]\nbatchCount [int]\nnumber of instances in the batch\n@param[out]\nresult\ndevice pointer or host pointer to array for storing contiguous batchCount results.\nreturn is 0.0 for each element if n <= 0, incx<=0.\n"]
    pub fn hipblasSnrm2StridedBatched(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        x: *const f32,
        incx: ::std::os::raw::c_int,
        stridex: hipblasStride,
        batchCount: ::std::os::raw::c_int,
        result: *mut f32,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDnrm2StridedBatched(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        x: *const f64,
        incx: ::std::os::raw::c_int,
        stridex: hipblasStride,
        batchCount: ::std::os::raw::c_int,
        result: *mut f64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasScnrm2StridedBatched(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        x: *const hipblasComplex,
        incx: ::std::os::raw::c_int,
        stridex: hipblasStride,
        batchCount: ::std::os::raw::c_int,
        result: *mut f32,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDznrm2StridedBatched(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        x: *const hipblasDoubleComplex,
        incx: ::std::os::raw::c_int,
        stridex: hipblasStride,
        batchCount: ::std::os::raw::c_int,
        result: *mut f64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasScnrm2StridedBatched_v2(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        x: *const hipComplex,
        incx: ::std::os::raw::c_int,
        stridex: hipblasStride,
        batchCount: ::std::os::raw::c_int,
        result: *mut f32,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDznrm2StridedBatched_v2(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        x: *const hipDoubleComplex,
        incx: ::std::os::raw::c_int,
        stridex: hipblasStride,
        batchCount: ::std::os::raw::c_int,
        result: *mut f64,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 1 API\n\n\\details\nrot applies the Givens rotation matrix defined by c=cos(alpha) and s=sin(alpha) to vectors x and y.\nScalars c and s may be stored in either host or device memory, location is specified by calling hipblasSetPointerMode.\n\n- Supported precisions in rocBLAS : s,d,c,z,sc,dz\n- Supported precisions in cuBLAS  : s,d,c,z,cs,zd\n\n@param[in]\nhandle  [hipblasHandle_t]\nhandle to the hipblas library context queue.\n@param[in]\nn       [int]\nnumber of elements in the x and y vectors.\n@param[inout]\nx       device pointer storing vector x.\n@param[in]\nincx    [int]\nspecifies the increment between elements of x.\n@param[inout]\ny       device pointer storing vector y.\n@param[in]\nincy    [int]\nspecifies the increment between elements of y.\n@param[in]\nc       device pointer or host pointer storing scalar cosine component of the rotation matrix.\n@param[in]\ns       device pointer or host pointer storing scalar sine component of the rotation matrix.\n"]
    pub fn hipblasSrot(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        x: *mut f32,
        incx: ::std::os::raw::c_int,
        y: *mut f32,
        incy: ::std::os::raw::c_int,
        c: *const f32,
        s: *const f32,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDrot(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        x: *mut f64,
        incx: ::std::os::raw::c_int,
        y: *mut f64,
        incy: ::std::os::raw::c_int,
        c: *const f64,
        s: *const f64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCrot(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        x: *mut hipblasComplex,
        incx: ::std::os::raw::c_int,
        y: *mut hipblasComplex,
        incy: ::std::os::raw::c_int,
        c: *const f32,
        s: *const hipblasComplex,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsrot(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        x: *mut hipblasComplex,
        incx: ::std::os::raw::c_int,
        y: *mut hipblasComplex,
        incy: ::std::os::raw::c_int,
        c: *const f32,
        s: *const f32,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZrot(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        x: *mut hipblasDoubleComplex,
        incx: ::std::os::raw::c_int,
        y: *mut hipblasDoubleComplex,
        incy: ::std::os::raw::c_int,
        c: *const f64,
        s: *const hipblasDoubleComplex,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZdrot(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        x: *mut hipblasDoubleComplex,
        incx: ::std::os::raw::c_int,
        y: *mut hipblasDoubleComplex,
        incy: ::std::os::raw::c_int,
        c: *const f64,
        s: *const f64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCrot_v2(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        x: *mut hipComplex,
        incx: ::std::os::raw::c_int,
        y: *mut hipComplex,
        incy: ::std::os::raw::c_int,
        c: *const f32,
        s: *const hipComplex,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsrot_v2(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        x: *mut hipComplex,
        incx: ::std::os::raw::c_int,
        y: *mut hipComplex,
        incy: ::std::os::raw::c_int,
        c: *const f32,
        s: *const f32,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZrot_v2(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        x: *mut hipDoubleComplex,
        incx: ::std::os::raw::c_int,
        y: *mut hipDoubleComplex,
        incy: ::std::os::raw::c_int,
        c: *const f64,
        s: *const hipDoubleComplex,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZdrot_v2(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        x: *mut hipDoubleComplex,
        incx: ::std::os::raw::c_int,
        y: *mut hipDoubleComplex,
        incy: ::std::os::raw::c_int,
        c: *const f64,
        s: *const f64,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 1 API\n\n\\details\nrotBatched applies the Givens rotation matrix defined by c=cos(alpha) and s=sin(alpha) to batched vectors x_i and y_i, for i = 1, ..., batchCount.\nScalars c and s may be stored in either host or device memory, location is specified by calling hipblasSetPointerMode.\n\n- Supported precisions in rocBLAS : s,d,sc,dz\n- Supported precisions in cuBLAS  : No support\n\n@param[in]\nhandle  [hipblasHandle_t]\nhandle to the hipblas library context queue.\n@param[in]\nn       [int]\nnumber of elements in each x_i and y_i vectors.\n@param[inout]\nx       device array of device pointers storing each vector x_i.\n@param[in]\nincx    [int]\nspecifies the increment between elements of each x_i.\n@param[inout]\ny       device array of device pointers storing each vector y_i.\n@param[in]\nincy    [int]\nspecifies the increment between elements of each y_i.\n@param[in]\nc       device pointer or host pointer to scalar cosine component of the rotation matrix.\n@param[in]\ns       device pointer or host pointer to scalar sine component of the rotation matrix.\n@param[in]\nbatchCount [int]\nthe number of x and y arrays, i.e. the number of batches.\n"]
    pub fn hipblasSrotBatched(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        x: *const *mut f32,
        incx: ::std::os::raw::c_int,
        y: *const *mut f32,
        incy: ::std::os::raw::c_int,
        c: *const f32,
        s: *const f32,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDrotBatched(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        x: *const *mut f64,
        incx: ::std::os::raw::c_int,
        y: *const *mut f64,
        incy: ::std::os::raw::c_int,
        c: *const f64,
        s: *const f64,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCrotBatched(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        x: *const *mut hipblasComplex,
        incx: ::std::os::raw::c_int,
        y: *const *mut hipblasComplex,
        incy: ::std::os::raw::c_int,
        c: *const f32,
        s: *const hipblasComplex,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsrotBatched(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        x: *const *mut hipblasComplex,
        incx: ::std::os::raw::c_int,
        y: *const *mut hipblasComplex,
        incy: ::std::os::raw::c_int,
        c: *const f32,
        s: *const f32,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZrotBatched(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        x: *const *mut hipblasDoubleComplex,
        incx: ::std::os::raw::c_int,
        y: *const *mut hipblasDoubleComplex,
        incy: ::std::os::raw::c_int,
        c: *const f64,
        s: *const hipblasDoubleComplex,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZdrotBatched(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        x: *const *mut hipblasDoubleComplex,
        incx: ::std::os::raw::c_int,
        y: *const *mut hipblasDoubleComplex,
        incy: ::std::os::raw::c_int,
        c: *const f64,
        s: *const f64,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCrotBatched_v2(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        x: *const *mut hipComplex,
        incx: ::std::os::raw::c_int,
        y: *const *mut hipComplex,
        incy: ::std::os::raw::c_int,
        c: *const f32,
        s: *const hipComplex,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsrotBatched_v2(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        x: *const *mut hipComplex,
        incx: ::std::os::raw::c_int,
        y: *const *mut hipComplex,
        incy: ::std::os::raw::c_int,
        c: *const f32,
        s: *const f32,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZrotBatched_v2(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        x: *const *mut hipDoubleComplex,
        incx: ::std::os::raw::c_int,
        y: *const *mut hipDoubleComplex,
        incy: ::std::os::raw::c_int,
        c: *const f64,
        s: *const hipDoubleComplex,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZdrotBatched_v2(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        x: *const *mut hipDoubleComplex,
        incx: ::std::os::raw::c_int,
        y: *const *mut hipDoubleComplex,
        incy: ::std::os::raw::c_int,
        c: *const f64,
        s: *const f64,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 1 API\n\n\\details\nrotStridedBatched applies the Givens rotation matrix defined by c=cos(alpha) and s=sin(alpha) to strided batched vectors x_i and y_i, for i = 1, ..., batchCount.\nScalars c and s may be stored in either host or device memory, location is specified by calling hipblasSetPointerMode.\n\n- Supported precisions in rocBLAS : s,d,sc,dz\n- Supported precisions in cuBLAS  : No support\n\n@param[in]\nhandle  [hipblasHandle_t]\nhandle to the hipblas library context queue.\n@param[in]\nn       [int]\nnumber of elements in each x_i and y_i vectors.\n@param[inout]\nx       device pointer to the first vector x_1.\n@param[in]\nincx    [int]\nspecifies the increment between elements of each x_i.\n@param[in]\nstridex [hipblasStride]\nspecifies the increment from the beginning of x_i to the beginning of x_(i+1)\n@param[inout]\ny       device pointer to the first vector y_1.\n@param[in]\nincy    [int]\nspecifies the increment between elements of each y_i.\n@param[in]\nstridey  [hipblasStride]\nspecifies the increment from the beginning of y_i to the beginning of y_(i+1)\n@param[in]\nc       device pointer or host pointer to scalar cosine component of the rotation matrix.\n@param[in]\ns       device pointer or host pointer to scalar sine component of the rotation matrix.\n@param[in]\nbatchCount [int]\nthe number of x and y arrays, i.e. the number of batches.\n"]
    pub fn hipblasSrotStridedBatched(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        x: *mut f32,
        incx: ::std::os::raw::c_int,
        stridex: hipblasStride,
        y: *mut f32,
        incy: ::std::os::raw::c_int,
        stridey: hipblasStride,
        c: *const f32,
        s: *const f32,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDrotStridedBatched(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        x: *mut f64,
        incx: ::std::os::raw::c_int,
        stridex: hipblasStride,
        y: *mut f64,
        incy: ::std::os::raw::c_int,
        stridey: hipblasStride,
        c: *const f64,
        s: *const f64,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCrotStridedBatched(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        x: *mut hipblasComplex,
        incx: ::std::os::raw::c_int,
        stridex: hipblasStride,
        y: *mut hipblasComplex,
        incy: ::std::os::raw::c_int,
        stridey: hipblasStride,
        c: *const f32,
        s: *const hipblasComplex,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsrotStridedBatched(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        x: *mut hipblasComplex,
        incx: ::std::os::raw::c_int,
        stridex: hipblasStride,
        y: *mut hipblasComplex,
        incy: ::std::os::raw::c_int,
        stridey: hipblasStride,
        c: *const f32,
        s: *const f32,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZrotStridedBatched(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        x: *mut hipblasDoubleComplex,
        incx: ::std::os::raw::c_int,
        stridex: hipblasStride,
        y: *mut hipblasDoubleComplex,
        incy: ::std::os::raw::c_int,
        stridey: hipblasStride,
        c: *const f64,
        s: *const hipblasDoubleComplex,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZdrotStridedBatched(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        x: *mut hipblasDoubleComplex,
        incx: ::std::os::raw::c_int,
        stridex: hipblasStride,
        y: *mut hipblasDoubleComplex,
        incy: ::std::os::raw::c_int,
        stridey: hipblasStride,
        c: *const f64,
        s: *const f64,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCrotStridedBatched_v2(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        x: *mut hipComplex,
        incx: ::std::os::raw::c_int,
        stridex: hipblasStride,
        y: *mut hipComplex,
        incy: ::std::os::raw::c_int,
        stridey: hipblasStride,
        c: *const f32,
        s: *const hipComplex,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsrotStridedBatched_v2(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        x: *mut hipComplex,
        incx: ::std::os::raw::c_int,
        stridex: hipblasStride,
        y: *mut hipComplex,
        incy: ::std::os::raw::c_int,
        stridey: hipblasStride,
        c: *const f32,
        s: *const f32,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZrotStridedBatched_v2(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        x: *mut hipDoubleComplex,
        incx: ::std::os::raw::c_int,
        stridex: hipblasStride,
        y: *mut hipDoubleComplex,
        incy: ::std::os::raw::c_int,
        stridey: hipblasStride,
        c: *const f64,
        s: *const hipDoubleComplex,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZdrotStridedBatched_v2(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        x: *mut hipDoubleComplex,
        incx: ::std::os::raw::c_int,
        stridex: hipblasStride,
        y: *mut hipDoubleComplex,
        incy: ::std::os::raw::c_int,
        stridey: hipblasStride,
        c: *const f64,
        s: *const f64,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 1 API\n\n\\details\nrotg creates the Givens rotation matrix for the vector (a b).\nScalars c and s and arrays a and b may be stored in either host or device memory, location is specified by calling hipblasSetPointerMode.\nIf the pointer mode is set to HIPBLAS_POINTER_MODE_HOST, this function blocks the CPU until the GPU has finished and the results are available in host memory.\nIf the pointer mode is set to HIPBLAS_POINTER_MODE_DEVICE, this function returns immediately and synchronization is required to read the results.\n\n- Supported precisions in rocBLAS : s,d,c,z\n- Supported precisions in cuBLAS  : s,d,c,z\n\n@param[in]\nhandle  [hipblasHandle_t]\nhandle to the hipblas library context queue.\n@param[inout]\na       device pointer or host pointer to input vector element, overwritten with r.\n@param[inout]\nb       device pointer or host pointer to input vector element, overwritten with z.\n@param[inout]\nc       device pointer or host pointer to cosine element of Givens rotation.\n@param[inout]\ns       device pointer or host pointer sine element of Givens rotation.\n"]
    pub fn hipblasSrotg(
        handle: hipblasHandle_t,
        a: *mut f32,
        b: *mut f32,
        c: *mut f32,
        s: *mut f32,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDrotg(
        handle: hipblasHandle_t,
        a: *mut f64,
        b: *mut f64,
        c: *mut f64,
        s: *mut f64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCrotg(
        handle: hipblasHandle_t,
        a: *mut hipblasComplex,
        b: *mut hipblasComplex,
        c: *mut f32,
        s: *mut hipblasComplex,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZrotg(
        handle: hipblasHandle_t,
        a: *mut hipblasDoubleComplex,
        b: *mut hipblasDoubleComplex,
        c: *mut f64,
        s: *mut hipblasDoubleComplex,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCrotg_v2(
        handle: hipblasHandle_t,
        a: *mut hipComplex,
        b: *mut hipComplex,
        c: *mut f32,
        s: *mut hipComplex,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZrotg_v2(
        handle: hipblasHandle_t,
        a: *mut hipDoubleComplex,
        b: *mut hipDoubleComplex,
        c: *mut f64,
        s: *mut hipDoubleComplex,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 1 API\n\n\\details\nrotgBatched creates the Givens rotation matrix for the batched vectors (a_i b_i), for i = 1, ..., batchCount.\na, b, c, and s may be stored in either host or device memory, location is specified by calling hipblasSetPointerMode.\nIf the pointer mode is set to HIPBLAS_POINTER_MODE_HOST, this function blocks the CPU until the GPU has finished and the results are available in host memory.\nIf the pointer mode is set to HIPBLAS_POINTER_MODE_DEVICE, this function returns immediately and synchronization is required to read the results.\n\n- Supported precisions in rocBLAS : s,d,c,z\n- Supported precisions in cuBLAS  : No support\n\n@param[in]\nhandle  [hipblasHandle_t]\nhandle to the hipblas library context queue.\n@param[inout]\na       device array of device pointers storing each single input vector element a_i, overwritten with r_i.\n@param[inout]\nb       device array of device pointers storing each single input vector element b_i, overwritten with z_i.\n@param[inout]\nc       device array of device pointers storing each cosine element of Givens rotation for the batch.\n@param[inout]\ns       device array of device pointers storing each sine element of Givens rotation for the batch.\n@param[in]\nbatchCount [int]\nnumber of batches (length of arrays a, b, c, and s).\n"]
    pub fn hipblasSrotgBatched(
        handle: hipblasHandle_t,
        a: *const *mut f32,
        b: *const *mut f32,
        c: *const *mut f32,
        s: *const *mut f32,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDrotgBatched(
        handle: hipblasHandle_t,
        a: *const *mut f64,
        b: *const *mut f64,
        c: *const *mut f64,
        s: *const *mut f64,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCrotgBatched(
        handle: hipblasHandle_t,
        a: *const *mut hipblasComplex,
        b: *const *mut hipblasComplex,
        c: *const *mut f32,
        s: *const *mut hipblasComplex,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZrotgBatched(
        handle: hipblasHandle_t,
        a: *const *mut hipblasDoubleComplex,
        b: *const *mut hipblasDoubleComplex,
        c: *const *mut f64,
        s: *const *mut hipblasDoubleComplex,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCrotgBatched_v2(
        handle: hipblasHandle_t,
        a: *const *mut hipComplex,
        b: *const *mut hipComplex,
        c: *const *mut f32,
        s: *const *mut hipComplex,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZrotgBatched_v2(
        handle: hipblasHandle_t,
        a: *const *mut hipDoubleComplex,
        b: *const *mut hipDoubleComplex,
        c: *const *mut f64,
        s: *const *mut hipDoubleComplex,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 1 API\n\n\\details\nrotgStridedBatched creates the Givens rotation matrix for the strided batched vectors (a_i b_i), for i = 1, ..., batchCount.\na, b, c, and s may be stored in either host or device memory, location is specified by calling hipblasSetPointerMode.\nIf the pointer mode is set to HIPBLAS_POINTER_MODE_HOST, this function blocks the CPU until the GPU has finished and the results are available in host memory.\nIf the pointer mode is set to HIPBLAS_POINTER_MODE_HOST, this function returns immediately and synchronization is required to read the results.\n\n- Supported precisions in rocBLAS : s,d,c,z\n- Supported precisions in cuBLAS  : No support\n\n@param[in]\nhandle  [hipblasHandle_t]\nhandle to the hipblas library context queue.\n@param[inout]\na       device strided_batched pointer or host strided_batched pointer to first single input vector element a_1, overwritten with r.\n@param[in]\nstridea [hipblasStride]\ndistance between elements of a in batch (distance between a_i and a_(i + 1))\n@param[inout]\nb       device strided_batched pointer or host strided_batched pointer to first single input vector element b_1, overwritten with z.\n@param[in]\nstrideb [hipblasStride]\ndistance between elements of b in batch (distance between b_i and b_(i + 1))\n@param[inout]\nc       device strided_batched pointer or host strided_batched pointer to first cosine element of Givens rotations c_1.\n@param[in]\nstridec [hipblasStride]\ndistance between elements of c in batch (distance between c_i and c_(i + 1))\n@param[inout]\ns       device strided_batched pointer or host strided_batched pointer to sine element of Givens rotations s_1.\n@param[in]\nstrides [hipblasStride]\ndistance between elements of s in batch (distance between s_i and s_(i + 1))\n@param[in]\nbatchCount [int]\nnumber of batches (length of arrays a, b, c, and s).\n"]
    pub fn hipblasSrotgStridedBatched(
        handle: hipblasHandle_t,
        a: *mut f32,
        stridea: hipblasStride,
        b: *mut f32,
        strideb: hipblasStride,
        c: *mut f32,
        stridec: hipblasStride,
        s: *mut f32,
        strides: hipblasStride,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDrotgStridedBatched(
        handle: hipblasHandle_t,
        a: *mut f64,
        stridea: hipblasStride,
        b: *mut f64,
        strideb: hipblasStride,
        c: *mut f64,
        stridec: hipblasStride,
        s: *mut f64,
        strides: hipblasStride,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCrotgStridedBatched(
        handle: hipblasHandle_t,
        a: *mut hipblasComplex,
        stridea: hipblasStride,
        b: *mut hipblasComplex,
        strideb: hipblasStride,
        c: *mut f32,
        stridec: hipblasStride,
        s: *mut hipblasComplex,
        strides: hipblasStride,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZrotgStridedBatched(
        handle: hipblasHandle_t,
        a: *mut hipblasDoubleComplex,
        stridea: hipblasStride,
        b: *mut hipblasDoubleComplex,
        strideb: hipblasStride,
        c: *mut f64,
        stridec: hipblasStride,
        s: *mut hipblasDoubleComplex,
        strides: hipblasStride,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCrotgStridedBatched_v2(
        handle: hipblasHandle_t,
        a: *mut hipComplex,
        stridea: hipblasStride,
        b: *mut hipComplex,
        strideb: hipblasStride,
        c: *mut f32,
        stridec: hipblasStride,
        s: *mut hipComplex,
        strides: hipblasStride,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZrotgStridedBatched_v2(
        handle: hipblasHandle_t,
        a: *mut hipDoubleComplex,
        stridea: hipblasStride,
        b: *mut hipDoubleComplex,
        strideb: hipblasStride,
        c: *mut f64,
        stridec: hipblasStride,
        s: *mut hipDoubleComplex,
        strides: hipblasStride,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 1 API\n\n\\details\nrotm applies the modified Givens rotation matrix defined by param to vectors x and y.\n\n- Supported precisions in rocBLAS : s,d\n- Supported precisions in cuBLAS  : s,d\n\n@param[in]\nhandle  [hipblasHandle_t]\nhandle to the hipblas library context queue.\n@param[in]\nn       [int]\nnumber of elements in the x and y vectors.\n@param[inout]\nx       device pointer storing vector x.\n@param[in]\nincx    [int]\nspecifies the increment between elements of x.\n@param[inout]\ny       device pointer storing vector y.\n@param[in]\nincy    [int]\nspecifies the increment between elements of y.\n@param[in]\nparam   device vector or host vector of 5 elements defining the rotation.\nparam[0] = flag\nparam[1] = H11\nparam[2] = H21\nparam[3] = H12\nparam[4] = H22\nThe flag parameter defines the form of H:\nflag = -1 => H = ( H11 H12 H21 H22 )\nflag =  0 => H = ( 1.0 H12 H21 1.0 )\nflag =  1 => H = ( H11 1.0 -1.0 H22 )\nflag = -2 => H = ( 1.0 0.0 0.0 1.0 )\nparam may be stored in either host or device memory, location is specified by calling hipblasSetPointerMode.\n"]
    pub fn hipblasSrotm(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        x: *mut f32,
        incx: ::std::os::raw::c_int,
        y: *mut f32,
        incy: ::std::os::raw::c_int,
        param: *const f32,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDrotm(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        x: *mut f64,
        incx: ::std::os::raw::c_int,
        y: *mut f64,
        incy: ::std::os::raw::c_int,
        param: *const f64,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 1 API\n\n\\details\nrotmBatched applies the modified Givens rotation matrix defined by param_i to batched vectors x_i and y_i, for i = 1, ..., batchCount.\n\n- Supported precisions in rocBLAS : s,d\n- Supported precisions in cuBLAS  : No support\n\n@param[in]\nhandle  [hipblasHandle_t]\nhandle to the hipblas library context queue.\n@param[in]\nn       [int]\nnumber of elements in the x and y vectors.\n@param[inout]\nx       device array of device pointers storing each vector x_i.\n@param[in]\nincx    [int]\nspecifies the increment between elements of each x_i.\n@param[inout]\ny       device array of device pointers storing each vector y_1.\n@param[in]\nincy    [int]\nspecifies the increment between elements of each y_i.\n@param[in]\nparam   device array of device vectors of 5 elements defining the rotation.\nparam[0] = flag\nparam[1] = H11\nparam[2] = H21\nparam[3] = H12\nparam[4] = H22\nThe flag parameter defines the form of H:\nflag = -1 => H = ( H11 H12 H21 H22 )\nflag =  0 => H = ( 1.0 H12 H21 1.0 )\nflag =  1 => H = ( H11 1.0 -1.0 H22 )\nflag = -2 => H = ( 1.0 0.0 0.0 1.0 )\nparam may ONLY be stored on the device for the batched version of this function.\n@param[in]\nbatchCount [int]\nthe number of x and y arrays, i.e. the number of batches.\n"]
    pub fn hipblasSrotmBatched(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        x: *const *mut f32,
        incx: ::std::os::raw::c_int,
        y: *const *mut f32,
        incy: ::std::os::raw::c_int,
        param: *const *const f32,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDrotmBatched(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        x: *const *mut f64,
        incx: ::std::os::raw::c_int,
        y: *const *mut f64,
        incy: ::std::os::raw::c_int,
        param: *const *const f64,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 1 API\n\n\\details\nrotmStridedBatched applies the modified Givens rotation matrix defined by param_i to strided batched vectors x_i and y_i, for i = 1, ..., batchCount\n\n- Supported precisions in rocBLAS : s,d\n- Supported precisions in cuBLAS  : No support\n\n@param[in]\nhandle  [hipblasHandle_t]\nhandle to the hipblas library context queue.\n@param[in]\nn       [int]\nnumber of elements in the x and y vectors.\n@param[inout]\nx       device pointer pointing to first strided batched vector x_1.\n@param[in]\nincx    [int]\nspecifies the increment between elements of each x_i.\n@param[in]\nstridex [hipblasStride]\nspecifies the increment between the beginning of x_i and x_(i + 1)\n@param[inout]\ny       device pointer pointing to first strided batched vector y_1.\n@param[in]\nincy    [int]\nspecifies the increment between elements of each y_i.\n@param[in]\nstridey  [hipblasStride]\nspecifies the increment between the beginning of y_i and y_(i + 1)\n@param[in]\nparam   device pointer pointing to first array of 5 elements defining the rotation (param_1).\nparam[0] = flag\nparam[1] = H11\nparam[2] = H21\nparam[3] = H12\nparam[4] = H22\nThe flag parameter defines the form of H:\nflag = -1 => H = ( H11 H12 H21 H22 )\nflag =  0 => H = ( 1.0 H12 H21 1.0 )\nflag =  1 => H = ( H11 1.0 -1.0 H22 )\nflag = -2 => H = ( 1.0 0.0 0.0 1.0 )\nparam may ONLY be stored on the device for the strided_batched version of this function.\n@param[in]\nstrideParam [hipblasStride]\nspecifies the increment between the beginning of param_i and param_(i + 1)\n@param[in]\nbatchCount [int]\nthe number of x and y arrays, i.e. the number of batches.\n"]
    pub fn hipblasSrotmStridedBatched(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        x: *mut f32,
        incx: ::std::os::raw::c_int,
        stridex: hipblasStride,
        y: *mut f32,
        incy: ::std::os::raw::c_int,
        stridey: hipblasStride,
        param: *const f32,
        strideParam: hipblasStride,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDrotmStridedBatched(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        x: *mut f64,
        incx: ::std::os::raw::c_int,
        stridex: hipblasStride,
        y: *mut f64,
        incy: ::std::os::raw::c_int,
        stridey: hipblasStride,
        param: *const f64,
        strideParam: hipblasStride,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 1 API\n\n\\details\nrotmg creates the modified Givens rotation matrix for the vector (d1 * x1, d2 * y1).\nParameters may be stored in either host or device memory, location is specified by calling hipblasSetPointerMode.\nIf the pointer mode is set to HIPBLAS_POINTER_MODE_HOST, this function blocks the CPU until the GPU has finished and the results are available in host memory.\nIf the pointer mode is set to HIPBLAS_POINTER_MODE_DEVICE, this function returns immediately and synchronization is required to read the results.\n\n- Supported precisions in rocBLAS : s,d\n- Supported precisions in cuBLAS  : s,d\n\n@param[in]\nhandle  [hipblasHandle_t]\nhandle to the hipblas library context queue.\n@param[inout]\nd1      device pointer or host pointer to input scalar that is overwritten.\n@param[inout]\nd2      device pointer or host pointer to input scalar that is overwritten.\n@param[inout]\nx1      device pointer or host pointer to input scalar that is overwritten.\n@param[in]\ny1      device pointer or host pointer to input scalar.\n@param[out]\nparam   device vector or host vector of 5 elements defining the rotation.\nparam[0] = flag\nparam[1] = H11\nparam[2] = H21\nparam[3] = H12\nparam[4] = H22\nThe flag parameter defines the form of H:\nflag = -1 => H = ( H11 H12 H21 H22 )\nflag =  0 => H = ( 1.0 H12 H21 1.0 )\nflag =  1 => H = ( H11 1.0 -1.0 H22 )\nflag = -2 => H = ( 1.0 0.0 0.0 1.0 )\nparam may be stored in either host or device memory, location is specified by calling hipblasSetPointerMode.\n"]
    pub fn hipblasSrotmg(
        handle: hipblasHandle_t,
        d1: *mut f32,
        d2: *mut f32,
        x1: *mut f32,
        y1: *const f32,
        param: *mut f32,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDrotmg(
        handle: hipblasHandle_t,
        d1: *mut f64,
        d2: *mut f64,
        x1: *mut f64,
        y1: *const f64,
        param: *mut f64,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 1 API\n\n\\details\nrotmgBatched creates the modified Givens rotation matrix for the batched vectors (d1_i * x1_i, d2_i * y1_i), for i = 1, ..., batchCount.\nParameters may be stored in either host or device memory, location is specified by calling hipblasSetPointerMode.\nIf the pointer mode is set to HIPBLAS_POINTER_MODE_HOST, this function blocks the CPU until the GPU has finished and the results are available in host memory.\nIf the pointer mode is set to HIPBLAS_POINTER_MODE_DEVICE, this function returns immediately and synchronization is required to read the results.\n\n- Supported precisions in rocBLAS : s,d\n- Supported precisions in cuBLAS  : No support\n\n@param[in]\nhandle  [hipblasHandle_t]\nhandle to the hipblas library context queue.\n@param[inout]\nd1      device batched array or host batched array of input scalars that is overwritten.\n@param[inout]\nd2      device batched array or host batched array of input scalars that is overwritten.\n@param[inout]\nx1      device batched array or host batched array of input scalars that is overwritten.\n@param[in]\ny1      device batched array or host batched array of input scalars.\n@param[out]\nparam   device batched array or host batched array of vectors of 5 elements defining the rotation.\nparam[0] = flag\nparam[1] = H11\nparam[2] = H21\nparam[3] = H12\nparam[4] = H22\nThe flag parameter defines the form of H:\nflag = -1 => H = ( H11 H12 H21 H22 )\nflag =  0 => H = ( 1.0 H12 H21 1.0 )\nflag =  1 => H = ( H11 1.0 -1.0 H22 )\nflag = -2 => H = ( 1.0 0.0 0.0 1.0 )\nparam may be stored in either host or device memory, location is specified by calling hipblasSetPointerMode.\n@param[in]\nbatchCount [int]\nthe number of instances in the batch.\n"]
    pub fn hipblasSrotmgBatched(
        handle: hipblasHandle_t,
        d1: *const *mut f32,
        d2: *const *mut f32,
        x1: *const *mut f32,
        y1: *const *const f32,
        param: *const *mut f32,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDrotmgBatched(
        handle: hipblasHandle_t,
        d1: *const *mut f64,
        d2: *const *mut f64,
        x1: *const *mut f64,
        y1: *const *const f64,
        param: *const *mut f64,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 1 API\n\n\\details\nrotmgStridedBatched creates the modified Givens rotation matrix for the strided batched vectors (d1_i * x1_i, d2_i * y1_i), for i = 1, ..., batchCount.\nParameters may be stored in either host or device memory, location is specified by calling hipblasSetPointerMode.\nIf the pointer mode is set to HIPBLAS_POINTER_MODE_HOST, this function blocks the CPU until the GPU has finished and the results are available in host memory.\nIf the pointer mode is set to HIPBLAS_POINTER_MODE_DEVICE, this function returns immediately and synchronization is required to read the results.\n\n- Supported precisions in rocBLAS : s,d\n- Supported precisions in cuBLAS  : No support\n\n@param[in]\nhandle  [hipblasHandle_t]\nhandle to the hipblas library context queue.\n@param[inout]\nd1      device strided_batched array or host strided_batched array of input scalars that is overwritten.\n@param[in]\nstrided1 [hipblasStride]\nspecifies the increment between the beginning of d1_i and d1_(i+1)\n@param[inout]\nd2      device strided_batched array or host strided_batched array of input scalars that is overwritten.\n@param[in]\nstrided2 [hipblasStride]\nspecifies the increment between the beginning of d2_i and d2_(i+1)\n@param[inout]\nx1      device strided_batched array or host strided_batched array of input scalars that is overwritten.\n@param[in]\nstridex1 [hipblasStride]\nspecifies the increment between the beginning of x1_i and x1_(i+1)\n@param[in]\ny1      device strided_batched array or host strided_batched array of input scalars.\n@param[in]\nstridey1 [hipblasStride]\nspecifies the increment between the beginning of y1_i and y1_(i+1)\n@param[out]\nparam   device stridedBatched array or host stridedBatched array of vectors of 5 elements defining the rotation.\nparam[0] = flag\nparam[1] = H11\nparam[2] = H21\nparam[3] = H12\nparam[4] = H22\nThe flag parameter defines the form of H:\nflag = -1 => H = ( H11 H12 H21 H22 )\nflag =  0 => H = ( 1.0 H12 H21 1.0 )\nflag =  1 => H = ( H11 1.0 -1.0 H22 )\nflag = -2 => H = ( 1.0 0.0 0.0 1.0 )\nparam may be stored in either host or device memory, location is specified by calling hipblasSetPointerMode.\n@param[in]\nstrideParam [hipblasStride]\nspecifies the increment between the beginning of param_i and param_(i + 1)\n@param[in]\nbatchCount [int]\nthe number of instances in the batch.\n"]
    pub fn hipblasSrotmgStridedBatched(
        handle: hipblasHandle_t,
        d1: *mut f32,
        strided1: hipblasStride,
        d2: *mut f32,
        strided2: hipblasStride,
        x1: *mut f32,
        stridex1: hipblasStride,
        y1: *const f32,
        stridey1: hipblasStride,
        param: *mut f32,
        strideParam: hipblasStride,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDrotmgStridedBatched(
        handle: hipblasHandle_t,
        d1: *mut f64,
        strided1: hipblasStride,
        d2: *mut f64,
        strided2: hipblasStride,
        x1: *mut f64,
        stridex1: hipblasStride,
        y1: *const f64,
        stridey1: hipblasStride,
        param: *mut f64,
        strideParam: hipblasStride,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 1 API\n\n\\details\nscal  scales each element of vector x with scalar alpha.\n\nx := alpha * x\n\n- Supported precisions in rocBLAS : s,d,c,z,cs,zd\n- Supported precisions in cuBLAS  : s,d,c,z,cs,zd\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n@param[in]\nn         [int]\nthe number of elements in x.\n@param[in]\nalpha     device pointer or host pointer for the scalar alpha.\n@param[inout]\nx         device pointer storing vector x.\n@param[in]\nincx      [int]\nspecifies the increment for the elements of x.\n\n"]
    pub fn hipblasSscal(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        alpha: *const f32,
        x: *mut f32,
        incx: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDscal(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        alpha: *const f64,
        x: *mut f64,
        incx: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCscal(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        alpha: *const hipblasComplex,
        x: *mut hipblasComplex,
        incx: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsscal(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        alpha: *const f32,
        x: *mut hipblasComplex,
        incx: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZscal(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        alpha: *const hipblasDoubleComplex,
        x: *mut hipblasDoubleComplex,
        incx: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZdscal(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        alpha: *const f64,
        x: *mut hipblasDoubleComplex,
        incx: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCscal_v2(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        alpha: *const hipComplex,
        x: *mut hipComplex,
        incx: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsscal_v2(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        alpha: *const f32,
        x: *mut hipComplex,
        incx: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZscal_v2(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        alpha: *const hipDoubleComplex,
        x: *mut hipDoubleComplex,
        incx: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZdscal_v2(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        alpha: *const f64,
        x: *mut hipDoubleComplex,
        incx: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 1 API\n\\details\nscalBatched  scales each element of vector x_i with scalar alpha, for i = 1, ... , batchCount.\n\nx_i := alpha * x_i\n\nwhere (x_i) is the i-th instance of the batch.\n\n- Supported precisions in rocBLAS : s,d,c,z,cs,zd\n- Supported precisions in cuBLAS  : No support\n\n@param[in]\nhandle      [hipblasHandle_t]\nhandle to the hipblas library context queue.\n@param[in]\nn           [int]\nthe number of elements in each x_i.\n@param[in]\nalpha       host pointer or device pointer for the scalar alpha.\n@param[inout]\nx           device array of device pointers storing each vector x_i.\n@param[in]\nincx        [int]\nspecifies the increment for the elements of each x_i.\n@param[in]\nbatchCount [int]\nspecifies the number of batches in x."]
    pub fn hipblasSscalBatched(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        alpha: *const f32,
        x: *const *mut f32,
        incx: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDscalBatched(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        alpha: *const f64,
        x: *const *mut f64,
        incx: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCscalBatched(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        alpha: *const hipblasComplex,
        x: *const *mut hipblasComplex,
        incx: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZscalBatched(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        alpha: *const hipblasDoubleComplex,
        x: *const *mut hipblasDoubleComplex,
        incx: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsscalBatched(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        alpha: *const f32,
        x: *const *mut hipblasComplex,
        incx: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZdscalBatched(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        alpha: *const f64,
        x: *const *mut hipblasDoubleComplex,
        incx: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCscalBatched_v2(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        alpha: *const hipComplex,
        x: *const *mut hipComplex,
        incx: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZscalBatched_v2(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        alpha: *const hipDoubleComplex,
        x: *const *mut hipDoubleComplex,
        incx: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsscalBatched_v2(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        alpha: *const f32,
        x: *const *mut hipComplex,
        incx: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZdscalBatched_v2(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        alpha: *const f64,
        x: *const *mut hipDoubleComplex,
        incx: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 1 API\n\\details\nscalStridedBatched  scales each element of vector x_i with scalar alpha, for i = 1, ... , batchCount.\n\nx_i := alpha * x_i ,\n\nwhere (x_i) is the i-th instance of the batch.\n\n- Supported precisions in rocBLAS : s,d,c,z,cs,zd\n- Supported precisions in cuBLAS  : No support\n\n@param[in]\nhandle      [hipblasHandle_t]\nhandle to the hipblas library context queue.\n@param[in]\nn           [int]\nthe number of elements in each x_i.\n@param[in]\nalpha       host pointer or device pointer for the scalar alpha.\n@param[inout]\nx           device pointer to the first vector (x_1) in the batch.\n@param[in]\nincx        [int]\nspecifies the increment for the elements of x.\n@param[in]\nstridex     [hipblasStride]\nstride from the start of one vector (x_i) and the next one (x_i+1).\nThere are no restrictions placed on stride_x, however the user should\ntake care to ensure that stride_x is of appropriate size, for a typical\ncase this means stride_x >= n * incx.\n@param[in]\nbatchCount [int]\nspecifies the number of batches in x."]
    pub fn hipblasSscalStridedBatched(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        alpha: *const f32,
        x: *mut f32,
        incx: ::std::os::raw::c_int,
        stridex: hipblasStride,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDscalStridedBatched(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        alpha: *const f64,
        x: *mut f64,
        incx: ::std::os::raw::c_int,
        stridex: hipblasStride,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCscalStridedBatched(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        alpha: *const hipblasComplex,
        x: *mut hipblasComplex,
        incx: ::std::os::raw::c_int,
        stridex: hipblasStride,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZscalStridedBatched(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        alpha: *const hipblasDoubleComplex,
        x: *mut hipblasDoubleComplex,
        incx: ::std::os::raw::c_int,
        stridex: hipblasStride,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsscalStridedBatched(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        alpha: *const f32,
        x: *mut hipblasComplex,
        incx: ::std::os::raw::c_int,
        stridex: hipblasStride,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZdscalStridedBatched(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        alpha: *const f64,
        x: *mut hipblasDoubleComplex,
        incx: ::std::os::raw::c_int,
        stridex: hipblasStride,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCscalStridedBatched_v2(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        alpha: *const hipComplex,
        x: *mut hipComplex,
        incx: ::std::os::raw::c_int,
        stridex: hipblasStride,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZscalStridedBatched_v2(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        alpha: *const hipDoubleComplex,
        x: *mut hipDoubleComplex,
        incx: ::std::os::raw::c_int,
        stridex: hipblasStride,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsscalStridedBatched_v2(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        alpha: *const f32,
        x: *mut hipComplex,
        incx: ::std::os::raw::c_int,
        stridex: hipblasStride,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZdscalStridedBatched_v2(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        alpha: *const f64,
        x: *mut hipDoubleComplex,
        incx: ::std::os::raw::c_int,
        stridex: hipblasStride,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 1 API\n\n\\details\nswap  interchanges vectors x and y.\n\ny := x; x := y\n\n- Supported precisions in rocBLAS : s,d,c,z\n- Supported precisions in cuBLAS  : s,d,c,z\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n@param[in]\nn         [int]\nthe number of elements in x and y.\n@param[inout]\nx         device pointer storing vector x.\n@param[in]\nincx      [int]\nspecifies the increment for the elements of x.\n@param[inout]\ny         device pointer storing vector y.\n@param[in]\nincy      [int]\nspecifies the increment for the elements of y.\n"]
    pub fn hipblasSswap(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        x: *mut f32,
        incx: ::std::os::raw::c_int,
        y: *mut f32,
        incy: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDswap(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        x: *mut f64,
        incx: ::std::os::raw::c_int,
        y: *mut f64,
        incy: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCswap(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        x: *mut hipblasComplex,
        incx: ::std::os::raw::c_int,
        y: *mut hipblasComplex,
        incy: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZswap(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        x: *mut hipblasDoubleComplex,
        incx: ::std::os::raw::c_int,
        y: *mut hipblasDoubleComplex,
        incy: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCswap_v2(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        x: *mut hipComplex,
        incx: ::std::os::raw::c_int,
        y: *mut hipComplex,
        incy: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZswap_v2(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        x: *mut hipDoubleComplex,
        incx: ::std::os::raw::c_int,
        y: *mut hipDoubleComplex,
        incy: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 1 API\n\n\\details\nswapBatched interchanges vectors x_i and y_i, for i = 1 , ... , batchCount\n\ny_i := x_i; x_i := y_i\n\n- Supported precisions in rocBLAS : s,d,c,z\n- Supported precisions in cuBLAS  : No support\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n@param[in]\nn         [int]\nthe number of elements in each x_i and y_i.\n@param[inout]\nx         device array of device pointers storing each vector x_i.\n@param[in]\nincx      [int]\nspecifies the increment for the elements of each x_i.\n@param[inout]\ny         device array of device pointers storing each vector y_i.\n@param[in]\nincy      [int]\nspecifies the increment for the elements of each y_i.\n@param[in]\nbatchCount [int]\nnumber of instances in the batch.\n"]
    pub fn hipblasSswapBatched(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        x: *const *mut f32,
        incx: ::std::os::raw::c_int,
        y: *const *mut f32,
        incy: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDswapBatched(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        x: *const *mut f64,
        incx: ::std::os::raw::c_int,
        y: *const *mut f64,
        incy: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCswapBatched(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        x: *const *mut hipblasComplex,
        incx: ::std::os::raw::c_int,
        y: *const *mut hipblasComplex,
        incy: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZswapBatched(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        x: *const *mut hipblasDoubleComplex,
        incx: ::std::os::raw::c_int,
        y: *const *mut hipblasDoubleComplex,
        incy: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCswapBatched_v2(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        x: *const *mut hipComplex,
        incx: ::std::os::raw::c_int,
        y: *const *mut hipComplex,
        incy: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZswapBatched_v2(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        x: *const *mut hipDoubleComplex,
        incx: ::std::os::raw::c_int,
        y: *const *mut hipDoubleComplex,
        incy: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 1 API\n\n\\details\nswapStridedBatched interchanges vectors x_i and y_i, for i = 1 , ... , batchCount\n\ny_i := x_i; x_i := y_i\n\n- Supported precisions in rocBLAS : s,d,c,z\n- Supported precisions in cuBLAS  : No support\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n@param[in]\nn         [int]\nthe number of elements in each x_i and y_i.\n@param[inout]\nx         device pointer to the first vector x_1.\n@param[in]\nincx      [int]\nspecifies the increment for the elements of x.\n@param[in]\nstridex   [hipblasStride]\nstride from the start of one vector (x_i) and the next one (x_i+1).\nThere are no restrictions placed on stride_x, however the user should\ntake care to ensure that stride_x is of appropriate size, for a typical\ncase this means stride_x >= n * incx.\n@param[inout]\ny         device pointer to the first vector y_1.\n@param[in]\nincy      [int]\nspecifies the increment for the elements of y.\n@param[in]\nstridey   [hipblasStride]\nstride from the start of one vector (y_i) and the next one (y_i+1).\nThere are no restrictions placed on stride_x, however the user should\ntake care to ensure that stride_y is of appropriate size, for a typical\ncase this means stride_y >= n * incy. stridey should be non zero.\n@param[in]\nbatchCount [int]\nnumber of instances in the batch.\n"]
    pub fn hipblasSswapStridedBatched(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        x: *mut f32,
        incx: ::std::os::raw::c_int,
        stridex: hipblasStride,
        y: *mut f32,
        incy: ::std::os::raw::c_int,
        stridey: hipblasStride,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDswapStridedBatched(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        x: *mut f64,
        incx: ::std::os::raw::c_int,
        stridex: hipblasStride,
        y: *mut f64,
        incy: ::std::os::raw::c_int,
        stridey: hipblasStride,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCswapStridedBatched(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        x: *mut hipblasComplex,
        incx: ::std::os::raw::c_int,
        stridex: hipblasStride,
        y: *mut hipblasComplex,
        incy: ::std::os::raw::c_int,
        stridey: hipblasStride,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZswapStridedBatched(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        x: *mut hipblasDoubleComplex,
        incx: ::std::os::raw::c_int,
        stridex: hipblasStride,
        y: *mut hipblasDoubleComplex,
        incy: ::std::os::raw::c_int,
        stridey: hipblasStride,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCswapStridedBatched_v2(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        x: *mut hipComplex,
        incx: ::std::os::raw::c_int,
        stridex: hipblasStride,
        y: *mut hipComplex,
        incy: ::std::os::raw::c_int,
        stridey: hipblasStride,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZswapStridedBatched_v2(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        x: *mut hipDoubleComplex,
        incx: ::std::os::raw::c_int,
        stridex: hipblasStride,
        y: *mut hipDoubleComplex,
        incy: ::std::os::raw::c_int,
        stridey: hipblasStride,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 2 API\n\n\\details\ngbmv performs one of the matrix-vector operations\n\ny := alpha*A*x    + beta*y,   or\ny := alpha*A**T*x + beta*y,   or\ny := alpha*A**H*x + beta*y,\n\nwhere alpha and beta are scalars, x and y are vectors and A is an\nm by n banded matrix with kl sub-diagonals and ku super-diagonals.\n\n- Supported precisions in rocBLAS : s,d,c,z\n- Supported precisions in cuBLAS  : s,d,c,z\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n@param[in]\ntrans     [hipblasOperation_t]\nindicates whether matrix A is tranposed (conjugated) or not\n@param[in]\nm         [int]\nnumber of rows of matrix A\n@param[in]\nn         [int]\nnumber of columns of matrix A\n@param[in]\nkl        [int]\nnumber of sub-diagonals of A\n@param[in]\nku        [int]\nnumber of super-diagonals of A\n@param[in]\nalpha     device pointer or host pointer to scalar alpha.\n@param[in]\nAP    device pointer storing banded matrix A.\nLeading (kl + ku + 1) by n part of the matrix contains the coefficients\nof the banded matrix. The leading diagonal resides in row (ku + 1) with\nthe first super-diagonal above on the RHS of row ku. The first sub-diagonal\nresides below on the LHS of row ku + 2. This propagates up and down across\nsub/super-diagonals.\nEx: (m = n = 7; ku = 2, kl = 2)\n1 2 3 0 0 0 0             0 0 3 3 3 3 3\n4 1 2 3 0 0 0             0 2 2 2 2 2 2\n5 4 1 2 3 0 0    ---->    1 1 1 1 1 1 1\n0 5 4 1 2 3 0             4 4 4 4 4 4 0\n0 0 5 4 1 2 0             5 5 5 5 5 0 0\n0 0 0 5 4 1 2             0 0 0 0 0 0 0\n0 0 0 0 5 4 1             0 0 0 0 0 0 0\nNote that the empty elements which don't correspond to data will not\nbe referenced.\n@param[in]\nlda       [int]\nspecifies the leading dimension of A. Must be >= (kl + ku + 1)\n@param[in]\nx         device pointer storing vector x.\n@param[in]\nincx      [int]\nspecifies the increment for the elements of x.\n@param[in]\nbeta      device pointer or host pointer to scalar beta.\n@param[inout]\ny         device pointer storing vector y.\n@param[in]\nincy      [int]\nspecifies the increment for the elements of y.\n"]
    pub fn hipblasSgbmv(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        kl: ::std::os::raw::c_int,
        ku: ::std::os::raw::c_int,
        alpha: *const f32,
        AP: *const f32,
        lda: ::std::os::raw::c_int,
        x: *const f32,
        incx: ::std::os::raw::c_int,
        beta: *const f32,
        y: *mut f32,
        incy: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDgbmv(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        kl: ::std::os::raw::c_int,
        ku: ::std::os::raw::c_int,
        alpha: *const f64,
        AP: *const f64,
        lda: ::std::os::raw::c_int,
        x: *const f64,
        incx: ::std::os::raw::c_int,
        beta: *const f64,
        y: *mut f64,
        incy: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgbmv(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        kl: ::std::os::raw::c_int,
        ku: ::std::os::raw::c_int,
        alpha: *const hipblasComplex,
        AP: *const hipblasComplex,
        lda: ::std::os::raw::c_int,
        x: *const hipblasComplex,
        incx: ::std::os::raw::c_int,
        beta: *const hipblasComplex,
        y: *mut hipblasComplex,
        incy: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgbmv(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        kl: ::std::os::raw::c_int,
        ku: ::std::os::raw::c_int,
        alpha: *const hipblasDoubleComplex,
        AP: *const hipblasDoubleComplex,
        lda: ::std::os::raw::c_int,
        x: *const hipblasDoubleComplex,
        incx: ::std::os::raw::c_int,
        beta: *const hipblasDoubleComplex,
        y: *mut hipblasDoubleComplex,
        incy: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgbmv_v2(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        kl: ::std::os::raw::c_int,
        ku: ::std::os::raw::c_int,
        alpha: *const hipComplex,
        AP: *const hipComplex,
        lda: ::std::os::raw::c_int,
        x: *const hipComplex,
        incx: ::std::os::raw::c_int,
        beta: *const hipComplex,
        y: *mut hipComplex,
        incy: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgbmv_v2(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        kl: ::std::os::raw::c_int,
        ku: ::std::os::raw::c_int,
        alpha: *const hipDoubleComplex,
        AP: *const hipDoubleComplex,
        lda: ::std::os::raw::c_int,
        x: *const hipDoubleComplex,
        incx: ::std::os::raw::c_int,
        beta: *const hipDoubleComplex,
        y: *mut hipDoubleComplex,
        incy: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 2 API\n\n\\details\ngbmvBatched performs one of the matrix-vector operations\n\ny_i := alpha*A_i*x_i    + beta*y_i,   or\ny_i := alpha*A_i**T*x_i + beta*y_i,   or\ny_i := alpha*A_i**H*x_i + beta*y_i,\n\nwhere (A_i, x_i, y_i) is the i-th instance of the batch.\nalpha and beta are scalars, x_i and y_i are vectors and A_i is an\nm by n banded matrix with kl sub-diagonals and ku super-diagonals,\nfor i = 1, ..., batchCount.\n\n- Supported precisions in rocBLAS : s,d,c,z\n- Supported precisions in cuBLAS  : No support\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n@param[in]\ntrans     [hipblasOperation_t]\nindicates whether matrix A is tranposed (conjugated) or not\n@param[in]\nm         [int]\nnumber of rows of each matrix A_i\n@param[in]\nn         [int]\nnumber of columns of each matrix A_i\n@param[in]\nkl        [int]\nnumber of sub-diagonals of each A_i\n@param[in]\nku        [int]\nnumber of super-diagonals of each A_i\n@param[in]\nalpha     device pointer or host pointer to scalar alpha.\n@param[in]\nAP    device array of device pointers storing each banded matrix A_i.\nLeading (kl + ku + 1) by n part of the matrix contains the coefficients\nof the banded matrix. The leading diagonal resides in row (ku + 1) with\nthe first super-diagonal above on the RHS of row ku. The first sub-diagonal\nresides below on the LHS of row ku + 2. This propagates up and down across\nsub/super-diagonals.\nEx: (m = n = 7; ku = 2, kl = 2)\n1 2 3 0 0 0 0             0 0 3 3 3 3 3\n4 1 2 3 0 0 0             0 2 2 2 2 2 2\n5 4 1 2 3 0 0    ---->    1 1 1 1 1 1 1\n0 5 4 1 2 3 0             4 4 4 4 4 4 0\n0 0 5 4 1 2 0             5 5 5 5 5 0 0\n0 0 0 5 4 1 2             0 0 0 0 0 0 0\n0 0 0 0 5 4 1             0 0 0 0 0 0 0\nNote that the empty elements which don't correspond to data will not\nbe referenced.\n@param[in]\nlda       [int]\nspecifies the leading dimension of each A_i. Must be >= (kl + ku + 1)\n@param[in]\nx         device array of device pointers storing each vector x_i.\n@param[in]\nincx      [int]\nspecifies the increment for the elements of each x_i.\n@param[in]\nbeta      device pointer or host pointer to scalar beta.\n@param[inout]\ny         device array of device pointers storing each vector y_i.\n@param[in]\nincy      [int]\nspecifies the increment for the elements of each y_i.\n@param[in]\nbatchCount [int]\nspecifies the number of instances in the batch.\n"]
    pub fn hipblasSgbmvBatched(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        kl: ::std::os::raw::c_int,
        ku: ::std::os::raw::c_int,
        alpha: *const f32,
        AP: *const *const f32,
        lda: ::std::os::raw::c_int,
        x: *const *const f32,
        incx: ::std::os::raw::c_int,
        beta: *const f32,
        y: *const *mut f32,
        incy: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDgbmvBatched(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        kl: ::std::os::raw::c_int,
        ku: ::std::os::raw::c_int,
        alpha: *const f64,
        AP: *const *const f64,
        lda: ::std::os::raw::c_int,
        x: *const *const f64,
        incx: ::std::os::raw::c_int,
        beta: *const f64,
        y: *const *mut f64,
        incy: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgbmvBatched(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        kl: ::std::os::raw::c_int,
        ku: ::std::os::raw::c_int,
        alpha: *const hipblasComplex,
        AP: *const *const hipblasComplex,
        lda: ::std::os::raw::c_int,
        x: *const *const hipblasComplex,
        incx: ::std::os::raw::c_int,
        beta: *const hipblasComplex,
        y: *const *mut hipblasComplex,
        incy: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgbmvBatched(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        kl: ::std::os::raw::c_int,
        ku: ::std::os::raw::c_int,
        alpha: *const hipblasDoubleComplex,
        AP: *const *const hipblasDoubleComplex,
        lda: ::std::os::raw::c_int,
        x: *const *const hipblasDoubleComplex,
        incx: ::std::os::raw::c_int,
        beta: *const hipblasDoubleComplex,
        y: *const *mut hipblasDoubleComplex,
        incy: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgbmvBatched_v2(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        kl: ::std::os::raw::c_int,
        ku: ::std::os::raw::c_int,
        alpha: *const hipComplex,
        AP: *const *const hipComplex,
        lda: ::std::os::raw::c_int,
        x: *const *const hipComplex,
        incx: ::std::os::raw::c_int,
        beta: *const hipComplex,
        y: *const *mut hipComplex,
        incy: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgbmvBatched_v2(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        kl: ::std::os::raw::c_int,
        ku: ::std::os::raw::c_int,
        alpha: *const hipDoubleComplex,
        AP: *const *const hipDoubleComplex,
        lda: ::std::os::raw::c_int,
        x: *const *const hipDoubleComplex,
        incx: ::std::os::raw::c_int,
        beta: *const hipDoubleComplex,
        y: *const *mut hipDoubleComplex,
        incy: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 2 API\n\n\\details\ngbmvStridedBatched performs one of the matrix-vector operations\n\ny_i := alpha*A_i*x_i    + beta*y_i,   or\ny_i := alpha*A_i**T*x_i + beta*y_i,   or\ny_i := alpha*A_i**H*x_i + beta*y_i,\n\nwhere (A_i, x_i, y_i) is the i-th instance of the batch.\nalpha and beta are scalars, x_i and y_i are vectors and A_i is an\nm by n banded matrix with kl sub-diagonals and ku super-diagonals,\nfor i = 1, ..., batchCount.\n\n- Supported precisions in rocBLAS : s,d,c,z\n- Supported precisions in cuBLAS  : No support\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n@param[in]\ntrans     [hipblasOperation_t]\nindicates whether matrix A is tranposed (conjugated) or not\n@param[in]\nm         [int]\nnumber of rows of matrix A\n@param[in]\nn         [int]\nnumber of columns of matrix A\n@param[in]\nkl        [int]\nnumber of sub-diagonals of A\n@param[in]\nku        [int]\nnumber of super-diagonals of A\n@param[in]\nalpha     device pointer or host pointer to scalar alpha.\n@param[in]\nAP    device pointer to first banded matrix (A_1).\nLeading (kl + ku + 1) by n part of the matrix contains the coefficients\nof the banded matrix. The leading diagonal resides in row (ku + 1) with\nthe first super-diagonal above on the RHS of row ku. The first sub-diagonal\nresides below on the LHS of row ku + 2. This propagates up and down across\nsub/super-diagonals.\nEx: (m = n = 7; ku = 2, kl = 2)\n1 2 3 0 0 0 0             0 0 3 3 3 3 3\n4 1 2 3 0 0 0             0 2 2 2 2 2 2\n5 4 1 2 3 0 0    ---->    1 1 1 1 1 1 1\n0 5 4 1 2 3 0             4 4 4 4 4 4 0\n0 0 5 4 1 2 0             5 5 5 5 5 0 0\n0 0 0 5 4 1 2             0 0 0 0 0 0 0\n0 0 0 0 5 4 1             0 0 0 0 0 0 0\nNote that the empty elements which don't correspond to data will not\nbe referenced.\n@param[in]\nlda       [int]\nspecifies the leading dimension of A. Must be >= (kl + ku + 1)\n@param[in]\nstrideA  [hipblasStride]\nstride from the start of one matrix (A_i) and the next one (A_i+1)\n@param[in]\nx         device pointer to first vector (x_1).\n@param[in]\nincx      [int]\nspecifies the increment for the elements of x.\n@param[in]\nstridex  [hipblasStride]\nstride from the start of one vector (x_i) and the next one (x_i+1)\n@param[in]\nbeta      device pointer or host pointer to scalar beta.\n@param[inout]\ny         device pointer to first vector (y_1).\n@param[in]\nincy      [int]\nspecifies the increment for the elements of y.\n@param[in]\nstridey  [hipblasStride]\nstride from the start of one vector (y_i) and the next one (x_i+1)\n@param[in]\nbatchCount [int]\nspecifies the number of instances in the batch.\n"]
    pub fn hipblasSgbmvStridedBatched(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        kl: ::std::os::raw::c_int,
        ku: ::std::os::raw::c_int,
        alpha: *const f32,
        AP: *const f32,
        lda: ::std::os::raw::c_int,
        strideA: hipblasStride,
        x: *const f32,
        incx: ::std::os::raw::c_int,
        stridex: hipblasStride,
        beta: *const f32,
        y: *mut f32,
        incy: ::std::os::raw::c_int,
        stridey: hipblasStride,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDgbmvStridedBatched(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        kl: ::std::os::raw::c_int,
        ku: ::std::os::raw::c_int,
        alpha: *const f64,
        AP: *const f64,
        lda: ::std::os::raw::c_int,
        strideA: hipblasStride,
        x: *const f64,
        incx: ::std::os::raw::c_int,
        stridex: hipblasStride,
        beta: *const f64,
        y: *mut f64,
        incy: ::std::os::raw::c_int,
        stridey: hipblasStride,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgbmvStridedBatched(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        kl: ::std::os::raw::c_int,
        ku: ::std::os::raw::c_int,
        alpha: *const hipblasComplex,
        AP: *const hipblasComplex,
        lda: ::std::os::raw::c_int,
        strideA: hipblasStride,
        x: *const hipblasComplex,
        incx: ::std::os::raw::c_int,
        stridex: hipblasStride,
        beta: *const hipblasComplex,
        y: *mut hipblasComplex,
        incy: ::std::os::raw::c_int,
        stridey: hipblasStride,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgbmvStridedBatched(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        kl: ::std::os::raw::c_int,
        ku: ::std::os::raw::c_int,
        alpha: *const hipblasDoubleComplex,
        AP: *const hipblasDoubleComplex,
        lda: ::std::os::raw::c_int,
        strideA: hipblasStride,
        x: *const hipblasDoubleComplex,
        incx: ::std::os::raw::c_int,
        stridex: hipblasStride,
        beta: *const hipblasDoubleComplex,
        y: *mut hipblasDoubleComplex,
        incy: ::std::os::raw::c_int,
        stridey: hipblasStride,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgbmvStridedBatched_v2(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        kl: ::std::os::raw::c_int,
        ku: ::std::os::raw::c_int,
        alpha: *const hipComplex,
        AP: *const hipComplex,
        lda: ::std::os::raw::c_int,
        strideA: hipblasStride,
        x: *const hipComplex,
        incx: ::std::os::raw::c_int,
        stridex: hipblasStride,
        beta: *const hipComplex,
        y: *mut hipComplex,
        incy: ::std::os::raw::c_int,
        stridey: hipblasStride,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgbmvStridedBatched_v2(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        kl: ::std::os::raw::c_int,
        ku: ::std::os::raw::c_int,
        alpha: *const hipDoubleComplex,
        AP: *const hipDoubleComplex,
        lda: ::std::os::raw::c_int,
        strideA: hipblasStride,
        x: *const hipDoubleComplex,
        incx: ::std::os::raw::c_int,
        stridex: hipblasStride,
        beta: *const hipDoubleComplex,
        y: *mut hipDoubleComplex,
        incy: ::std::os::raw::c_int,
        stridey: hipblasStride,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 2 API\n\n\\details\ngemv performs one of the matrix-vector operations\n\ny := alpha*A*x    + beta*y,   or\ny := alpha*A**T*x + beta*y,   or\ny := alpha*A**H*x + beta*y,\n\nwhere alpha and beta are scalars, x and y are vectors and A is an\nm by n matrix.\n\n- Supported precisions in rocBLAS : s,d,c,z\n- Supported precisions in cuBLAS  : s,d,c,z\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n@param[in]\ntrans     [hipblasOperation_t]\nindicates whether matrix A is tranposed (conjugated) or not\n@param[in]\nm         [int]\nnumber of rows of matrix A\n@param[in]\nn         [int]\nnumber of columns of matrix A\n@param[in]\nalpha     device pointer or host pointer to scalar alpha.\n@param[in]\nAP        device pointer storing matrix A.\n@param[in]\nlda       [int]\nspecifies the leading dimension of A.\n@param[in]\nx         device pointer storing vector x.\n@param[in]\nincx      [int]\nspecifies the increment for the elements of x.\n@param[in]\nbeta      device pointer or host pointer to scalar beta.\n@param[inout]\ny         device pointer storing vector y.\n@param[in]\nincy      [int]\nspecifies the increment for the elements of y.\n"]
    pub fn hipblasSgemv(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        alpha: *const f32,
        AP: *const f32,
        lda: ::std::os::raw::c_int,
        x: *const f32,
        incx: ::std::os::raw::c_int,
        beta: *const f32,
        y: *mut f32,
        incy: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDgemv(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        alpha: *const f64,
        AP: *const f64,
        lda: ::std::os::raw::c_int,
        x: *const f64,
        incx: ::std::os::raw::c_int,
        beta: *const f64,
        y: *mut f64,
        incy: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgemv(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        alpha: *const hipblasComplex,
        AP: *const hipblasComplex,
        lda: ::std::os::raw::c_int,
        x: *const hipblasComplex,
        incx: ::std::os::raw::c_int,
        beta: *const hipblasComplex,
        y: *mut hipblasComplex,
        incy: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgemv(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        alpha: *const hipblasDoubleComplex,
        AP: *const hipblasDoubleComplex,
        lda: ::std::os::raw::c_int,
        x: *const hipblasDoubleComplex,
        incx: ::std::os::raw::c_int,
        beta: *const hipblasDoubleComplex,
        y: *mut hipblasDoubleComplex,
        incy: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgemv_v2(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        alpha: *const hipComplex,
        AP: *const hipComplex,
        lda: ::std::os::raw::c_int,
        x: *const hipComplex,
        incx: ::std::os::raw::c_int,
        beta: *const hipComplex,
        y: *mut hipComplex,
        incy: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgemv_v2(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        alpha: *const hipDoubleComplex,
        AP: *const hipDoubleComplex,
        lda: ::std::os::raw::c_int,
        x: *const hipDoubleComplex,
        incx: ::std::os::raw::c_int,
        beta: *const hipDoubleComplex,
        y: *mut hipDoubleComplex,
        incy: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 2 API\n\n\\details\ngemvBatched performs a batch of matrix-vector operations\n\ny_i := alpha*A_i*x_i    + beta*y_i,   or\ny_i := alpha*A_i**T*x_i + beta*y_i,   or\ny_i := alpha*A_i**H*x_i + beta*y_i,\n\nwhere (A_i, x_i, y_i) is the i-th instance of the batch.\nalpha and beta are scalars, x_i and y_i are vectors and A_i is an\nm by n matrix, for i = 1, ..., batchCount.\n\n- Supported precisions in rocBLAS : s,d,c,z\n- Supported precisions in cuBLAS  : No support\n\n@param[in]\nhandle      [hipblasHandle_t]\nhandle to the hipblas library context queue.\n@param[in]\ntrans       [hipblasOperation_t]\nindicates whether matrices A_i are tranposed (conjugated) or not\n@param[in]\nm           [int]\nnumber of rows of each matrix A_i\n@param[in]\nn           [int]\nnumber of columns of each matrix A_i\n@param[in]\nalpha       device pointer or host pointer to scalar alpha.\n@param[in]\nAP         device array of device pointers storing each matrix A_i.\n@param[in]\nlda         [int]\nspecifies the leading dimension of each matrix A_i.\n@param[in]\nx           device array of device pointers storing each vector x_i.\n@param[in]\nincx        [int]\nspecifies the increment for the elements of each vector x_i.\n@param[in]\nbeta        device pointer or host pointer to scalar beta.\n@param[inout]\ny           device array of device pointers storing each vector y_i.\n@param[in]\nincy        [int]\nspecifies the increment for the elements of each vector y_i.\n@param[in]\nbatchCount [int]\nnumber of instances in the batch\n"]
    pub fn hipblasSgemvBatched(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        alpha: *const f32,
        AP: *const *const f32,
        lda: ::std::os::raw::c_int,
        x: *const *const f32,
        incx: ::std::os::raw::c_int,
        beta: *const f32,
        y: *const *mut f32,
        incy: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDgemvBatched(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        alpha: *const f64,
        AP: *const *const f64,
        lda: ::std::os::raw::c_int,
        x: *const *const f64,
        incx: ::std::os::raw::c_int,
        beta: *const f64,
        y: *const *mut f64,
        incy: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgemvBatched(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        alpha: *const hipblasComplex,
        AP: *const *const hipblasComplex,
        lda: ::std::os::raw::c_int,
        x: *const *const hipblasComplex,
        incx: ::std::os::raw::c_int,
        beta: *const hipblasComplex,
        y: *const *mut hipblasComplex,
        incy: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgemvBatched(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        alpha: *const hipblasDoubleComplex,
        AP: *const *const hipblasDoubleComplex,
        lda: ::std::os::raw::c_int,
        x: *const *const hipblasDoubleComplex,
        incx: ::std::os::raw::c_int,
        beta: *const hipblasDoubleComplex,
        y: *const *mut hipblasDoubleComplex,
        incy: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgemvBatched_v2(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        alpha: *const hipComplex,
        AP: *const *const hipComplex,
        lda: ::std::os::raw::c_int,
        x: *const *const hipComplex,
        incx: ::std::os::raw::c_int,
        beta: *const hipComplex,
        y: *const *mut hipComplex,
        incy: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgemvBatched_v2(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        alpha: *const hipDoubleComplex,
        AP: *const *const hipDoubleComplex,
        lda: ::std::os::raw::c_int,
        x: *const *const hipDoubleComplex,
        incx: ::std::os::raw::c_int,
        beta: *const hipDoubleComplex,
        y: *const *mut hipDoubleComplex,
        incy: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 2 API\n\n\\details\ngemvStridedBatched performs a batch of matrix-vector operations\n\ny_i := alpha*A_i*x_i    + beta*y_i,   or\ny_i := alpha*A_i**T*x_i + beta*y_i,   or\ny_i := alpha*A_i**H*x_i + beta*y_i,\n\nwhere (A_i, x_i, y_i) is the i-th instance of the batch.\nalpha and beta are scalars, x_i and y_i are vectors and A_i is an\nm by n matrix, for i = 1, ..., batchCount.\n\n- Supported precisions in rocBLAS : s,d,c,z\n- Supported precisions in cuBLAS  : No support\n\n@param[in]\nhandle      [hipblasHandle_t]\nhandle to the hipblas library context queue.\n@param[in]\ntransA      [hipblasOperation_t]\nindicates whether matrices A_i are tranposed (conjugated) or not\n@param[in]\nm           [int]\nnumber of rows of matrices A_i\n@param[in]\nn           [int]\nnumber of columns of matrices A_i\n@param[in]\nalpha       device pointer or host pointer to scalar alpha.\n@param[in]\nAP          device pointer to the first matrix (A_1) in the batch.\n@param[in]\nlda         [int]\nspecifies the leading dimension of matrices A_i.\n@param[in]\nstrideA     [hipblasStride]\nstride from the start of one matrix (A_i) and the next one (A_i+1)\n@param[in]\nx           device pointer to the first vector (x_1) in the batch.\n@param[in]\nincx        [int]\nspecifies the increment for the elements of vectors x_i.\n@param[in]\nstridex     [hipblasStride]\nstride from the start of one vector (x_i) and the next one (x_i+1).\nThere are no restrictions placed on stridex, however the user should\ntake care to ensure that stridex is of appropriate size. When trans equals HIPBLAS_OP_N\nthis typically means stridex >= n * incx, otherwise stridex >= m * incx.\n@param[in]\nbeta        device pointer or host pointer to scalar beta.\n@param[inout]\ny           device pointer to the first vector (y_1) in the batch.\n@param[in]\nincy        [int]\nspecifies the increment for the elements of vectors y_i.\n@param[in]\nstridey     [hipblasStride]\nstride from the start of one vector (y_i) and the next one (y_i+1).\nThere are no restrictions placed on stridey, however the user should\ntake care to ensure that stridey is of appropriate size. When trans equals HIPBLAS_OP_N\nthis typically means stridey >= m * incy, otherwise stridey >= n * incy. stridey should be non zero.\n@param[in]\nbatchCount [int]\nnumber of instances in the batch\n"]
    pub fn hipblasSgemvStridedBatched(
        handle: hipblasHandle_t,
        transA: hipblasOperation_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        alpha: *const f32,
        AP: *const f32,
        lda: ::std::os::raw::c_int,
        strideA: hipblasStride,
        x: *const f32,
        incx: ::std::os::raw::c_int,
        stridex: hipblasStride,
        beta: *const f32,
        y: *mut f32,
        incy: ::std::os::raw::c_int,
        stridey: hipblasStride,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDgemvStridedBatched(
        handle: hipblasHandle_t,
        transA: hipblasOperation_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        alpha: *const f64,
        AP: *const f64,
        lda: ::std::os::raw::c_int,
        strideA: hipblasStride,
        x: *const f64,
        incx: ::std::os::raw::c_int,
        stridex: hipblasStride,
        beta: *const f64,
        y: *mut f64,
        incy: ::std::os::raw::c_int,
        stridey: hipblasStride,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgemvStridedBatched(
        handle: hipblasHandle_t,
        transA: hipblasOperation_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        alpha: *const hipblasComplex,
        AP: *const hipblasComplex,
        lda: ::std::os::raw::c_int,
        strideA: hipblasStride,
        x: *const hipblasComplex,
        incx: ::std::os::raw::c_int,
        stridex: hipblasStride,
        beta: *const hipblasComplex,
        y: *mut hipblasComplex,
        incy: ::std::os::raw::c_int,
        stridey: hipblasStride,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgemvStridedBatched(
        handle: hipblasHandle_t,
        transA: hipblasOperation_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        alpha: *const hipblasDoubleComplex,
        AP: *const hipblasDoubleComplex,
        lda: ::std::os::raw::c_int,
        strideA: hipblasStride,
        x: *const hipblasDoubleComplex,
        incx: ::std::os::raw::c_int,
        stridex: hipblasStride,
        beta: *const hipblasDoubleComplex,
        y: *mut hipblasDoubleComplex,
        incy: ::std::os::raw::c_int,
        stridey: hipblasStride,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgemvStridedBatched_v2(
        handle: hipblasHandle_t,
        transA: hipblasOperation_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        alpha: *const hipComplex,
        AP: *const hipComplex,
        lda: ::std::os::raw::c_int,
        strideA: hipblasStride,
        x: *const hipComplex,
        incx: ::std::os::raw::c_int,
        stridex: hipblasStride,
        beta: *const hipComplex,
        y: *mut hipComplex,
        incy: ::std::os::raw::c_int,
        stridey: hipblasStride,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgemvStridedBatched_v2(
        handle: hipblasHandle_t,
        transA: hipblasOperation_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        alpha: *const hipDoubleComplex,
        AP: *const hipDoubleComplex,
        lda: ::std::os::raw::c_int,
        strideA: hipblasStride,
        x: *const hipDoubleComplex,
        incx: ::std::os::raw::c_int,
        stridex: hipblasStride,
        beta: *const hipDoubleComplex,
        y: *mut hipDoubleComplex,
        incy: ::std::os::raw::c_int,
        stridey: hipblasStride,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 2 API\n\n\\details\nger,geru,gerc performs the matrix-vector operations\n\nA := A + alpha*x*y**T , OR\nA := A + alpha*x*y**H for gerc\n\nwhere alpha is a scalar, x and y are vectors, and A is an\nm by n matrix.\n\n- Supported precisions in rocBLAS : s,d,c,z\n- Supported precisions in cuBLAS  : s,d,c,z\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n@param[in]\nm         [int]\nthe number of rows of the matrix A.\n@param[in]\nn         [int]\nthe number of columns of the matrix A.\n@param[in]\nalpha\ndevice pointer or host pointer to scalar alpha.\n@param[in]\nx         device pointer storing vector x.\n@param[in]\nincx      [int]\nspecifies the increment for the elements of x.\n@param[in]\ny         device pointer storing vector y.\n@param[in]\nincy      [int]\nspecifies the increment for the elements of y.\n@param[inout]\nAP         device pointer storing matrix A.\n@param[in]\nlda       [int]\nspecifies the leading dimension of A.\n"]
    pub fn hipblasSger(
        handle: hipblasHandle_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        alpha: *const f32,
        x: *const f32,
        incx: ::std::os::raw::c_int,
        y: *const f32,
        incy: ::std::os::raw::c_int,
        AP: *mut f32,
        lda: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDger(
        handle: hipblasHandle_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        alpha: *const f64,
        x: *const f64,
        incx: ::std::os::raw::c_int,
        y: *const f64,
        incy: ::std::os::raw::c_int,
        AP: *mut f64,
        lda: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgeru(
        handle: hipblasHandle_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        alpha: *const hipblasComplex,
        x: *const hipblasComplex,
        incx: ::std::os::raw::c_int,
        y: *const hipblasComplex,
        incy: ::std::os::raw::c_int,
        AP: *mut hipblasComplex,
        lda: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgerc(
        handle: hipblasHandle_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        alpha: *const hipblasComplex,
        x: *const hipblasComplex,
        incx: ::std::os::raw::c_int,
        y: *const hipblasComplex,
        incy: ::std::os::raw::c_int,
        AP: *mut hipblasComplex,
        lda: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgeru(
        handle: hipblasHandle_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        alpha: *const hipblasDoubleComplex,
        x: *const hipblasDoubleComplex,
        incx: ::std::os::raw::c_int,
        y: *const hipblasDoubleComplex,
        incy: ::std::os::raw::c_int,
        AP: *mut hipblasDoubleComplex,
        lda: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgerc(
        handle: hipblasHandle_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        alpha: *const hipblasDoubleComplex,
        x: *const hipblasDoubleComplex,
        incx: ::std::os::raw::c_int,
        y: *const hipblasDoubleComplex,
        incy: ::std::os::raw::c_int,
        AP: *mut hipblasDoubleComplex,
        lda: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgeru_v2(
        handle: hipblasHandle_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        alpha: *const hipComplex,
        x: *const hipComplex,
        incx: ::std::os::raw::c_int,
        y: *const hipComplex,
        incy: ::std::os::raw::c_int,
        AP: *mut hipComplex,
        lda: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgerc_v2(
        handle: hipblasHandle_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        alpha: *const hipComplex,
        x: *const hipComplex,
        incx: ::std::os::raw::c_int,
        y: *const hipComplex,
        incy: ::std::os::raw::c_int,
        AP: *mut hipComplex,
        lda: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgeru_v2(
        handle: hipblasHandle_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        alpha: *const hipDoubleComplex,
        x: *const hipDoubleComplex,
        incx: ::std::os::raw::c_int,
        y: *const hipDoubleComplex,
        incy: ::std::os::raw::c_int,
        AP: *mut hipDoubleComplex,
        lda: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgerc_v2(
        handle: hipblasHandle_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        alpha: *const hipDoubleComplex,
        x: *const hipDoubleComplex,
        incx: ::std::os::raw::c_int,
        y: *const hipDoubleComplex,
        incy: ::std::os::raw::c_int,
        AP: *mut hipDoubleComplex,
        lda: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 2 API\n\n\\details\ngerBatched,geruBatched,gercBatched performs a batch of the matrix-vector operations\n\nA := A + alpha*x*y**T , OR\nA := A + alpha*x*y**H for gerc\n\nwhere (A_i, x_i, y_i) is the i-th instance of the batch.\nalpha is a scalar, x_i and y_i are vectors and A_i is an\nm by n matrix, for i = 1, ..., batchCount.\n\n- Supported precisions in rocBLAS : s,d,c,z\n- Supported precisions in cuBLAS  : No support\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n@param[in]\nm         [int]\nthe number of rows of each matrix A_i.\n@param[in]\nn         [int]\nthe number of columns of eaceh matrix A_i.\n@param[in]\nalpha\ndevice pointer or host pointer to scalar alpha.\n@param[in]\nx         device array of device pointers storing each vector x_i.\n@param[in]\nincx      [int]\nspecifies the increment for the elements of each vector x_i.\n@param[in]\ny         device array of device pointers storing each vector y_i.\n@param[in]\nincy      [int]\nspecifies the increment for the elements of each vector y_i.\n@param[inout]\nAP        device array of device pointers storing each matrix A_i.\n@param[in]\nlda       [int]\nspecifies the leading dimension of each A_i.\n@param[in]\nbatchCount [int]\nnumber of instances in the batch\n"]
    pub fn hipblasSgerBatched(
        handle: hipblasHandle_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        alpha: *const f32,
        x: *const *const f32,
        incx: ::std::os::raw::c_int,
        y: *const *const f32,
        incy: ::std::os::raw::c_int,
        AP: *const *mut f32,
        lda: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDgerBatched(
        handle: hipblasHandle_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        alpha: *const f64,
        x: *const *const f64,
        incx: ::std::os::raw::c_int,
        y: *const *const f64,
        incy: ::std::os::raw::c_int,
        AP: *const *mut f64,
        lda: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgeruBatched(
        handle: hipblasHandle_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        alpha: *const hipblasComplex,
        x: *const *const hipblasComplex,
        incx: ::std::os::raw::c_int,
        y: *const *const hipblasComplex,
        incy: ::std::os::raw::c_int,
        AP: *const *mut hipblasComplex,
        lda: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgercBatched(
        handle: hipblasHandle_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        alpha: *const hipblasComplex,
        x: *const *const hipblasComplex,
        incx: ::std::os::raw::c_int,
        y: *const *const hipblasComplex,
        incy: ::std::os::raw::c_int,
        AP: *const *mut hipblasComplex,
        lda: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgeruBatched(
        handle: hipblasHandle_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        alpha: *const hipblasDoubleComplex,
        x: *const *const hipblasDoubleComplex,
        incx: ::std::os::raw::c_int,
        y: *const *const hipblasDoubleComplex,
        incy: ::std::os::raw::c_int,
        AP: *const *mut hipblasDoubleComplex,
        lda: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgercBatched(
        handle: hipblasHandle_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        alpha: *const hipblasDoubleComplex,
        x: *const *const hipblasDoubleComplex,
        incx: ::std::os::raw::c_int,
        y: *const *const hipblasDoubleComplex,
        incy: ::std::os::raw::c_int,
        AP: *const *mut hipblasDoubleComplex,
        lda: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgeruBatched_v2(
        handle: hipblasHandle_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        alpha: *const hipComplex,
        x: *const *const hipComplex,
        incx: ::std::os::raw::c_int,
        y: *const *const hipComplex,
        incy: ::std::os::raw::c_int,
        AP: *const *mut hipComplex,
        lda: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgercBatched_v2(
        handle: hipblasHandle_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        alpha: *const hipComplex,
        x: *const *const hipComplex,
        incx: ::std::os::raw::c_int,
        y: *const *const hipComplex,
        incy: ::std::os::raw::c_int,
        AP: *const *mut hipComplex,
        lda: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgeruBatched_v2(
        handle: hipblasHandle_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        alpha: *const hipDoubleComplex,
        x: *const *const hipDoubleComplex,
        incx: ::std::os::raw::c_int,
        y: *const *const hipDoubleComplex,
        incy: ::std::os::raw::c_int,
        AP: *const *mut hipDoubleComplex,
        lda: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgercBatched_v2(
        handle: hipblasHandle_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        alpha: *const hipDoubleComplex,
        x: *const *const hipDoubleComplex,
        incx: ::std::os::raw::c_int,
        y: *const *const hipDoubleComplex,
        incy: ::std::os::raw::c_int,
        AP: *const *mut hipDoubleComplex,
        lda: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 2 API\n\n\\details\ngerStridedBatched,geruStridedBatched,gercStridedBatched performs the matrix-vector operations\n\nA_i := A_i + alpha*x_i*y_i**T, OR\nA_i := A_i + alpha*x_i*y_i**H  for gerc\n\nwhere (A_i, x_i, y_i) is the i-th instance of the batch.\nalpha is a scalar, x_i and y_i are vectors and A_i is an\nm by n matrix, for i = 1, ..., batchCount.\n\n- Supported precisions in rocBLAS : s,d,c,z\n- Supported precisions in cuBLAS  : No support\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n@param[in]\nm         [int]\nthe number of rows of each matrix A_i.\n@param[in]\nn         [int]\nthe number of columns of each matrix A_i.\n@param[in]\nalpha\ndevice pointer or host pointer to scalar alpha.\n@param[in]\nx         device pointer to the first vector (x_1) in the batch.\n@param[in]\nincx      [int]\nspecifies the increments for the elements of each vector x_i.\n@param[in]\nstridex   [hipblasStride]\nstride from the start of one vector (x_i) and the next one (x_i+1).\nThere are no restrictions placed on stridex, however the user should\ntake care to ensure that stridex is of appropriate size, for a typical\ncase this means stridex >= m * incx.\n@param[inout]\ny         device pointer to the first vector (y_1) in the batch.\n@param[in]\nincy      [int]\nspecifies the increment for the elements of each vector y_i.\n@param[in]\nstridey   [hipblasStride]\nstride from the start of one vector (y_i) and the next one (y_i+1).\nThere are no restrictions placed on stridey, however the user should\ntake care to ensure that stridey is of appropriate size, for a typical\ncase this means stridey >= n * incy.\n@param[inout]\nAP        device pointer to the first matrix (A_1) in the batch.\n@param[in]\nlda       [int]\nspecifies the leading dimension of each A_i.\n@param[in]\nstrideA     [hipblasStride]\nstride from the start of one matrix (A_i) and the next one (A_i+1)\n@param[in]\nbatchCount [int]\nnumber of instances in the batch\n"]
    pub fn hipblasSgerStridedBatched(
        handle: hipblasHandle_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        alpha: *const f32,
        x: *const f32,
        incx: ::std::os::raw::c_int,
        stridex: hipblasStride,
        y: *const f32,
        incy: ::std::os::raw::c_int,
        stridey: hipblasStride,
        AP: *mut f32,
        lda: ::std::os::raw::c_int,
        strideA: hipblasStride,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDgerStridedBatched(
        handle: hipblasHandle_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        alpha: *const f64,
        x: *const f64,
        incx: ::std::os::raw::c_int,
        stridex: hipblasStride,
        y: *const f64,
        incy: ::std::os::raw::c_int,
        stridey: hipblasStride,
        AP: *mut f64,
        lda: ::std::os::raw::c_int,
        strideA: hipblasStride,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgeruStridedBatched(
        handle: hipblasHandle_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        alpha: *const hipblasComplex,
        x: *const hipblasComplex,
        incx: ::std::os::raw::c_int,
        stridex: hipblasStride,
        y: *const hipblasComplex,
        incy: ::std::os::raw::c_int,
        stridey: hipblasStride,
        AP: *mut hipblasComplex,
        lda: ::std::os::raw::c_int,
        strideA: hipblasStride,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgercStridedBatched(
        handle: hipblasHandle_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        alpha: *const hipblasComplex,
        x: *const hipblasComplex,
        incx: ::std::os::raw::c_int,
        stridex: hipblasStride,
        y: *const hipblasComplex,
        incy: ::std::os::raw::c_int,
        stridey: hipblasStride,
        AP: *mut hipblasComplex,
        lda: ::std::os::raw::c_int,
        strideA: hipblasStride,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgeruStridedBatched(
        handle: hipblasHandle_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        alpha: *const hipblasDoubleComplex,
        x: *const hipblasDoubleComplex,
        incx: ::std::os::raw::c_int,
        stridex: hipblasStride,
        y: *const hipblasDoubleComplex,
        incy: ::std::os::raw::c_int,
        stridey: hipblasStride,
        AP: *mut hipblasDoubleComplex,
        lda: ::std::os::raw::c_int,
        strideA: hipblasStride,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgercStridedBatched(
        handle: hipblasHandle_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        alpha: *const hipblasDoubleComplex,
        x: *const hipblasDoubleComplex,
        incx: ::std::os::raw::c_int,
        stridex: hipblasStride,
        y: *const hipblasDoubleComplex,
        incy: ::std::os::raw::c_int,
        stridey: hipblasStride,
        AP: *mut hipblasDoubleComplex,
        lda: ::std::os::raw::c_int,
        strideA: hipblasStride,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgeruStridedBatched_v2(
        handle: hipblasHandle_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        alpha: *const hipComplex,
        x: *const hipComplex,
        incx: ::std::os::raw::c_int,
        stridex: hipblasStride,
        y: *const hipComplex,
        incy: ::std::os::raw::c_int,
        stridey: hipblasStride,
        AP: *mut hipComplex,
        lda: ::std::os::raw::c_int,
        strideA: hipblasStride,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgercStridedBatched_v2(
        handle: hipblasHandle_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        alpha: *const hipComplex,
        x: *const hipComplex,
        incx: ::std::os::raw::c_int,
        stridex: hipblasStride,
        y: *const hipComplex,
        incy: ::std::os::raw::c_int,
        stridey: hipblasStride,
        AP: *mut hipComplex,
        lda: ::std::os::raw::c_int,
        strideA: hipblasStride,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgeruStridedBatched_v2(
        handle: hipblasHandle_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        alpha: *const hipDoubleComplex,
        x: *const hipDoubleComplex,
        incx: ::std::os::raw::c_int,
        stridex: hipblasStride,
        y: *const hipDoubleComplex,
        incy: ::std::os::raw::c_int,
        stridey: hipblasStride,
        AP: *mut hipDoubleComplex,
        lda: ::std::os::raw::c_int,
        strideA: hipblasStride,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgercStridedBatched_v2(
        handle: hipblasHandle_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        alpha: *const hipDoubleComplex,
        x: *const hipDoubleComplex,
        incx: ::std::os::raw::c_int,
        stridex: hipblasStride,
        y: *const hipDoubleComplex,
        incy: ::std::os::raw::c_int,
        stridey: hipblasStride,
        AP: *mut hipDoubleComplex,
        lda: ::std::os::raw::c_int,
        strideA: hipblasStride,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 2 API\n\n\\details\nhbmv performs the matrix-vector operations\n\ny := alpha*A*x + beta*y\n\nwhere alpha and beta are scalars, x and y are n element vectors and A is an\nn by n Hermitian band matrix, with k super-diagonals.\n\n- Supported precisions in rocBLAS : c,z\n- Supported precisions in cuBLAS  : c,z\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n@param[in]\nuplo      [hipblasFillMode_t]\nHIPBLAS_FILL_MODE_UPPER: The upper triangular part of A is being supplied.\nHIPBLAS_FILL_MODE_LOWER: The lower triangular part of A is being supplied.\n@param[in]\nn         [int]\nthe order of the matrix A.\n@param[in]\nk         [int]\nthe number of super-diagonals of the matrix A. Must be >= 0.\n@param[in]\nalpha     device pointer or host pointer to scalar alpha.\n@param[in]\nAP        device pointer storing matrix A. Of dimension (lda, n).\nif uplo == HIPBLAS_FILL_MODE_UPPER:\nThe leading (k + 1) by n part of A must contain the upper\ntriangular band part of the Hermitian matrix, with the leading\ndiagonal in row (k + 1), the first super-diagonal on the RHS\nof row k, etc.\nThe top left k by x triangle of A will not be referenced.\nEx (upper, lda = n = 4, k = 1):\nA                             Represented matrix\n(0,0) (5,9) (6,8) (7,7)       (1, 0) (5, 9) (0, 0) (0, 0)\n(1,0) (2,0) (3,0) (4,0)       (5,-9) (2, 0) (6, 8) (0, 0)\n(0,0) (0,0) (0,0) (0,0)       (0, 0) (6,-8) (3, 0) (7, 7)\n(0,0) (0,0) (0,0) (0,0)       (0, 0) (0, 0) (7,-7) (4, 0)\n\nif uplo == HIPBLAS_FILL_MODE_LOWER:\nThe leading (k + 1) by n part of A must contain the lower\ntriangular band part of the Hermitian matrix, with the leading\ndiagonal in row (1), the first sub-diagonal on the LHS of\nrow 2, etc.\nThe bottom right k by k triangle of A will not be referenced.\nEx (lower, lda = 2, n = 4, k = 1):\nA                               Represented matrix\n(1,0) (2,0) (3,0) (4,0)         (1, 0) (5,-9) (0, 0) (0, 0)\n(5,9) (6,8) (7,7) (0,0)         (5, 9) (2, 0) (6,-8) (0, 0)\n(0, 0) (6, 8) (3, 0) (7,-7)\n(0, 0) (0, 0) (7, 7) (4, 0)\n\nAs a Hermitian matrix, the imaginary part of the main diagonal\nof A will not be referenced and is assumed to be == 0.\n@param[in]\nlda       [int]\nspecifies the leading dimension of A. must be >= k + 1\n@param[in]\nx         device pointer storing vector x.\n@param[in]\nincx      [int]\nspecifies the increment for the elements of x.\n@param[in]\nbeta      device pointer or host pointer to scalar beta.\n@param[inout]\ny         device pointer storing vector y.\n@param[in]\nincy      [int]\nspecifies the increment for the elements of y.\n"]
    pub fn hipblasChbmv(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        alpha: *const hipblasComplex,
        AP: *const hipblasComplex,
        lda: ::std::os::raw::c_int,
        x: *const hipblasComplex,
        incx: ::std::os::raw::c_int,
        beta: *const hipblasComplex,
        y: *mut hipblasComplex,
        incy: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZhbmv(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        alpha: *const hipblasDoubleComplex,
        AP: *const hipblasDoubleComplex,
        lda: ::std::os::raw::c_int,
        x: *const hipblasDoubleComplex,
        incx: ::std::os::raw::c_int,
        beta: *const hipblasDoubleComplex,
        y: *mut hipblasDoubleComplex,
        incy: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasChbmv_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        alpha: *const hipComplex,
        AP: *const hipComplex,
        lda: ::std::os::raw::c_int,
        x: *const hipComplex,
        incx: ::std::os::raw::c_int,
        beta: *const hipComplex,
        y: *mut hipComplex,
        incy: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZhbmv_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        alpha: *const hipDoubleComplex,
        AP: *const hipDoubleComplex,
        lda: ::std::os::raw::c_int,
        x: *const hipDoubleComplex,
        incx: ::std::os::raw::c_int,
        beta: *const hipDoubleComplex,
        y: *mut hipDoubleComplex,
        incy: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 2 API\n\n\\details\nhbmvBatched performs one of the matrix-vector operations\n\ny_i := alpha*A_i*x_i + beta*y_i\n\nwhere alpha and beta are scalars, x_i and y_i are n element vectors and A_i is an\nn by n Hermitian band matrix with k super-diagonals, for each batch in i = [1, batchCount].\n\n- Supported precisions in rocBLAS : c,z\n- Supported precisions in cuBLAS  : No support\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n@param[in]\nuplo      [hipblasFillMode_t]\nHIPBLAS_FILL_MODE_UPPER: The upper triangular part of each A_i is being supplied.\nHIPBLAS_FILL_MODE_LOWER: The lower triangular part of each A_i is being supplied.\n@param[in]\nn         [int]\nthe order of each matrix A_i.\n@param[in]\nk         [int]\nthe number of super-diagonals of each matrix A_i. Must be >= 0.\n@param[in]\nalpha     device pointer or host pointer to scalar alpha.\n@param[in]\nAP        device array of device pointers storing each matrix_i A of dimension (lda, n).\nif uplo == HIPBLAS_FILL_MODE_UPPER:\nThe leading (k + 1) by n part of each A_i must contain the upper\ntriangular band part of the Hermitian matrix, with the leading\ndiagonal in row (k + 1), the first super-diagonal on the RHS\nof row k, etc.\nThe top left k by x triangle of each A_i will not be referenced.\nEx (upper, lda = n = 4, k = 1):\nA                             Represented matrix\n(0,0) (5,9) (6,8) (7,7)       (1, 0) (5, 9) (0, 0) (0, 0)\n(1,0) (2,0) (3,0) (4,0)       (5,-9) (2, 0) (6, 8) (0, 0)\n(0,0) (0,0) (0,0) (0,0)       (0, 0) (6,-8) (3, 0) (7, 7)\n(0,0) (0,0) (0,0) (0,0)       (0, 0) (0, 0) (7,-7) (4, 0)\n\nif uplo == HIPBLAS_FILL_MODE_LOWER:\nThe leading (k + 1) by n part of each A_i must contain the lower\ntriangular band part of the Hermitian matrix, with the leading\ndiagonal in row (1), the first sub-diagonal on the LHS of\nrow 2, etc.\nThe bottom right k by k triangle of each A_i will not be referenced.\nEx (lower, lda = 2, n = 4, k = 1):\nA                               Represented matrix\n(1,0) (2,0) (3,0) (4,0)         (1, 0) (5,-9) (0, 0) (0, 0)\n(5,9) (6,8) (7,7) (0,0)         (5, 9) (2, 0) (6,-8) (0, 0)\n(0, 0) (6, 8) (3, 0) (7,-7)\n(0, 0) (0, 0) (7, 7) (4, 0)\n\nAs a Hermitian matrix, the imaginary part of the main diagonal\nof each A_i will not be referenced and is assumed to be == 0.\n@param[in]\nlda       [int]\nspecifies the leading dimension of each A_i. must be >= max(1, n)\n@param[in]\nx         device array of device pointers storing each vector x_i.\n@param[in]\nincx      [int]\nspecifies the increment for the elements of each x_i.\n@param[in]\nbeta      device pointer or host pointer to scalar beta.\n@param[inout]\ny         device array of device pointers storing each vector y_i.\n@param[in]\nincy      [int]\nspecifies the increment for the elements of y.\n@param[in]\nbatchCount [int]\nnumber of instances in the batch.\n"]
    pub fn hipblasChbmvBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        alpha: *const hipblasComplex,
        AP: *const *const hipblasComplex,
        lda: ::std::os::raw::c_int,
        x: *const *const hipblasComplex,
        incx: ::std::os::raw::c_int,
        beta: *const hipblasComplex,
        y: *const *mut hipblasComplex,
        incy: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZhbmvBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        alpha: *const hipblasDoubleComplex,
        AP: *const *const hipblasDoubleComplex,
        lda: ::std::os::raw::c_int,
        x: *const *const hipblasDoubleComplex,
        incx: ::std::os::raw::c_int,
        beta: *const hipblasDoubleComplex,
        y: *const *mut hipblasDoubleComplex,
        incy: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasChbmvBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        alpha: *const hipComplex,
        AP: *const *const hipComplex,
        lda: ::std::os::raw::c_int,
        x: *const *const hipComplex,
        incx: ::std::os::raw::c_int,
        beta: *const hipComplex,
        y: *const *mut hipComplex,
        incy: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZhbmvBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        alpha: *const hipDoubleComplex,
        AP: *const *const hipDoubleComplex,
        lda: ::std::os::raw::c_int,
        x: *const *const hipDoubleComplex,
        incx: ::std::os::raw::c_int,
        beta: *const hipDoubleComplex,
        y: *const *mut hipDoubleComplex,
        incy: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 2 API\n\n\\details\nhbmvStridedBatched performs one of the matrix-vector operations\n\ny_i := alpha*A_i*x_i + beta*y_i\n\nwhere alpha and beta are scalars, x_i and y_i are n element vectors and A_i is an\nn by n Hermitian band matrix with k super-diagonals, for each batch in i = [1, batchCount].\n\n- Supported precisions in rocBLAS : c,z\n- Supported precisions in cuBLAS  : No support\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n@param[in]\nuplo      [hipblasFillMode_t]\nHIPBLAS_FILL_MODE_UPPER: The upper triangular part of each A_i is being supplied.\nHIPBLAS_FILL_MODE_LOWER: The lower triangular part of each A_i is being supplied.\n@param[in]\nn         [int]\nthe order of each matrix A_i.\n@param[in]\nk         [int]\nthe number of super-diagonals of each matrix A_i. Must be >= 0.\n@param[in]\nalpha     device pointer or host pointer to scalar alpha.\n@param[in]\nAP        device array pointing to the first matrix A_1. Each A_i is of dimension (lda, n).\nif uplo == HIPBLAS_FILL_MODE_UPPER:\nThe leading (k + 1) by n part of each A_i must contain the upper\ntriangular band part of the Hermitian matrix, with the leading\ndiagonal in row (k + 1), the first super-diagonal on the RHS\nof row k, etc.\nThe top left k by x triangle of each A_i will not be referenced.\nEx (upper, lda = n = 4, k = 1):\nA                             Represented matrix\n(0,0) (5,9) (6,8) (7,7)       (1, 0) (5, 9) (0, 0) (0, 0)\n(1,0) (2,0) (3,0) (4,0)       (5,-9) (2, 0) (6, 8) (0, 0)\n(0,0) (0,0) (0,0) (0,0)       (0, 0) (6,-8) (3, 0) (7, 7)\n(0,0) (0,0) (0,0) (0,0)       (0, 0) (0, 0) (7,-7) (4, 0)\n\nif uplo == HIPBLAS_FILL_MODE_LOWER:\nThe leading (k + 1) by n part of each A_i must contain the lower\ntriangular band part of the Hermitian matrix, with the leading\ndiagonal in row (1), the first sub-diagonal on the LHS of\nrow 2, etc.\nThe bottom right k by k triangle of each A_i will not be referenced.\nEx (lower, lda = 2, n = 4, k = 1):\nA                               Represented matrix\n(1,0) (2,0) (3,0) (4,0)         (1, 0) (5,-9) (0, 0) (0, 0)\n(5,9) (6,8) (7,7) (0,0)         (5, 9) (2, 0) (6,-8) (0, 0)\n(0, 0) (6, 8) (3, 0) (7,-7)\n(0, 0) (0, 0) (7, 7) (4, 0)\n\nAs a Hermitian matrix, the imaginary part of the main diagonal\nof each A_i will not be referenced and is assumed to be == 0.\n@param[in]\nlda       [int]\nspecifies the leading dimension of each A_i. must be >= max(1, n)\n@param[in]\nstrideA  [hipblasStride]\nstride from the start of one matrix (A_i) and the next one (A_i+1)\n@param[in]\nx         device array pointing to the first vector y_1.\n@param[in]\nincx      [int]\nspecifies the increment for the elements of each x_i.\n@param[in]\nstridex  [hipblasStride]\nstride from the start of one vector (x_i) and the next one (x_i+1)\n@param[in]\nbeta      device pointer or host pointer to scalar beta.\n@param[inout]\ny         device array pointing to the first vector y_1.\n@param[in]\nincy      [int]\nspecifies the increment for the elements of y.\n@param[in]\nstridey  [hipblasStride]\nstride from the start of one vector (y_i) and the next one (y_i+1)\n@param[in]\nbatchCount [int]\nnumber of instances in the batch.\n"]
    pub fn hipblasChbmvStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        alpha: *const hipblasComplex,
        AP: *const hipblasComplex,
        lda: ::std::os::raw::c_int,
        strideA: hipblasStride,
        x: *const hipblasComplex,
        incx: ::std::os::raw::c_int,
        stridex: hipblasStride,
        beta: *const hipblasComplex,
        y: *mut hipblasComplex,
        incy: ::std::os::raw::c_int,
        stridey: hipblasStride,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZhbmvStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        alpha: *const hipblasDoubleComplex,
        AP: *const hipblasDoubleComplex,
        lda: ::std::os::raw::c_int,
        strideA: hipblasStride,
        x: *const hipblasDoubleComplex,
        incx: ::std::os::raw::c_int,
        stridex: hipblasStride,
        beta: *const hipblasDoubleComplex,
        y: *mut hipblasDoubleComplex,
        incy: ::std::os::raw::c_int,
        stridey: hipblasStride,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasChbmvStridedBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        alpha: *const hipComplex,
        AP: *const hipComplex,
        lda: ::std::os::raw::c_int,
        strideA: hipblasStride,
        x: *const hipComplex,
        incx: ::std::os::raw::c_int,
        stridex: hipblasStride,
        beta: *const hipComplex,
        y: *mut hipComplex,
        incy: ::std::os::raw::c_int,
        stridey: hipblasStride,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZhbmvStridedBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        alpha: *const hipDoubleComplex,
        AP: *const hipDoubleComplex,
        lda: ::std::os::raw::c_int,
        strideA: hipblasStride,
        x: *const hipDoubleComplex,
        incx: ::std::os::raw::c_int,
        stridex: hipblasStride,
        beta: *const hipDoubleComplex,
        y: *mut hipDoubleComplex,
        incy: ::std::os::raw::c_int,
        stridey: hipblasStride,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 2 API\n\n\\details\nhemv performs one of the matrix-vector operations\n\ny := alpha*A*x + beta*y\n\nwhere alpha and beta are scalars, x and y are n element vectors and A is an\nn by n Hermitian matrix.\n\n- Supported precisions in rocBLAS : c,z\n- Supported precisions in cuBLAS  : c,z\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n@param[in]\nuplo      [hipblasFillMode_t]\nHIPBLAS_FILL_MODE_UPPER: the upper triangular part of the Hermitian matrix A is supplied.\nHIPBLAS_FILL_MODE_LOWER: the lower triangular part of the Hermitian matrix A is supplied.\n@param[in]\nn         [int]\nthe order of the matrix A.\n@param[in]\nalpha     device pointer or host pointer to scalar alpha.\n@param[in]\nAP        device pointer storing matrix A. Of dimension (lda, n).\nif uplo == HIPBLAS_FILL_MODE_UPPER:\nThe upper triangular part of A must contain\nthe upper triangular part of a Hermitian matrix. The lower\ntriangular part of A will not be referenced.\nif uplo == HIPBLAS_FILL_MODE_LOWER:\nThe lower triangular part of A must contain\nthe lower triangular part of a Hermitian matrix. The upper\ntriangular part of A will not be referenced.\nAs a Hermitian matrix, the imaginary part of the main diagonal\nof A will not be referenced and is assumed to be == 0.\n@param[in]\nlda       [int]\nspecifies the leading dimension of A. must be >= max(1, n)\n@param[in]\nx         device pointer storing vector x.\n@param[in]\nincx      [int]\nspecifies the increment for the elements of x.\n@param[in]\nbeta      device pointer or host pointer to scalar beta.\n@param[inout]\ny         device pointer storing vector y.\n@param[in]\nincy      [int]\nspecifies the increment for the elements of y.\n"]
    pub fn hipblasChemv(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::std::os::raw::c_int,
        alpha: *const hipblasComplex,
        AP: *const hipblasComplex,
        lda: ::std::os::raw::c_int,
        x: *const hipblasComplex,
        incx: ::std::os::raw::c_int,
        beta: *const hipblasComplex,
        y: *mut hipblasComplex,
        incy: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZhemv(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::std::os::raw::c_int,
        alpha: *const hipblasDoubleComplex,
        AP: *const hipblasDoubleComplex,
        lda: ::std::os::raw::c_int,
        x: *const hipblasDoubleComplex,
        incx: ::std::os::raw::c_int,
        beta: *const hipblasDoubleComplex,
        y: *mut hipblasDoubleComplex,
        incy: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasChemv_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::std::os::raw::c_int,
        alpha: *const hipComplex,
        AP: *const hipComplex,
        lda: ::std::os::raw::c_int,
        x: *const hipComplex,
        incx: ::std::os::raw::c_int,
        beta: *const hipComplex,
        y: *mut hipComplex,
        incy: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZhemv_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::std::os::raw::c_int,
        alpha: *const hipDoubleComplex,
        AP: *const hipDoubleComplex,
        lda: ::std::os::raw::c_int,
        x: *const hipDoubleComplex,
        incx: ::std::os::raw::c_int,
        beta: *const hipDoubleComplex,
        y: *mut hipDoubleComplex,
        incy: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 2 API\n\n\\details\nhemvBatched performs one of the matrix-vector operations\n\ny_i := alpha*A_i*x_i + beta*y_i\n\nwhere alpha and beta are scalars, x_i and y_i are n element vectors and A_i is an\nn by n Hermitian matrix, for each batch in i = [1, batchCount].\n\n- Supported precisions in rocBLAS : c,z\n- Supported precisions in cuBLAS  : No support\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n@param[in]\nuplo      [hipblasFillMode_t]\nHIPBLAS_FILL_MODE_UPPER: the upper triangular part of the Hermitian matrix A is supplied.\nHIPBLAS_FILL_MODE_LOWER: the lower triangular part of the Hermitian matrix A is supplied.\n@param[in]\nn         [int]\nthe order of each matrix A_i.\n@param[in]\nalpha     device pointer or host pointer to scalar alpha.\n@param[in]\nAP        device array of device pointers storing each matrix A_i of dimension (lda, n).\nif uplo == HIPBLAS_FILL_MODE_UPPER:\nThe upper triangular part of each A_i must contain\nthe upper triangular part of a Hermitian matrix. The lower\ntriangular part of each A_i will not be referenced.\nif uplo == HIPBLAS_FILL_MODE_LOWER:\nThe lower triangular part of each A_i must contain\nthe lower triangular part of a Hermitian matrix. The upper\ntriangular part of each A_i will not be referenced.\nAs a Hermitian matrix, the imaginary part of the main diagonal\nof each A_i will not be referenced and is assumed to be == 0.\n@param[in]\nlda       [int]\nspecifies the leading dimension of each A_i. must be >= max(1, n)\n@param[in]\nx         device array of device pointers storing each vector x_i.\n@param[in]\nincx      [int]\nspecifies the increment for the elements of each x_i.\n@param[in]\nbeta      device pointer or host pointer to scalar beta.\n@param[inout]\ny         device array of device pointers storing each vector y_i.\n@param[in]\nincy      [int]\nspecifies the increment for the elements of y.\n@param[in]\nbatchCount [int]\nnumber of instances in the batch.\n"]
    pub fn hipblasChemvBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::std::os::raw::c_int,
        alpha: *const hipblasComplex,
        AP: *const *const hipblasComplex,
        lda: ::std::os::raw::c_int,
        x: *const *const hipblasComplex,
        incx: ::std::os::raw::c_int,
        beta: *const hipblasComplex,
        y: *const *mut hipblasComplex,
        incy: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZhemvBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::std::os::raw::c_int,
        alpha: *const hipblasDoubleComplex,
        AP: *const *const hipblasDoubleComplex,
        lda: ::std::os::raw::c_int,
        x: *const *const hipblasDoubleComplex,
        incx: ::std::os::raw::c_int,
        beta: *const hipblasDoubleComplex,
        y: *const *mut hipblasDoubleComplex,
        incy: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasChemvBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::std::os::raw::c_int,
        alpha: *const hipComplex,
        AP: *const *const hipComplex,
        lda: ::std::os::raw::c_int,
        x: *const *const hipComplex,
        incx: ::std::os::raw::c_int,
        beta: *const hipComplex,
        y: *const *mut hipComplex,
        incy: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZhemvBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::std::os::raw::c_int,
        alpha: *const hipDoubleComplex,
        AP: *const *const hipDoubleComplex,
        lda: ::std::os::raw::c_int,
        x: *const *const hipDoubleComplex,
        incx: ::std::os::raw::c_int,
        beta: *const hipDoubleComplex,
        y: *const *mut hipDoubleComplex,
        incy: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 2 API\n\n\\details\nhemvStridedBatched performs one of the matrix-vector operations\n\ny_i := alpha*A_i*x_i + beta*y_i\n\nwhere alpha and beta are scalars, x_i and y_i are n element vectors and A_i is an\nn by n Hermitian matrix, for each batch in i = [1, batchCount].\n\n- Supported precisions in rocBLAS : c,z\n- Supported precisions in cuBLAS  : No support\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n@param[in]\nuplo      [hipblasFillMode_t]\nHIPBLAS_FILL_MODE_UPPER: the upper triangular part of the Hermitian matrix A is supplied.\nHIPBLAS_FILL_MODE_LOWER: the lower triangular part of the Hermitian matrix A is supplied.\n@param[in]\nn         [int]\nthe order of each matrix A_i.\n@param[in]\nalpha     device pointer or host pointer to scalar alpha.\n@param[in]\nAP        device array of device pointers storing each matrix A_i of dimension (lda, n).\nif uplo == HIPBLAS_FILL_MODE_UPPER:\nThe upper triangular part of each A_i must contain\nthe upper triangular part of a Hermitian matrix. The lower\ntriangular part of each A_i will not be referenced.\nif uplo == HIPBLAS_FILL_MODE_LOWER:\nThe lower triangular part of each A_i must contain\nthe lower triangular part of a Hermitian matrix. The upper\ntriangular part of each A_i will not be referenced.\nAs a Hermitian matrix, the imaginary part of the main diagonal\nof each A_i will not be referenced and is assumed to be == 0.\n@param[in]\nlda       [int]\nspecifies the leading dimension of each A_i. must be >= max(1, n)\n@param[in]\nstrideA    [hipblasStride]\nstride from the start of one (A_i) to the next (A_i+1)\n\n@param[in]\nx         device array of device pointers storing each vector x_i.\n@param[in]\nincx      [int]\nspecifies the increment for the elements of each x_i.\n@param[in]\nstridex  [hipblasStride]\nstride from the start of one vector (x_i) and the next one (x_i+1).\n@param[in]\nbeta      device pointer or host pointer to scalar beta.\n@param[inout]\ny         device array of device pointers storing each vector y_i.\n@param[in]\nincy      [int]\nspecifies the increment for the elements of y.\n@param[in]\nstridey  [hipblasStride]\nstride from the start of one vector (y_i) and the next one (y_i+1).\n@param[in]\nbatchCount [int]\nnumber of instances in the batch.\n"]
    pub fn hipblasChemvStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::std::os::raw::c_int,
        alpha: *const hipblasComplex,
        AP: *const hipblasComplex,
        lda: ::std::os::raw::c_int,
        strideA: hipblasStride,
        x: *const hipblasComplex,
        incx: ::std::os::raw::c_int,
        stridex: hipblasStride,
        beta: *const hipblasComplex,
        y: *mut hipblasComplex,
        incy: ::std::os::raw::c_int,
        stridey: hipblasStride,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZhemvStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::std::os::raw::c_int,
        alpha: *const hipblasDoubleComplex,
        AP: *const hipblasDoubleComplex,
        lda: ::std::os::raw::c_int,
        strideA: hipblasStride,
        x: *const hipblasDoubleComplex,
        incx: ::std::os::raw::c_int,
        stridex: hipblasStride,
        beta: *const hipblasDoubleComplex,
        y: *mut hipblasDoubleComplex,
        incy: ::std::os::raw::c_int,
        stridey: hipblasStride,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasChemvStridedBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::std::os::raw::c_int,
        alpha: *const hipComplex,
        AP: *const hipComplex,
        lda: ::std::os::raw::c_int,
        strideA: hipblasStride,
        x: *const hipComplex,
        incx: ::std::os::raw::c_int,
        stridex: hipblasStride,
        beta: *const hipComplex,
        y: *mut hipComplex,
        incy: ::std::os::raw::c_int,
        stridey: hipblasStride,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZhemvStridedBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::std::os::raw::c_int,
        alpha: *const hipDoubleComplex,
        AP: *const hipDoubleComplex,
        lda: ::std::os::raw::c_int,
        strideA: hipblasStride,
        x: *const hipDoubleComplex,
        incx: ::std::os::raw::c_int,
        stridex: hipblasStride,
        beta: *const hipDoubleComplex,
        y: *mut hipDoubleComplex,
        incy: ::std::os::raw::c_int,
        stridey: hipblasStride,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 2 API\n\n\\details\nher performs the matrix-vector operations\n\nA := A + alpha*x*x**H\n\nwhere alpha is a real scalar, x is a vector, and A is an\nn by n Hermitian matrix.\n\n- Supported precisions in rocBLAS : c,z\n- Supported precisions in cuBLAS  : c,z\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n@param[in]\nuplo      [hipblasFillMode_t]\nspecifies whether the upper 'HIPBLAS_FILL_MODE_UPPER' or lower 'HIPBLAS_FILL_MODE_LOWER'\nHIPBLAS_FILL_MODE_UPPER: The upper triangular part of A is supplied in A.\nHIPBLAS_FILL_MODE_LOWER: The lower triangular part of A is supplied in A.\n@param[in]\nn         [int]\nthe number of rows and columns of matrix A, must be at least 0.\n@param[in]\nalpha\ndevice pointer or host pointer to scalar alpha.\n@param[in]\nx         device pointer storing vector x.\n@param[in]\nincx      [int]\nspecifies the increment for the elements of x.\n@param[inout]\nAP        device pointer storing the specified triangular portion of\nthe Hermitian matrix A. Of size (lda * n).\nif uplo == HIPBLAS_FILL_MODE_UPPER:\nThe upper triangular portion of the Hermitian matrix A is supplied. The lower\ntriangluar portion will not be touched.\nif uplo == HIPBLAS_FILL_MODE_LOWER:\nThe lower triangular portion of the Hermitian matrix A is supplied. The upper\ntriangular portion will not be touched.\nNote that the imaginary part of the diagonal elements are not accessed and are assumed\nto be 0.\n@param[in]\nlda       [int]\nspecifies the leading dimension of A. Must be at least max(1, n)."]
    pub fn hipblasCher(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::std::os::raw::c_int,
        alpha: *const f32,
        x: *const hipblasComplex,
        incx: ::std::os::raw::c_int,
        AP: *mut hipblasComplex,
        lda: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZher(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::std::os::raw::c_int,
        alpha: *const f64,
        x: *const hipblasDoubleComplex,
        incx: ::std::os::raw::c_int,
        AP: *mut hipblasDoubleComplex,
        lda: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCher_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::std::os::raw::c_int,
        alpha: *const f32,
        x: *const hipComplex,
        incx: ::std::os::raw::c_int,
        AP: *mut hipComplex,
        lda: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZher_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::std::os::raw::c_int,
        alpha: *const f64,
        x: *const hipDoubleComplex,
        incx: ::std::os::raw::c_int,
        AP: *mut hipDoubleComplex,
        lda: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 2 API\n\n\\details\nherBatched performs the matrix-vector operations\n\nA_i := A_i + alpha*x_i*x_i**H\n\nwhere alpha is a real scalar, x_i is a vector, and A_i is an\nn by n symmetric matrix, for i = 1, ..., batchCount.\n\n- Supported precisions in rocBLAS : c,z\n- Supported precisions in cuBLAS  : No support\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n@param[in]\nuplo      [hipblasFillMode_t]\nspecifies whether the upper 'HIPBLAS_FILL_MODE_UPPER' or lower 'HIPBLAS_FILL_MODE_LOWER'\nHIPBLAS_FILL_MODE_UPPER: The upper triangular part of each A_i is supplied in A.\nHIPBLAS_FILL_MODE_LOWER: The lower triangular part of each A_i is supplied in A.\n@param[in]\nn         [int]\nthe number of rows and columns of each matrix A_i, must be at least 0.\n@param[in]\nalpha\ndevice pointer or host pointer to scalar alpha.\n@param[in]\nx         device array of device pointers storing each vector x_i.\n@param[in]\nincx      [int]\nspecifies the increment for the elements of each x_i.\n@param[inout]\nAP       device array of device pointers storing the specified triangular portion of\neach Hermitian matrix A_i of at least size ((n * (n + 1)) / 2). Array is of at least size batchCount.\nif uplo == HIPBLAS_FILL_MODE_UPPER:\nThe upper triangular portion of each Hermitian matrix A_i is supplied. The lower triangular portion\nof each A_i will not be touched.\nif uplo == HIPBLAS_FILL_MODE_LOWER:\nThe lower triangular portion of each Hermitian matrix A_i is supplied. The upper triangular portion\nof each A_i will not be touched.\nNote that the imaginary part of the diagonal elements are not accessed and are assumed\nto be 0.\n@param[in]\nlda       [int]\nspecifies the leading dimension of each A_i. Must be at least max(1, n).\n@param[in]\nbatchCount [int]\nnumber of instances in the batch."]
    pub fn hipblasCherBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::std::os::raw::c_int,
        alpha: *const f32,
        x: *const *const hipblasComplex,
        incx: ::std::os::raw::c_int,
        AP: *const *mut hipblasComplex,
        lda: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZherBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::std::os::raw::c_int,
        alpha: *const f64,
        x: *const *const hipblasDoubleComplex,
        incx: ::std::os::raw::c_int,
        AP: *const *mut hipblasDoubleComplex,
        lda: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCherBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::std::os::raw::c_int,
        alpha: *const f32,
        x: *const *const hipComplex,
        incx: ::std::os::raw::c_int,
        AP: *const *mut hipComplex,
        lda: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZherBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::std::os::raw::c_int,
        alpha: *const f64,
        x: *const *const hipDoubleComplex,
        incx: ::std::os::raw::c_int,
        AP: *const *mut hipDoubleComplex,
        lda: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 2 API\n\n\\details\nherStridedBatched performs the matrix-vector operations\n\nA_i := A_i + alpha*x_i*x_i**H\n\nwhere alpha is a real scalar, x_i is a vector, and A_i is an\nn by n Hermitian matrix, for i = 1, ..., batchCount.\n\n- Supported precisions in rocBLAS : c,z\n- Supported precisions in cuBLAS  : No support\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n@param[in]\nuplo      [hipblasFillMode_t]\nspecifies whether the upper 'HIPBLAS_FILL_MODE_UPPER' or lower 'HIPBLAS_FILL_MODE_LOWER'\nHIPBLAS_FILL_MODE_UPPER: The upper triangular part of each A_i is supplied in A.\nHIPBLAS_FILL_MODE_LOWER: The lower triangular part of each A_i is supplied in A.\n@param[in]\nn         [int]\nthe number of rows and columns of each matrix A_i, must be at least 0.\n@param[in]\nalpha\ndevice pointer or host pointer to scalar alpha.\n@param[in]\nx         device pointer pointing to the first vector (x_1).\n@param[in]\nincx      [int]\nspecifies the increment for the elements of each x_i.\n@param[in]\nstridex  [hipblasStride]\nstride from the start of one vector (x_i) and the next one (x_i+1).\n@param[inout]\nAP        device array of device pointers storing the specified triangular portion of\neach Hermitian matrix A_i. Points to the first matrix (A_1).\nif uplo == HIPBLAS_FILL_MODE_UPPER:\nThe upper triangular portion of each Hermitian matrix A_i is supplied. The lower triangular\nportion of each A_i will not be touched.\nif uplo == HIPBLAS_FILL_MODE_LOWER:\nThe lower triangular portion of each Hermitian matrix A_i is supplied. The upper triangular\nportion of each A_i will not be touched.\nNote that the imaginary part of the diagonal elements are not accessed and are assumed\nto be 0.\n@param[in]\nlda       [int]\nspecifies the leading dimension of each A_i.\n@param[in]\nstrideA    [hipblasStride]\nstride from the start of one (A_i) and the next (A_i+1)\n@param[in]\nbatchCount [int]\nnumber of instances in the batch."]
    pub fn hipblasCherStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::std::os::raw::c_int,
        alpha: *const f32,
        x: *const hipblasComplex,
        incx: ::std::os::raw::c_int,
        stridex: hipblasStride,
        AP: *mut hipblasComplex,
        lda: ::std::os::raw::c_int,
        strideA: hipblasStride,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZherStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::std::os::raw::c_int,
        alpha: *const f64,
        x: *const hipblasDoubleComplex,
        incx: ::std::os::raw::c_int,
        stridex: hipblasStride,
        AP: *mut hipblasDoubleComplex,
        lda: ::std::os::raw::c_int,
        strideA: hipblasStride,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCherStridedBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::std::os::raw::c_int,
        alpha: *const f32,
        x: *const hipComplex,
        incx: ::std::os::raw::c_int,
        stridex: hipblasStride,
        AP: *mut hipComplex,
        lda: ::std::os::raw::c_int,
        strideA: hipblasStride,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZherStridedBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::std::os::raw::c_int,
        alpha: *const f64,
        x: *const hipDoubleComplex,
        incx: ::std::os::raw::c_int,
        stridex: hipblasStride,
        AP: *mut hipDoubleComplex,
        lda: ::std::os::raw::c_int,
        strideA: hipblasStride,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 2 API\n\n\\details\nher2 performs the matrix-vector operations\n\nA := A + alpha*x*y**H + conj(alpha)*y*x**H\n\nwhere alpha is a complex scalar, x and y are vectors, and A is an\nn by n Hermitian matrix.\n\n- Supported precisions in rocBLAS : c,z\n- Supported precisions in cuBLAS  : c,z\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n@param[in]\nuplo      [hipblasFillMode_t]\nspecifies whether the upper 'HIPBLAS_FILL_MODE_UPPER' or lower 'HIPBLAS_FILL_MODE_LOWER'\nHIPBLAS_FILL_MODE_UPPER: The upper triangular part of A is supplied.\nHIPBLAS_FILL_MODE_LOWER: The lower triangular part of A is supplied.\n@param[in]\nn         [int]\nthe number of rows and columns of matrix A, must be at least 0.\n@param[in]\nalpha\ndevice pointer or host pointer to scalar alpha.\n@param[in]\nx         device pointer storing vector x.\n@param[in]\nincx      [int]\nspecifies the increment for the elements of x.\n@param[in]\ny         device pointer storing vector y.\n@param[in]\nincy      [int]\nspecifies the increment for the elements of y.\n@param[inout]\nAP         device pointer storing the specified triangular portion of\nthe Hermitian matrix A. Of size (lda, n).\nif uplo == HIPBLAS_FILL_MODE_UPPER:\nThe upper triangular portion of the Hermitian matrix A is supplied. The lower triangular\nportion of A will not be touched.\nif uplo == HIPBLAS_FILL_MODE_LOWER:\nThe lower triangular portion of the Hermitian matrix A is supplied. The upper triangular\nportion of A will not be touched.\nNote that the imaginary part of the diagonal elements are not accessed and are assumed\nto be 0.\n@param[in]\nlda       [int]\nspecifies the leading dimension of A. Must be at least max(lda, 1)."]
    pub fn hipblasCher2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::std::os::raw::c_int,
        alpha: *const hipblasComplex,
        x: *const hipblasComplex,
        incx: ::std::os::raw::c_int,
        y: *const hipblasComplex,
        incy: ::std::os::raw::c_int,
        AP: *mut hipblasComplex,
        lda: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZher2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::std::os::raw::c_int,
        alpha: *const hipblasDoubleComplex,
        x: *const hipblasDoubleComplex,
        incx: ::std::os::raw::c_int,
        y: *const hipblasDoubleComplex,
        incy: ::std::os::raw::c_int,
        AP: *mut hipblasDoubleComplex,
        lda: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCher2_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::std::os::raw::c_int,
        alpha: *const hipComplex,
        x: *const hipComplex,
        incx: ::std::os::raw::c_int,
        y: *const hipComplex,
        incy: ::std::os::raw::c_int,
        AP: *mut hipComplex,
        lda: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZher2_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::std::os::raw::c_int,
        alpha: *const hipDoubleComplex,
        x: *const hipDoubleComplex,
        incx: ::std::os::raw::c_int,
        y: *const hipDoubleComplex,
        incy: ::std::os::raw::c_int,
        AP: *mut hipDoubleComplex,
        lda: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 2 API\n\n\\details\nher2Batched performs the matrix-vector operations\n\nA_i := A_i + alpha*x_i*y_i**H + conj(alpha)*y_i*x_i**H\n\nwhere alpha is a complex scalar, x_i and y_i are vectors, and A_i is an\nn by n Hermitian matrix for each batch in i = [1, batchCount].\n\n- Supported precisions in rocBLAS : c,z\n- Supported precisions in cuBLAS  : No support\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n@param[in]\nuplo      [hipblasFillMode_t]\nspecifies whether the upper 'HIPBLAS_FILL_MODE_UPPER' or lower 'HIPBLAS_FILL_MODE_LOWER'\nHIPBLAS_FILL_MODE_UPPER: The upper triangular part of each A_i is supplied.\nHIPBLAS_FILL_MODE_LOWER: The lower triangular part of each A_i is supplied.\n@param[in]\nn         [int]\nthe number of rows and columns of each matrix A_i, must be at least 0.\n@param[in]\nalpha\ndevice pointer or host pointer to scalar alpha.\n@param[in]\nx         device array of device pointers storing each vector x_i.\n@param[in]\nincx      [int]\nspecifies the increment for the elements of x.\n@param[in]\ny         device array of device pointers storing each vector y_i.\n@param[in]\nincy      [int]\nspecifies the increment for the elements of each y_i.\n@param[inout]\nAP         device array of device pointers storing the specified triangular portion of\neach Hermitian matrix A_i of size (lda, n).\nif uplo == HIPBLAS_FILL_MODE_UPPER:\nThe upper triangular portion of each Hermitian matrix A_i is supplied. The lower triangular\nportion of each A_i will not be touched.\nif uplo == HIPBLAS_FILL_MODE_LOWER:\nThe lower triangular portion of each Hermitian matrix A_i is supplied. The upper triangular\nportion of each A_i will not be touched.\nNote that the imaginary part of the diagonal elements are not accessed and are assumed\nto be 0.\n@param[in]\nlda       [int]\nspecifies the leading dimension of each A_i. Must be at least max(lda, 1).\n@param[in]\nbatchCount [int]\nnumber of instances in the batch."]
    pub fn hipblasCher2Batched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::std::os::raw::c_int,
        alpha: *const hipblasComplex,
        x: *const *const hipblasComplex,
        incx: ::std::os::raw::c_int,
        y: *const *const hipblasComplex,
        incy: ::std::os::raw::c_int,
        AP: *const *mut hipblasComplex,
        lda: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZher2Batched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::std::os::raw::c_int,
        alpha: *const hipblasDoubleComplex,
        x: *const *const hipblasDoubleComplex,
        incx: ::std::os::raw::c_int,
        y: *const *const hipblasDoubleComplex,
        incy: ::std::os::raw::c_int,
        AP: *const *mut hipblasDoubleComplex,
        lda: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCher2Batched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::std::os::raw::c_int,
        alpha: *const hipComplex,
        x: *const *const hipComplex,
        incx: ::std::os::raw::c_int,
        y: *const *const hipComplex,
        incy: ::std::os::raw::c_int,
        AP: *const *mut hipComplex,
        lda: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZher2Batched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::std::os::raw::c_int,
        alpha: *const hipDoubleComplex,
        x: *const *const hipDoubleComplex,
        incx: ::std::os::raw::c_int,
        y: *const *const hipDoubleComplex,
        incy: ::std::os::raw::c_int,
        AP: *const *mut hipDoubleComplex,
        lda: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 2 API\n\n\\details\nher2StridedBatched performs the matrix-vector operations\n\nA_i := A_i + alpha*x_i*y_i**H + conj(alpha)*y_i*x_i**H\n\nwhere alpha is a complex scalar, x_i and y_i are vectors, and A_i is an\nn by n Hermitian matrix for each batch in i = [1, batchCount].\n\n- Supported precisions in rocBLAS : c,z\n- Supported precisions in cuBLAS  : No support\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n@param[in]\nuplo      [hipblasFillMode_t]\nspecifies whether the upper 'HIPBLAS_FILL_MODE_UPPER' or lower 'HIPBLAS_FILL_MODE_LOWER'\nHIPBLAS_FILL_MODE_UPPER: The upper triangular part of each A_i is supplied.\nHIPBLAS_FILL_MODE_LOWER: The lower triangular part of each A_i is supplied.\n@param[in]\nn         [int]\nthe number of rows and columns of each matrix A_i, must be at least 0.\n@param[in]\nalpha\ndevice pointer or host pointer to scalar alpha.\n@param[in]\nx         device pointer pointing to the first vector x_1.\n@param[in]\nincx      [int]\nspecifies the increment for the elements of each x_i.\n@param[in]\nstridex  [hipblasStride]\nspecifies the stride between the beginning of one vector (x_i) and the next (x_i+1).\n@param[in]\ny         device pointer pointing to the first vector y_i.\n@param[in]\nincy      [int]\nspecifies the increment for the elements of each y_i.\n@param[in]\nstridey  [hipblasStride]\nspecifies the stride between the beginning of one vector (y_i) and the next (y_i+1).\n@param[inout]\nAP        device pointer pointing to the first matrix (A_1). Stores the specified triangular portion of\neach Hermitian matrix A_i.\nif uplo == HIPBLAS_FILL_MODE_UPPER:\nThe upper triangular portion of each Hermitian matrix A_i is supplied. The lower triangular\nportion of each A_i will not be touched.\nif uplo == HIPBLAS_FILL_MODE_LOWER:\nThe lower triangular portion of each Hermitian matrix A_i is supplied. The upper triangular\nportion of each A_i will not be touched.\nNote that the imaginary part of the diagonal elements are not accessed and are assumed\nto be 0.\n@param[in]\nlda       [int]\nspecifies the leading dimension of each A_i. Must be at least max(lda, 1).\n@param[in]\nstrideA  [hipblasStride]\nspecifies the stride between the beginning of one matrix (A_i) and the next (A_i+1).\n@param[in]\nbatchCount [int]\nnumber of instances in the batch."]
    pub fn hipblasCher2StridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::std::os::raw::c_int,
        alpha: *const hipblasComplex,
        x: *const hipblasComplex,
        incx: ::std::os::raw::c_int,
        stridex: hipblasStride,
        y: *const hipblasComplex,
        incy: ::std::os::raw::c_int,
        stridey: hipblasStride,
        AP: *mut hipblasComplex,
        lda: ::std::os::raw::c_int,
        strideA: hipblasStride,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZher2StridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::std::os::raw::c_int,
        alpha: *const hipblasDoubleComplex,
        x: *const hipblasDoubleComplex,
        incx: ::std::os::raw::c_int,
        stridex: hipblasStride,
        y: *const hipblasDoubleComplex,
        incy: ::std::os::raw::c_int,
        stridey: hipblasStride,
        AP: *mut hipblasDoubleComplex,
        lda: ::std::os::raw::c_int,
        strideA: hipblasStride,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCher2StridedBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::std::os::raw::c_int,
        alpha: *const hipComplex,
        x: *const hipComplex,
        incx: ::std::os::raw::c_int,
        stridex: hipblasStride,
        y: *const hipComplex,
        incy: ::std::os::raw::c_int,
        stridey: hipblasStride,
        AP: *mut hipComplex,
        lda: ::std::os::raw::c_int,
        strideA: hipblasStride,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZher2StridedBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::std::os::raw::c_int,
        alpha: *const hipDoubleComplex,
        x: *const hipDoubleComplex,
        incx: ::std::os::raw::c_int,
        stridex: hipblasStride,
        y: *const hipDoubleComplex,
        incy: ::std::os::raw::c_int,
        stridey: hipblasStride,
        AP: *mut hipDoubleComplex,
        lda: ::std::os::raw::c_int,
        strideA: hipblasStride,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 2 API\n\n\\details\nhpmv performs the matrix-vector operation\n\ny := alpha*A*x + beta*y\n\nwhere alpha and beta are scalars, x and y are n element vectors and A is an\nn by n Hermitian matrix, supplied in packed form (see description below).\n\n- Supported precisions in rocBLAS : c,z\n- Supported precisions in cuBLAS  : c,z\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n@param[in]\nuplo      [hipblasFillMode_t]\nHIPBLAS_FILL_MODE_UPPER: the upper triangular part of the Hermitian matrix A is supplied in AP.\nHIPBLAS_FILL_MODE_LOWER: the lower triangular part of the Hermitian matrix A is supplied in AP.\n@param[in]\nn         [int]\nthe order of the matrix A, must be >= 0.\n@param[in]\nalpha     device pointer or host pointer to scalar alpha.\n@param[in]\nAP        device pointer storing the packed version of the specified triangular portion of\nthe Hermitian matrix A. Of at least size ((n * (n + 1)) / 2).\nif uplo == HIPBLAS_FILL_MODE_UPPER:\nThe upper triangular portion of the Hermitian matrix A is supplied.\nThe matrix is compacted so that AP contains the triangular portion column-by-column\nso that:\nAP(0) = A(0,0)\nAP(1) = A(0,1)\nAP(2) = A(1,1), etc.\nEx: (HIPBLAS_FILL_MODE_UPPER; n = 3)\n(1, 0) (2, 1) (3, 2)\n(2,-1) (4, 0) (5,-1)    -----> [(1,0), (2,1), (4,0), (3,2), (5,-1), (6,0)]\n(3,-2) (5, 1) (6, 0)\nif uplo == HIPBLAS_FILL_MODE_LOWER:\nThe lower triangular portion of the Hermitian matrix A is supplied.\nThe matrix is compacted so that AP contains the triangular portion column-by-column\nso that:\nAP(0) = A(0,0)\nAP(1) = A(1,0)\nAP(2) = A(2,1), etc.\nEx: (HIPBLAS_FILL_MODE_LOWER; n = 3)\n(1, 0) (2, 1) (3, 2)\n(2,-1) (4, 0) (5,-1)    -----> [(1,0), (2,-1), (3,-2), (4,0), (5,1), (6,0)]\n(3,-2) (5, 1) (6, 0)\nNote that the imaginary part of the diagonal elements are not accessed and are assumed\nto be 0.\n@param[in]\nx         device pointer storing vector x.\n@param[in]\nincx      [int]\nspecifies the increment for the elements of x.\n@param[in]\nbeta      device pointer or host pointer to scalar beta.\n@param[inout]\ny         device pointer storing vector y.\n@param[in]\nincy      [int]\nspecifies the increment for the elements of y.\n"]
    pub fn hipblasChpmv(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::std::os::raw::c_int,
        alpha: *const hipblasComplex,
        AP: *const hipblasComplex,
        x: *const hipblasComplex,
        incx: ::std::os::raw::c_int,
        beta: *const hipblasComplex,
        y: *mut hipblasComplex,
        incy: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZhpmv(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::std::os::raw::c_int,
        alpha: *const hipblasDoubleComplex,
        AP: *const hipblasDoubleComplex,
        x: *const hipblasDoubleComplex,
        incx: ::std::os::raw::c_int,
        beta: *const hipblasDoubleComplex,
        y: *mut hipblasDoubleComplex,
        incy: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasChpmv_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::std::os::raw::c_int,
        alpha: *const hipComplex,
        AP: *const hipComplex,
        x: *const hipComplex,
        incx: ::std::os::raw::c_int,
        beta: *const hipComplex,
        y: *mut hipComplex,
        incy: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZhpmv_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::std::os::raw::c_int,
        alpha: *const hipDoubleComplex,
        AP: *const hipDoubleComplex,
        x: *const hipDoubleComplex,
        incx: ::std::os::raw::c_int,
        beta: *const hipDoubleComplex,
        y: *mut hipDoubleComplex,
        incy: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 2 API\n\n\\details\nhpmvBatched performs the matrix-vector operation\n\ny_i := alpha*A_i*x_i + beta*y_i\n\nwhere alpha and beta are scalars, x_i and y_i are n element vectors and A_i is an\nn by n Hermitian matrix, supplied in packed form (see description below),\nfor each batch in i = [1, batchCount].\n\n- Supported precisions in rocBLAS : c,z\n- Supported precisions in cuBLAS  : No support\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n@param[in]\nuplo      [hipblasFillMode_t]\nHIPBLAS_FILL_MODE_UPPER: the upper triangular part of each Hermitian matrix A_i is supplied in AP.\nHIPBLAS_FILL_MODE_LOWER: the lower triangular part of each Hermitian matrix A_i is supplied in AP.\n@param[in]\nn         [int]\nthe order of each matrix A_i.\n@param[in]\nalpha     device pointer or host pointer to scalar alpha.\n@param[in]\nAP      device pointer of device pointers storing the packed version of the specified triangular\nportion of each Hermitian matrix A_i. Each A_i is of at least size ((n * (n + 1)) / 2).\nif uplo == HIPBLAS_FILL_MODE_UPPER:\nThe upper triangular portion of each Hermitian matrix A_i is supplied.\nThe matrix is compacted so that each AP_i contains the triangular portion column-by-column\nso that:\nAP(0) = A(0,0)\nAP(1) = A(0,1)\nAP(2) = A(1,1), etc.\nEx: (HIPBLAS_FILL_MODE_UPPER; n = 3)\n(1, 0) (2, 1) (3, 2)\n(2,-1) (4, 0) (5,-1)    -----> [(1,0), (2,1), (4,0), (3,2), (5,-1), (6,0)]\n(3,-2) (5, 1) (6, 0)\nif uplo == HIPBLAS_FILL_MODE_LOWER:\nThe lower triangular portion of each Hermitian matrix A_i is supplied.\nThe matrix is compacted so that each AP_i contains the triangular portion column-by-column\nso that:\nAP(0) = A(0,0)\nAP(1) = A(1,0)\nAP(2) = A(2,1), etc.\nEx: (HIPBLAS_FILL_MODE_LOWER; n = 3)\n(1, 0) (2, 1) (3, 2)\n(2,-1) (4, 0) (5,-1)    -----> [(1,0), (2,-1), (3,-2), (4,0), (5,1), (6,0)]\n(3,-2) (5, 1) (6, 0)\nNote that the imaginary part of the diagonal elements are not accessed and are assumed\nto be 0.\n@param[in]\nx         device array of device pointers storing each vector x_i.\n@param[in]\nincx      [int]\nspecifies the increment for the elements of each x_i.\n@param[in]\nbeta      device pointer or host pointer to scalar beta.\n@param[inout]\ny         device array of device pointers storing each vector y_i.\n@param[in]\nincy      [int]\nspecifies the increment for the elements of y.\n@param[in]\nbatchCount [int]\nnumber of instances in the batch.\n"]
    pub fn hipblasChpmvBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::std::os::raw::c_int,
        alpha: *const hipblasComplex,
        AP: *const *const hipblasComplex,
        x: *const *const hipblasComplex,
        incx: ::std::os::raw::c_int,
        beta: *const hipblasComplex,
        y: *const *mut hipblasComplex,
        incy: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZhpmvBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::std::os::raw::c_int,
        alpha: *const hipblasDoubleComplex,
        AP: *const *const hipblasDoubleComplex,
        x: *const *const hipblasDoubleComplex,
        incx: ::std::os::raw::c_int,
        beta: *const hipblasDoubleComplex,
        y: *const *mut hipblasDoubleComplex,
        incy: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasChpmvBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::std::os::raw::c_int,
        alpha: *const hipComplex,
        AP: *const *const hipComplex,
        x: *const *const hipComplex,
        incx: ::std::os::raw::c_int,
        beta: *const hipComplex,
        y: *const *mut hipComplex,
        incy: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZhpmvBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::std::os::raw::c_int,
        alpha: *const hipDoubleComplex,
        AP: *const *const hipDoubleComplex,
        x: *const *const hipDoubleComplex,
        incx: ::std::os::raw::c_int,
        beta: *const hipDoubleComplex,
        y: *const *mut hipDoubleComplex,
        incy: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 2 API\n\n\\details\nhpmvStridedBatched performs the matrix-vector operation\n\ny_i := alpha*A_i*x_i + beta*y_i\n\nwhere alpha and beta are scalars, x_i and y_i are n element vectors and A_i is an\nn by n Hermitian matrix, supplied in packed form (see description below),\nfor each batch in i = [1, batchCount].\n\n- Supported precisions in rocBLAS : c,z\n- Supported precisions in cuBLAS  : No support\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n@param[in]\nuplo      [hipblasFillMode_t]\nHIPBLAS_FILL_MODE_UPPER: the upper triangular part of each Hermitian matrix A_i is supplied in AP.\nHIPBLAS_FILL_MODE_LOWER: the lower triangular part of each Hermitian matrix A_i is supplied in AP.\n@param[in]\nn         [int]\nthe order of each matrix A_i.\n@param[in]\nalpha     device pointer or host pointer to scalar alpha.\n@param[in]\nAP        device pointer pointing to the beginning of the first matrix (AP_1). Stores the packed\nversion of the specified triangular portion of each Hermitian matrix AP_i of size ((n * (n + 1)) / 2).\nif uplo == HIPBLAS_FILL_MODE_UPPER:\nThe upper triangular portion of each Hermitian matrix A_i is supplied.\nThe matrix is compacted so that each AP_i contains the triangular portion column-by-column\nso that:\nAP(0) = A(0,0)\nAP(1) = A(0,1)\nAP(2) = A(1,1), etc.\nEx: (HIPBLAS_FILL_MODE_UPPER; n = 3)\n(1, 0) (2, 1) (3, 2)\n(2,-1) (4, 0) (5,-1)    -----> [(1,0), (2,1), (4,0), (3,2), (5,-1), (6,0)]\n(3,-2) (5, 1) (6, 0)\nif uplo == HIPBLAS_FILL_MODE_LOWER:\nThe lower triangular portion of each Hermitian matrix A_i is supplied.\nThe matrix is compacted so that each AP_i contains the triangular portion column-by-column\nso that:\nAP(0) = A(0,0)\nAP(1) = A(1,0)\nAP(2) = A(2,1), etc.\nEx: (HIPBLAS_FILL_MODE_LOWER; n = 3)\n(1, 0) (2, 1) (3, 2)\n(2,-1) (4, 0) (5,-1)    -----> [(1,0), (2,-1), (3,-2), (4,0), (5,1), (6,0)]\n(3,-2) (5, 1) (6, 0)\nNote that the imaginary part of the diagonal elements are not accessed and are assumed\nto be 0.\n@param[in]\nstrideA  [hipblasStride]\nstride from the start of one matrix (AP_i) and the next one (AP_i+1).\n@param[in]\nx         device array pointing to the beginning of the first vector (x_1).\n@param[in]\nincx      [int]\nspecifies the increment for the elements of each x_i.\n@param[in]\nstridex  [hipblasStride]\nstride from the start of one vector (x_i) and the next one (x_i+1).\n@param[in]\nbeta      device pointer or host pointer to scalar beta.\n@param[inout]\ny         device array pointing to the beginning of the first vector (y_1).\n@param[in]\nincy      [int]\nspecifies the increment for the elements of y.\n@param[in]\nstridey  [hipblasStride]\nstride from the start of one vector (y_i) and the next one (y_i+1).\n@param[in]\nbatchCount [int]\nnumber of instances in the batch.\n"]
    pub fn hipblasChpmvStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::std::os::raw::c_int,
        alpha: *const hipblasComplex,
        AP: *const hipblasComplex,
        strideA: hipblasStride,
        x: *const hipblasComplex,
        incx: ::std::os::raw::c_int,
        stridex: hipblasStride,
        beta: *const hipblasComplex,
        y: *mut hipblasComplex,
        incy: ::std::os::raw::c_int,
        stridey: hipblasStride,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZhpmvStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::std::os::raw::c_int,
        alpha: *const hipblasDoubleComplex,
        AP: *const hipblasDoubleComplex,
        strideA: hipblasStride,
        x: *const hipblasDoubleComplex,
        incx: ::std::os::raw::c_int,
        stridex: hipblasStride,
        beta: *const hipblasDoubleComplex,
        y: *mut hipblasDoubleComplex,
        incy: ::std::os::raw::c_int,
        stridey: hipblasStride,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasChpmvStridedBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::std::os::raw::c_int,
        alpha: *const hipComplex,
        AP: *const hipComplex,
        strideA: hipblasStride,
        x: *const hipComplex,
        incx: ::std::os::raw::c_int,
        stridex: hipblasStride,
        beta: *const hipComplex,
        y: *mut hipComplex,
        incy: ::std::os::raw::c_int,
        stridey: hipblasStride,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZhpmvStridedBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::std::os::raw::c_int,
        alpha: *const hipDoubleComplex,
        AP: *const hipDoubleComplex,
        strideA: hipblasStride,
        x: *const hipDoubleComplex,
        incx: ::std::os::raw::c_int,
        stridex: hipblasStride,
        beta: *const hipDoubleComplex,
        y: *mut hipDoubleComplex,
        incy: ::std::os::raw::c_int,
        stridey: hipblasStride,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 2 API\n\n\\details\nhpr performs the matrix-vector operations\n\nA := A + alpha*x*x**H\n\nwhere alpha is a real scalar, x is a vector, and A is an\nn by n Hermitian matrix, supplied in packed form.\n\n- Supported precisions in rocBLAS : c,z\n- Supported precisions in cuBLAS  : c,z\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n@param[in]\nuplo      [hipblasFillMode_t]\nspecifies whether the upper 'HIPBLAS_FILL_MODE_UPPER' or lower 'HIPBLAS_FILL_MODE_LOWER'\nHIPBLAS_FILL_MODE_UPPER: The upper triangular part of A is supplied in AP.\nHIPBLAS_FILL_MODE_LOWER: The lower triangular part of A is supplied in AP.\n@param[in]\nn         [int]\nthe number of rows and columns of matrix A, must be at least 0.\n@param[in]\nalpha\ndevice pointer or host pointer to scalar alpha.\n@param[in]\nx         device pointer storing vector x.\n@param[in]\nincx      [int]\nspecifies the increment for the elements of x.\n@param[inout]\nAP        device pointer storing the packed version of the specified triangular portion of\nthe Hermitian matrix A. Of at least size ((n * (n + 1)) / 2).\nif uplo == HIPBLAS_FILL_MODE_UPPER:\nThe upper triangular portion of the Hermitian matrix A is supplied.\nThe matrix is compacted so that AP contains the triangular portion column-by-column\nso that:\nAP(0) = A(0,0)\nAP(1) = A(0,1)\nAP(2) = A(1,1), etc.\nEx: (HIPBLAS_FILL_MODE_UPPER; n = 3)\n(1, 0) (2, 1) (4,9)\n(2,-1) (3, 0) (5,3)  -----> [(1,0), (2,1), (3,0), (4,9), (5,3), (6,0)]\n(4,-9) (5,-3) (6,0)\nif uplo == HIPBLAS_FILL_MODE_LOWER:\nThe lower triangular portion of the Hermitian matrix A is supplied.\nThe matrix is compacted so that AP contains the triangular portion column-by-column\nso that:\nAP(0) = A(0,0)\nAP(1) = A(1,0)\nAP(2) = A(2,1), etc.\nEx: (HIPBLAS_FILL_MODE_LOWER; n = 3)\n(1, 0) (2, 1) (4,9)\n(2,-1) (3, 0) (5,3)  -----> [(1,0), (2,-1), (4,-9), (3,0), (5,-3), (6,0)]\n(4,-9) (5,-3) (6,0)\nNote that the imaginary part of the diagonal elements are not accessed and are assumed\nto be 0."]
    pub fn hipblasChpr(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::std::os::raw::c_int,
        alpha: *const f32,
        x: *const hipblasComplex,
        incx: ::std::os::raw::c_int,
        AP: *mut hipblasComplex,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZhpr(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::std::os::raw::c_int,
        alpha: *const f64,
        x: *const hipblasDoubleComplex,
        incx: ::std::os::raw::c_int,
        AP: *mut hipblasDoubleComplex,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasChpr_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::std::os::raw::c_int,
        alpha: *const f32,
        x: *const hipComplex,
        incx: ::std::os::raw::c_int,
        AP: *mut hipComplex,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZhpr_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::std::os::raw::c_int,
        alpha: *const f64,
        x: *const hipDoubleComplex,
        incx: ::std::os::raw::c_int,
        AP: *mut hipDoubleComplex,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 2 API\n\n\\details\nhprBatched performs the matrix-vector operations\n\nA_i := A_i + alpha*x_i*x_i**H\n\nwhere alpha is a real scalar, x_i is a vector, and A_i is an\nn by n symmetric matrix, supplied in packed form, for i = 1, ..., batchCount.\n\n- Supported precisions in rocBLAS : c,z\n- Supported precisions in cuBLAS  : No support\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n@param[in]\nuplo      [hipblasFillMode_t]\nspecifies whether the upper 'HIPBLAS_FILL_MODE_UPPER' or lower 'HIPBLAS_FILL_MODE_LOWER'\nHIPBLAS_FILL_MODE_UPPER: The upper triangular part of each A_i is supplied in AP.\nHIPBLAS_FILL_MODE_LOWER: The lower triangular part of each A_i is supplied in AP.\n@param[in]\nn         [int]\nthe number of rows and columns of each matrix A_i, must be at least 0.\n@param[in]\nalpha\ndevice pointer or host pointer to scalar alpha.\n@param[in]\nx         device array of device pointers storing each vector x_i.\n@param[in]\nincx      [int]\nspecifies the increment for the elements of each x_i.\n@param[inout]\nAP        device array of device pointers storing the packed version of the specified triangular portion of\neach Hermitian matrix A_i of at least size ((n * (n + 1)) / 2). Array is of at least size batchCount.\nif uplo == HIPBLAS_FILL_MODE_UPPER:\nThe upper triangular portion of each Hermitian matrix A_i is supplied.\nThe matrix is compacted so that AP contains the triangular portion column-by-column\nso that:\nAP(0) = A(0,0)\nAP(1) = A(0,1)\nAP(2) = A(1,1), etc.\nEx: (HIPBLAS_FILL_MODE_UPPER; n = 3)\n(1, 0) (2, 1) (4,9)\n(2,-1) (3, 0) (5,3)  -----> [(1,0), (2,1), (3,0), (4,9), (5,3), (6,0)]\n(4,-9) (5,-3) (6,0)\nif uplo == HIPBLAS_FILL_MODE_LOWER:\nThe lower triangular portion of each Hermitian matrix A_i is supplied.\nThe matrix is compacted so that AP contains the triangular portion column-by-column\nso that:\nAP(0) = A(0,0)\nAP(1) = A(1,0)\nAP(2) = A(2,1), etc.\nEx: (HIPBLAS_FILL_MODE_LOWER; n = 3)\n(1, 0) (2, 1) (4,9)\n(2,-1) (3, 0) (5,3)  -----> [(1,0), (2,-1), (4,-9), (3,0), (5,-3), (6,0)]\n(4,-9) (5,-3) (6,0)\nNote that the imaginary part of the diagonal elements are not accessed and are assumed\nto be 0.\n@param[in]\nbatchCount [int]\nnumber of instances in the batch."]
    pub fn hipblasChprBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::std::os::raw::c_int,
        alpha: *const f32,
        x: *const *const hipblasComplex,
        incx: ::std::os::raw::c_int,
        AP: *const *mut hipblasComplex,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZhprBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::std::os::raw::c_int,
        alpha: *const f64,
        x: *const *const hipblasDoubleComplex,
        incx: ::std::os::raw::c_int,
        AP: *const *mut hipblasDoubleComplex,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasChprBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::std::os::raw::c_int,
        alpha: *const f32,
        x: *const *const hipComplex,
        incx: ::std::os::raw::c_int,
        AP: *const *mut hipComplex,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZhprBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::std::os::raw::c_int,
        alpha: *const f64,
        x: *const *const hipDoubleComplex,
        incx: ::std::os::raw::c_int,
        AP: *const *mut hipDoubleComplex,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 2 API\n\n\\details\nhprStridedBatched performs the matrix-vector operations\n\nA_i := A_i + alpha*x_i*x_i**H\n\nwhere alpha is a real scalar, x_i is a vector, and A_i is an\nn by n symmetric matrix, supplied in packed form, for i = 1, ..., batchCount.\n\n- Supported precisions in rocBLAS : c,z\n- Supported precisions in cuBLAS  : No support\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n@param[in]\nuplo      [hipblasFillMode_t]\nspecifies whether the upper 'HIPBLAS_FILL_MODE_UPPER' or lower 'HIPBLAS_FILL_MODE_LOWER'\nHIPBLAS_FILL_MODE_UPPER: The upper triangular part of each A_i is supplied in AP.\nHIPBLAS_FILL_MODE_LOWER: The lower triangular part of each A_i is supplied in AP.\n@param[in]\nn         [int]\nthe number of rows and columns of each matrix A_i, must be at least 0.\n@param[in]\nalpha\ndevice pointer or host pointer to scalar alpha.\n@param[in]\nx         device pointer pointing to the first vector (x_1).\n@param[in]\nincx      [int]\nspecifies the increment for the elements of each x_i.\n@param[in]\nstridex  [hipblasStride]\nstride from the start of one vector (x_i) and the next one (x_i+1).\n@param[inout]\nAP        device array of device pointers storing the packed version of the specified triangular portion of\neach Hermitian matrix A_i. Points to the first matrix (A_1).\nif uplo == HIPBLAS_FILL_MODE_UPPER:\nThe upper triangular portion of each Hermitian matrix A_i is supplied.\nThe matrix is compacted so that AP contains the triangular portion column-by-column\nso that:\nAP(0) = A(0,0)\nAP(1) = A(0,1)\nAP(2) = A(1,1), etc.\nEx: (HIPBLAS_FILL_MODE_UPPER; n = 3)\n(1, 0) (2, 1) (4,9)\n(2,-1) (3, 0) (5,3)  -----> [(1,0), (2,1), (3,0), (4,9), (5,3), (6,0)]\n(4,-9) (5,-3) (6,0)\nif uplo == HIPBLAS_FILL_MODE_LOWER:\nThe lower triangular portion of each Hermitian matrix A_i is supplied.\nThe matrix is compacted so that AP contains the triangular portion column-by-column\nso that:\nAP(0) = A(0,0)\nAP(1) = A(1,0)\nAP(2) = A(2,1), etc.\nEx: (HIPBLAS_FILL_MODE_LOWER; n = 3)\n(1, 0) (2, 1) (4,9)\n(2,-1) (3, 0) (5,3)  -----> [(1,0), (2,-1), (4,-9), (3,0), (5,-3), (6,0)]\n(4,-9) (5,-3) (6,0)\nNote that the imaginary part of the diagonal elements are not accessed and are assumed\nto be 0.\n@param[in]\nstrideA   [hipblasStride]\nstride from the start of one (A_i) and the next (A_i+1)\n@param[in]\nbatchCount [int]\nnumber of instances in the batch."]
    pub fn hipblasChprStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::std::os::raw::c_int,
        alpha: *const f32,
        x: *const hipblasComplex,
        incx: ::std::os::raw::c_int,
        stridex: hipblasStride,
        AP: *mut hipblasComplex,
        strideA: hipblasStride,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZhprStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::std::os::raw::c_int,
        alpha: *const f64,
        x: *const hipblasDoubleComplex,
        incx: ::std::os::raw::c_int,
        stridex: hipblasStride,
        AP: *mut hipblasDoubleComplex,
        strideA: hipblasStride,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasChprStridedBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::std::os::raw::c_int,
        alpha: *const f32,
        x: *const hipComplex,
        incx: ::std::os::raw::c_int,
        stridex: hipblasStride,
        AP: *mut hipComplex,
        strideA: hipblasStride,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZhprStridedBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::std::os::raw::c_int,
        alpha: *const f64,
        x: *const hipDoubleComplex,
        incx: ::std::os::raw::c_int,
        stridex: hipblasStride,
        AP: *mut hipDoubleComplex,
        strideA: hipblasStride,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 2 API\n\n\\details\nhpr2 performs the matrix-vector operations\n\nA := A + alpha*x*y**H + conj(alpha)*y*x**H\n\nwhere alpha is a complex scalar, x and y are vectors, and A is an\nn by n Hermitian matrix, supplied in packed form.\n\n- Supported precisions in rocBLAS : c,z\n- Supported precisions in cuBLAS  : c,z\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n@param[in]\nuplo      [hipblasFillMode_t]\nspecifies whether the upper 'HIPBLAS_FILL_MODE_UPPER' or lower 'HIPBLAS_FILL_MODE_LOWER'\nHIPBLAS_FILL_MODE_UPPER: The upper triangular part of A is supplied in AP.\nHIPBLAS_FILL_MODE_LOWER: The lower triangular part of A is supplied in AP.\n@param[in]\nn         [int]\nthe number of rows and columns of matrix A, must be at least 0.\n@param[in]\nalpha\ndevice pointer or host pointer to scalar alpha.\n@param[in]\nx         device pointer storing vector x.\n@param[in]\nincx      [int]\nspecifies the increment for the elements of x.\n@param[in]\ny         device pointer storing vector y.\n@param[in]\nincy      [int]\nspecifies the increment for the elements of y.\n@param[inout]\nAP        device pointer storing the packed version of the specified triangular portion of\nthe Hermitian matrix A. Of at least size ((n * (n + 1)) / 2).\nif uplo == HIPBLAS_FILL_MODE_UPPER:\nThe upper triangular portion of the Hermitian matrix A is supplied.\nThe matrix is compacted so that AP contains the triangular portion column-by-column\nso that:\nAP(0) = A(0,0)\nAP(1) = A(0,1)\nAP(2) = A(1,1), etc.\nEx: (HIPBLAS_FILL_MODE_UPPER; n = 3)\n(1, 0) (2, 1) (4,9)\n(2,-1) (3, 0) (5,3)  -----> [(1,0), (2,1), (3,0), (4,9), (5,3), (6,0)]\n(4,-9) (5,-3) (6,0)\nif uplo == HIPBLAS_FILL_MODE_LOWER:\nThe lower triangular portion of the Hermitian matrix A is supplied.\nThe matrix is compacted so that AP contains the triangular portion column-by-column\nso that:\nAP(0) = A(0,0)\nAP(1) = A(1,0)\nAP(2) = A(2,1), etc.\nEx: (HIPBLAS_FILL_MODE_LOWER; n = 3)\n(1, 0) (2, 1) (4,9)\n(2,-1) (3, 0) (5,3)  -----> [(1,0), (2,-1), (4,-9), (3,0), (5,-3), (6,0)]\n(4,-9) (5,-3) (6,0)\nNote that the imaginary part of the diagonal elements are not accessed and are assumed\nto be 0."]
    pub fn hipblasChpr2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::std::os::raw::c_int,
        alpha: *const hipblasComplex,
        x: *const hipblasComplex,
        incx: ::std::os::raw::c_int,
        y: *const hipblasComplex,
        incy: ::std::os::raw::c_int,
        AP: *mut hipblasComplex,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZhpr2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::std::os::raw::c_int,
        alpha: *const hipblasDoubleComplex,
        x: *const hipblasDoubleComplex,
        incx: ::std::os::raw::c_int,
        y: *const hipblasDoubleComplex,
        incy: ::std::os::raw::c_int,
        AP: *mut hipblasDoubleComplex,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasChpr2_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::std::os::raw::c_int,
        alpha: *const hipComplex,
        x: *const hipComplex,
        incx: ::std::os::raw::c_int,
        y: *const hipComplex,
        incy: ::std::os::raw::c_int,
        AP: *mut hipComplex,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZhpr2_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::std::os::raw::c_int,
        alpha: *const hipDoubleComplex,
        x: *const hipDoubleComplex,
        incx: ::std::os::raw::c_int,
        y: *const hipDoubleComplex,
        incy: ::std::os::raw::c_int,
        AP: *mut hipDoubleComplex,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 2 API\n\n\\details\nhpr2Batched performs the matrix-vector operations\n\nA_i := A_i + alpha*x_i*y_i**H + conj(alpha)*y_i*x_i**H\n\nwhere alpha is a complex scalar, x_i and y_i are vectors, and A_i is an\nn by n symmetric matrix, supplied in packed form, for i = 1, ..., batchCount.\n\n- Supported precisions in rocBLAS : c,z\n- Supported precisions in cuBLAS  : No support\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n@param[in]\nuplo      [hipblasFillMode_t]\nspecifies whether the upper 'HIPBLAS_FILL_MODE_UPPER' or lower 'HIPBLAS_FILL_MODE_LOWER'\nHIPBLAS_FILL_MODE_UPPER: The upper triangular part of each A_i is supplied in AP.\nHIPBLAS_FILL_MODE_LOWER: The lower triangular part of each A_i is supplied in AP.\n@param[in]\nn         [int]\nthe number of rows and columns of each matrix A_i, must be at least 0.\n@param[in]\nalpha\ndevice pointer or host pointer to scalar alpha.\n@param[in]\nx         device array of device pointers storing each vector x_i.\n@param[in]\nincx      [int]\nspecifies the increment for the elements of each x_i.\n@param[in]\ny         device array of device pointers storing each vector y_i.\n@param[in]\nincy      [int]\nspecifies the increment for the elements of each y_i.\n@param[inout]\nAP        device array of device pointers storing the packed version of the specified triangular portion of\neach Hermitian matrix A_i of at least size ((n * (n + 1)) / 2). Array is of at least size batchCount.\nif uplo == HIPBLAS_FILL_MODE_UPPER:\nThe upper triangular portion of each Hermitian matrix A_i is supplied.\nThe matrix is compacted so that AP contains the triangular portion column-by-column\nso that:\nAP(0) = A(0,0)\nAP(1) = A(0,1)\nAP(2) = A(1,1), etc.\nEx: (HIPBLAS_FILL_MODE_UPPER; n = 3)\n(1, 0) (2, 1) (4,9)\n(2,-1) (3, 0) (5,3)  -----> [(1,0), (2,1), (3,0), (4,9), (5,3), (6,0)]\n(4,-9) (5,-3) (6,0)\nif uplo == HIPBLAS_FILL_MODE_LOWER:\nThe lower triangular portion of each Hermitian matrix A_i is supplied.\nThe matrix is compacted so that AP contains the triangular portion column-by-column\nso that:\nAP(0) = A(0,0)\nAP(1) = A(1,0)\nAP(2) = A(2,1), etc.\nEx: (HIPBLAS_FILL_MODE_LOWER; n = 3)\n(1, 0) (2, 1) (4,9)\n(2,-1) (3, 0) (5,3)  -----> [(1,0), (2,-1), (4,-9), (3,0), (5,-3), (6,0)]\n(4,-9) (5,-3) (6,0)\nNote that the imaginary part of the diagonal elements are not accessed and are assumed\nto be 0.\n@param[in]\nbatchCount [int]\nnumber of instances in the batch."]
    pub fn hipblasChpr2Batched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::std::os::raw::c_int,
        alpha: *const hipblasComplex,
        x: *const *const hipblasComplex,
        incx: ::std::os::raw::c_int,
        y: *const *const hipblasComplex,
        incy: ::std::os::raw::c_int,
        AP: *const *mut hipblasComplex,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZhpr2Batched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::std::os::raw::c_int,
        alpha: *const hipblasDoubleComplex,
        x: *const *const hipblasDoubleComplex,
        incx: ::std::os::raw::c_int,
        y: *const *const hipblasDoubleComplex,
        incy: ::std::os::raw::c_int,
        AP: *const *mut hipblasDoubleComplex,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasChpr2Batched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::std::os::raw::c_int,
        alpha: *const hipComplex,
        x: *const *const hipComplex,
        incx: ::std::os::raw::c_int,
        y: *const *const hipComplex,
        incy: ::std::os::raw::c_int,
        AP: *const *mut hipComplex,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZhpr2Batched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::std::os::raw::c_int,
        alpha: *const hipDoubleComplex,
        x: *const *const hipDoubleComplex,
        incx: ::std::os::raw::c_int,
        y: *const *const hipDoubleComplex,
        incy: ::std::os::raw::c_int,
        AP: *const *mut hipDoubleComplex,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 2 API\n\n\\details\nhpr2StridedBatched performs the matrix-vector operations\n\nA_i := A_i + alpha*x_i*y_i**H + conj(alpha)*y_i*x_i**H\n\nwhere alpha is a complex scalar, x_i and y_i are vectors, and A_i is an\nn by n symmetric matrix, supplied in packed form, for i = 1, ..., batchCount.\n\n- Supported precisions in rocBLAS : c,z\n- Supported precisions in cuBLAS  : No support\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n@param[in]\nuplo      [hipblasFillMode_t]\nspecifies whether the upper 'HIPBLAS_FILL_MODE_UPPER' or lower 'HIPBLAS_FILL_MODE_LOWER'\nHIPBLAS_FILL_MODE_UPPER: The upper triangular part of each A_i is supplied in AP.\nHIPBLAS_FILL_MODE_LOWER: The lower triangular part of each A_i is supplied in AP.\n@param[in]\nn         [int]\nthe number of rows and columns of each matrix A_i, must be at least 0.\n@param[in]\nalpha\ndevice pointer or host pointer to scalar alpha.\n@param[in]\nx         device pointer pointing to the first vector (x_1).\n@param[in]\nincx      [int]\nspecifies the increment for the elements of each x_i.\n@param[in]\nstridex  [hipblasStride]\nstride from the start of one vector (x_i) and the next one (x_i+1).\n@param[in]\ny         device pointer pointing to the first vector (y_1).\n@param[in]\nincy      [int]\nspecifies the increment for the elements of each y_i.\n@param[in]\nstridey  [hipblasStride]\nstride from the start of one vector (y_i) and the next one (y_i+1).\n@param[inout]\nAP        device array of device pointers storing the packed version of the specified triangular portion of\neach Hermitian matrix A_i. Points to the first matrix (A_1).\nif uplo == HIPBLAS_FILL_MODE_UPPER:\nThe upper triangular portion of each Hermitian matrix A_i is supplied.\nThe matrix is compacted so that AP contains the triangular portion column-by-column\nso that:\nAP(0) = A(0,0)\nAP(1) = A(0,1)\nAP(2) = A(1,1), etc.\nEx: (HIPBLAS_FILL_MODE_UPPER; n = 3)\n(1, 0) (2, 1) (4,9)\n(2,-1) (3, 0) (5,3)  -----> [(1,0), (2,1), (3,0), (4,9), (5,3), (6,0)]\n(4,-9) (5,-3) (6,0)\nif uplo == HIPBLAS_FILL_MODE_LOWER:\nThe lower triangular portion of each Hermitian matrix A_i is supplied.\nThe matrix is compacted so that AP contains the triangular portion column-by-column\nso that:\nAP(0) = A(0,0)\nAP(1) = A(1,0)\nAP(2) = A(2,1), etc.\nEx: (HIPBLAS_FILL_MODE_LOWER; n = 3)\n(1, 0) (2, 1) (4,9)\n(2,-1) (3, 0) (5,3)  -----> [(1,0), (2,-1), (4,-9), (3,0), (5,-3), (6,0)]\n(4,-9) (5,-3) (6,0)\nNote that the imaginary part of the diagonal elements are not accessed and are assumed\nto be 0.\n@param[in]\nstrideA    [hipblasStride]\nstride from the start of one (A_i) and the next (A_i+1)\n@param[in]\nbatchCount [int]\nnumber of instances in the batch."]
    pub fn hipblasChpr2StridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::std::os::raw::c_int,
        alpha: *const hipblasComplex,
        x: *const hipblasComplex,
        incx: ::std::os::raw::c_int,
        stridex: hipblasStride,
        y: *const hipblasComplex,
        incy: ::std::os::raw::c_int,
        stridey: hipblasStride,
        AP: *mut hipblasComplex,
        strideA: hipblasStride,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZhpr2StridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::std::os::raw::c_int,
        alpha: *const hipblasDoubleComplex,
        x: *const hipblasDoubleComplex,
        incx: ::std::os::raw::c_int,
        stridex: hipblasStride,
        y: *const hipblasDoubleComplex,
        incy: ::std::os::raw::c_int,
        stridey: hipblasStride,
        AP: *mut hipblasDoubleComplex,
        strideA: hipblasStride,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasChpr2StridedBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::std::os::raw::c_int,
        alpha: *const hipComplex,
        x: *const hipComplex,
        incx: ::std::os::raw::c_int,
        stridex: hipblasStride,
        y: *const hipComplex,
        incy: ::std::os::raw::c_int,
        stridey: hipblasStride,
        AP: *mut hipComplex,
        strideA: hipblasStride,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZhpr2StridedBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::std::os::raw::c_int,
        alpha: *const hipDoubleComplex,
        x: *const hipDoubleComplex,
        incx: ::std::os::raw::c_int,
        stridex: hipblasStride,
        y: *const hipDoubleComplex,
        incy: ::std::os::raw::c_int,
        stridey: hipblasStride,
        AP: *mut hipDoubleComplex,
        strideA: hipblasStride,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 2 API\n\n\\details\nsbmv performs the matrix-vector operation:\n\ny := alpha*A*x + beta*y,\n\nwhere alpha and beta are scalars, x and y are n element vectors and\nA should contain an upper or lower triangular n by n symmetric banded matrix.\n\n- Supported precisions in rocBLAS : s,d\n- Supported precisions in cuBLAS  : s,d\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n@param[in]\nuplo      [hipblasFillMode_t]\nspecifies whether the upper 'HIPBLAS_FILL_MODE_UPPER' or lower 'HIPBLAS_FILL_MODE_LOWER'\nif HIPBLAS_FILL_MODE_UPPER, the lower part of A is not referenced\nif HIPBLAS_FILL_MODE_LOWER, the upper part of A is not referenced\n@param[in]\nn         [int]\n@param[in]\nk         [int]\nspecifies the number of sub- and super-diagonals\n@param[in]\nalpha\nspecifies the scalar alpha\n@param[in]\nAP         pointer storing matrix A on the GPU\n@param[in]\nlda       [int]\nspecifies the leading dimension of matrix A\n@param[in]\nx         pointer storing vector x on the GPU\n@param[in]\nincx      [int]\nspecifies the increment for the elements of x\n@param[in]\nbeta      specifies the scalar beta\n@param[out]\ny         pointer storing vector y on the GPU\n@param[in]\nincy      [int]\nspecifies the increment for the elements of y\n"]
    pub fn hipblasSsbmv(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        alpha: *const f32,
        AP: *const f32,
        lda: ::std::os::raw::c_int,
        x: *const f32,
        incx: ::std::os::raw::c_int,
        beta: *const f32,
        y: *mut f32,
        incy: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDsbmv(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        alpha: *const f64,
        AP: *const f64,
        lda: ::std::os::raw::c_int,
        x: *const f64,
        incx: ::std::os::raw::c_int,
        beta: *const f64,
        y: *mut f64,
        incy: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 2 API\n\n\\details\nsbmvBatched performs the matrix-vector operation:\n\ny_i := alpha*A_i*x_i + beta*y_i,\n\nwhere (A_i, x_i, y_i) is the i-th instance of the batch.\nalpha and beta are scalars, x_i and y_i are vectors and A_i is an\nn by n symmetric banded matrix, for i = 1, ..., batchCount.\nA should contain an upper or lower triangular n by n symmetric banded matrix.\n\n- Supported precisions in rocBLAS : s,d\n- Supported precisions in cuBLAS  : No support\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue\n@param[in]\nuplo      [hipblasFillMode_t]\nspecifies whether the upper 'HIPBLAS_FILL_MODE_UPPER' or lower 'HIPBLAS_FILL_MODE_LOWER'\nif HIPBLAS_FILL_MODE_UPPER, the lower part of A is not referenced\nif HIPBLAS_FILL_MODE_LOWER, the upper part of A is not referenced\n@param[in]\nn         [int]\nnumber of rows and columns of each matrix A_i\n@param[in]\nk         [int]\nspecifies the number of sub- and super-diagonals\n@param[in]\nalpha\ndevice pointer or host pointer to scalar alpha\n@param[in]\nAP         device array of device pointers storing each matrix A_i\n@param[in]\nlda       [int]\nspecifies the leading dimension of each matrix A_i\n@param[in]\nx         device array of device pointers storing each vector x_i\n@param[in]\nincx      [int]\nspecifies the increment for the elements of each vector x_i\n@param[in]\nbeta      device pointer or host pointer to scalar beta\n@param[out]\ny         device array of device pointers storing each vector y_i\n@param[in]\nincy      [int]\nspecifies the increment for the elements of each vector y_i\n@param[in]\nbatchCount [int]\nnumber of instances in the batch\n"]
    pub fn hipblasSsbmvBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        alpha: *const f32,
        AP: *const *const f32,
        lda: ::std::os::raw::c_int,
        x: *const *const f32,
        incx: ::std::os::raw::c_int,
        beta: *const f32,
        y: *const *mut f32,
        incy: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDsbmvBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        alpha: *const f64,
        AP: *const *const f64,
        lda: ::std::os::raw::c_int,
        x: *const *const f64,
        incx: ::std::os::raw::c_int,
        beta: *const f64,
        y: *const *mut f64,
        incy: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 2 API\n\n\\details\nsbmvStridedBatched performs the matrix-vector operation:\n\ny_i := alpha*A_i*x_i + beta*y_i,\n\nwhere (A_i, x_i, y_i) is the i-th instance of the batch.\nalpha and beta are scalars, x_i and y_i are vectors and A_i is an\nn by n symmetric banded matrix, for i = 1, ..., batchCount.\nA should contain an upper or lower triangular n by n symmetric banded matrix.\n\n- Supported precisions in rocBLAS : s,d\n- Supported precisions in cuBLAS  : No support\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue\n@param[in]\nuplo      [hipblasFillMode_t]\nspecifies whether the upper 'HIPBLAS_FILL_MODE_UPPER' or lower 'HIPBLAS_FILL_MODE_LOWER'\nif HIPBLAS_FILL_MODE_UPPER, the lower part of A is not referenced\nif HIPBLAS_FILL_MODE_LOWER, the upper part of A is not referenced\n@param[in]\nn         [int]\nnumber of rows and columns of each matrix A_i\n@param[in]\nk         [int]\nspecifies the number of sub- and super-diagonals\n@param[in]\nalpha\ndevice pointer or host pointer to scalar alpha\n@param[in]\nAP        Device pointer to the first matrix A_1 on the GPU\n@param[in]\nlda       [int]\nspecifies the leading dimension of each matrix A_i\n@param[in]\nstrideA     [hipblasStride]\nstride from the start of one matrix (A_i) and the next one (A_i+1)\n@param[in]\nx         Device pointer to the first vector x_1 on the GPU\n@param[in]\nincx      [int]\nspecifies the increment for the elements of each vector x_i\n@param[in]\nstridex     [hipblasStride]\nstride from the start of one vector (x_i) and the next one (x_i+1).\nThere are no restrictions placed on stridex, however the user should\ntake care to ensure that stridex is of appropriate size.\nThis typically means stridex >= n * incx. stridex should be non zero.\n@param[in]\nbeta      device pointer or host pointer to scalar beta\n@param[out]\ny         Device pointer to the first vector y_1 on the GPU\n@param[in]\nincy      [int]\nspecifies the increment for the elements of each vector y_i\n@param[in]\nstridey     [hipblasStride]\nstride from the start of one vector (y_i) and the next one (y_i+1).\nThere are no restrictions placed on stridey, however the user should\ntake care to ensure that stridey is of appropriate size.\nThis typically means stridey >= n * incy. stridey should be non zero.\n@param[in]\nbatchCount [int]\nnumber of instances in the batch\n"]
    pub fn hipblasSsbmvStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        alpha: *const f32,
        AP: *const f32,
        lda: ::std::os::raw::c_int,
        strideA: hipblasStride,
        x: *const f32,
        incx: ::std::os::raw::c_int,
        stridex: hipblasStride,
        beta: *const f32,
        y: *mut f32,
        incy: ::std::os::raw::c_int,
        stridey: hipblasStride,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDsbmvStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        alpha: *const f64,
        AP: *const f64,
        lda: ::std::os::raw::c_int,
        strideA: hipblasStride,
        x: *const f64,
        incx: ::std::os::raw::c_int,
        stridex: hipblasStride,
        beta: *const f64,
        y: *mut f64,
        incy: ::std::os::raw::c_int,
        stridey: hipblasStride,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 2 API\n\n\\details\nspmv performs the matrix-vector operation:\n\ny := alpha*A*x + beta*y,\n\nwhere alpha and beta are scalars, x and y are n element vectors and\nA should contain an upper or lower triangular n by n packed symmetric matrix.\n\n- Supported precisions in rocBLAS : s,d\n- Supported precisions in cuBLAS  : s,d\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n@param[in]\nuplo      [hipblasFillMode_t]\nspecifies whether the upper 'HIPBLAS_FILL_MODE_UPPER' or lower 'HIPBLAS_FILL_MODE_LOWER'\nif HIPBLAS_FILL_MODE_UPPER, the lower part of A is not referenced\nif HIPBLAS_FILL_MODE_LOWER, the upper part of A is not referenced\n@param[in]\nn         [int]\n@param[in]\nalpha\nspecifies the scalar alpha\n@param[in]\nAP         pointer storing matrix A on the GPU\n@param[in]\nx         pointer storing vector x on the GPU\n@param[in]\nincx      [int]\nspecifies the increment for the elements of x\n@param[in]\nbeta      specifies the scalar beta\n@param[out]\ny         pointer storing vector y on the GPU\n@param[in]\nincy      [int]\nspecifies the increment for the elements of y\n"]
    pub fn hipblasSspmv(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::std::os::raw::c_int,
        alpha: *const f32,
        AP: *const f32,
        x: *const f32,
        incx: ::std::os::raw::c_int,
        beta: *const f32,
        y: *mut f32,
        incy: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDspmv(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::std::os::raw::c_int,
        alpha: *const f64,
        AP: *const f64,
        x: *const f64,
        incx: ::std::os::raw::c_int,
        beta: *const f64,
        y: *mut f64,
        incy: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 2 API\n\n\\details\nspmvBatched performs the matrix-vector operation:\n\ny_i := alpha*AP_i*x_i + beta*y_i,\n\nwhere (A_i, x_i, y_i) is the i-th instance of the batch.\nalpha and beta are scalars, x_i and y_i are vectors and A_i is an\nn by n symmetric matrix, for i = 1, ..., batchCount.\nA should contain an upper or lower triangular n by n packed symmetric matrix.\n\n- Supported precisions in rocBLAS : s,d\n- Supported precisions in cuBLAS  : No support\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue\n@param[in]\nuplo      [hipblasFillMode_t]\nspecifies whether the upper 'HIPBLAS_FILL_MODE_UPPER' or lower 'HIPBLAS_FILL_MODE_LOWER'\nif HIPBLAS_FILL_MODE_UPPER, the lower part of A is not referenced\nif HIPBLAS_FILL_MODE_LOWER, the upper part of A is not referenced\n@param[in]\nn         [int]\nnumber of rows and columns of each matrix A_i\n@param[in]\nalpha\ndevice pointer or host pointer to scalar alpha\n@param[in]\nAP         device array of device pointers storing each matrix A_i\n@param[in]\nx         device array of device pointers storing each vector x_i\n@param[in]\nincx      [int]\nspecifies the increment for the elements of each vector x_i\n@param[in]\nbeta      device pointer or host pointer to scalar beta\n@param[out]\ny         device array of device pointers storing each vector y_i\n@param[in]\nincy      [int]\nspecifies the increment for the elements of each vector y_i\n@param[in]\nbatchCount [int]\nnumber of instances in the batch\n"]
    pub fn hipblasSspmvBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::std::os::raw::c_int,
        alpha: *const f32,
        AP: *const *const f32,
        x: *const *const f32,
        incx: ::std::os::raw::c_int,
        beta: *const f32,
        y: *const *mut f32,
        incy: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDspmvBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::std::os::raw::c_int,
        alpha: *const f64,
        AP: *const *const f64,
        x: *const *const f64,
        incx: ::std::os::raw::c_int,
        beta: *const f64,
        y: *const *mut f64,
        incy: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 2 API\n\n\\details\nspmvStridedBatched performs the matrix-vector operation:\n\ny_i := alpha*A_i*x_i + beta*y_i,\n\nwhere (A_i, x_i, y_i) is the i-th instance of the batch.\nalpha and beta are scalars, x_i and y_i are vectors and A_i is an\nn by n symmetric matrix, for i = 1, ..., batchCount.\nA should contain an upper or lower triangular n by n packed symmetric matrix.\n\n- Supported precisions in rocBLAS : s,d\n- Supported precisions in cuBLAS  : No support\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue\n@param[in]\nuplo      [hipblasFillMode_t]\nspecifies whether the upper 'HIPBLAS_FILL_MODE_UPPER' or lower 'HIPBLAS_FILL_MODE_LOWER'\nif HIPBLAS_FILL_MODE_UPPER, the lower part of A is not referenced\nif HIPBLAS_FILL_MODE_LOWER, the upper part of A is not referenced\n@param[in]\nn         [int]\nnumber of rows and columns of each matrix A_i\n@param[in]\nalpha\ndevice pointer or host pointer to scalar alpha\n@param[in]\nAP        Device pointer to the first matrix A_1 on the GPU\n@param[in]\nstrideA    [hipblasStride]\nstride from the start of one matrix (A_i) and the next one (A_i+1)\n@param[in]\nx         Device pointer to the first vector x_1 on the GPU\n@param[in]\nincx      [int]\nspecifies the increment for the elements of each vector x_i\n@param[in]\nstridex     [hipblasStride]\nstride from the start of one vector (x_i) and the next one (x_i+1).\nThere are no restrictions placed on stridex, however the user should\ntake care to ensure that stridex is of appropriate size.\nThis typically means stridex >= n * incx. stridex should be non zero.\n@param[in]\nbeta      device pointer or host pointer to scalar beta\n@param[out]\ny         Device pointer to the first vector y_1 on the GPU\n@param[in]\nincy      [int]\nspecifies the increment for the elements of each vector y_i\n@param[in]\nstridey     [hipblasStride]\nstride from the start of one vector (y_i) and the next one (y_i+1).\nThere are no restrictions placed on stridey, however the user should\ntake care to ensure that stridey is of appropriate size.\nThis typically means stridey >= n * incy. stridey should be non zero.\n@param[in]\nbatchCount [int]\nnumber of instances in the batch\n"]
    pub fn hipblasSspmvStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::std::os::raw::c_int,
        alpha: *const f32,
        AP: *const f32,
        strideA: hipblasStride,
        x: *const f32,
        incx: ::std::os::raw::c_int,
        stridex: hipblasStride,
        beta: *const f32,
        y: *mut f32,
        incy: ::std::os::raw::c_int,
        stridey: hipblasStride,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDspmvStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::std::os::raw::c_int,
        alpha: *const f64,
        AP: *const f64,
        strideA: hipblasStride,
        x: *const f64,
        incx: ::std::os::raw::c_int,
        stridex: hipblasStride,
        beta: *const f64,
        y: *mut f64,
        incy: ::std::os::raw::c_int,
        stridey: hipblasStride,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 2 API\n\n\\details\nspr performs the matrix-vector operations\n\nA := A + alpha*x*x**T\n\nwhere alpha is a scalar, x is a vector, and A is an\nn by n symmetric matrix, supplied in packed form.\n\n- Supported precisions in rocBLAS : s,d,c,z\n- Supported precisions in cuBLAS  : s,d,c,z\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n@param[in]\nuplo      [hipblasFillMode_t]\nspecifies whether the upper 'HIPBLAS_FILL_MODE_UPPER' or lower 'HIPBLAS_FILL_MODE_LOWER'\nHIPBLAS_FILL_MODE_UPPER: The upper triangular part of A is supplied in AP.\nHIPBLAS_FILL_MODE_LOWER: The lower triangular part of A is supplied in AP.\n@param[in]\nn         [int]\nthe number of rows and columns of matrix A, must be at least 0.\n@param[in]\nalpha\ndevice pointer or host pointer to scalar alpha.\n@param[in]\nx         device pointer storing vector x.\n@param[in]\nincx      [int]\nspecifies the increment for the elements of x.\n@param[inout]\nAP        device pointer storing the packed version of the specified triangular portion of\nthe symmetric matrix A. Of at least size ((n * (n + 1)) / 2).\nif uplo == HIPBLAS_FILL_MODE_UPPER:\nThe upper triangular portion of the symmetric matrix A is supplied.\nThe matrix is compacted so that AP contains the triangular portion column-by-column\nso that:\nAP(0) = A(0,0)\nAP(1) = A(0,1)\nAP(2) = A(1,1), etc.\nEx: (HIPBLAS_FILL_MODE_UPPER; n = 4)\n1 2 4 7\n2 3 5 8   -----> [1, 2, 3, 4, 5, 6, 7, 8, 9, 0]\n4 5 6 9\n7 8 9 0\nif uplo == HIPBLAS_FILL_MODE_LOWER:\nThe lower triangular portion of the symmetric matrix A is supplied.\nThe matrix is compacted so that AP contains the triangular portion column-by-column\nso that:\nAP(0) = A(0,0)\nAP(1) = A(1,0)\nAP(2) = A(2,1), etc.\nEx: (HIPBLAS_FILL_MODE_LOWER; n = 4)\n1 2 3 4\n2 5 6 7    -----> [1, 2, 3, 4, 5, 6, 7, 8, 9, 0]\n3 6 8 9\n4 7 9 0"]
    pub fn hipblasSspr(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::std::os::raw::c_int,
        alpha: *const f32,
        x: *const f32,
        incx: ::std::os::raw::c_int,
        AP: *mut f32,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDspr(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::std::os::raw::c_int,
        alpha: *const f64,
        x: *const f64,
        incx: ::std::os::raw::c_int,
        AP: *mut f64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCspr(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::std::os::raw::c_int,
        alpha: *const hipblasComplex,
        x: *const hipblasComplex,
        incx: ::std::os::raw::c_int,
        AP: *mut hipblasComplex,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZspr(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::std::os::raw::c_int,
        alpha: *const hipblasDoubleComplex,
        x: *const hipblasDoubleComplex,
        incx: ::std::os::raw::c_int,
        AP: *mut hipblasDoubleComplex,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCspr_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::std::os::raw::c_int,
        alpha: *const hipComplex,
        x: *const hipComplex,
        incx: ::std::os::raw::c_int,
        AP: *mut hipComplex,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZspr_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::std::os::raw::c_int,
        alpha: *const hipDoubleComplex,
        x: *const hipDoubleComplex,
        incx: ::std::os::raw::c_int,
        AP: *mut hipDoubleComplex,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 2 API\n\n\\details\nsprBatched performs the matrix-vector operations\n\nA_i := A_i + alpha*x_i*x_i**T\n\nwhere alpha is a scalar, x_i is a vector, and A_i is an\nn by n symmetric matrix, supplied in packed form, for i = 1, ..., batchCount.\n\n- Supported precisions in rocBLAS : s,d,c,z\n- Supported precisions in cuBLAS  : No support\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n@param[in]\nuplo      [hipblasFillMode_t]\nspecifies whether the upper 'HIPBLAS_FILL_MODE_UPPER' or lower 'HIPBLAS_FILL_MODE_LOWER'\nHIPBLAS_FILL_MODE_UPPER: The upper triangular part of each A_i is supplied in AP.\nHIPBLAS_FILL_MODE_LOWER: The lower triangular part of each A_i is supplied in AP.\n@param[in]\nn         [int]\nthe number of rows and columns of each matrix A_i, must be at least 0.\n@param[in]\nalpha\ndevice pointer or host pointer to scalar alpha.\n@param[in]\nx         device array of device pointers storing each vector x_i.\n@param[in]\nincx      [int]\nspecifies the increment for the elements of each x_i.\n@param[inout]\nAP        device array of device pointers storing the packed version of the specified triangular portion of\neach symmetric matrix A_i of at least size ((n * (n + 1)) / 2). Array is of at least size batchCount.\nif uplo == HIPBLAS_FILL_MODE_UPPER:\nThe upper triangular portion of each symmetric matrix A_i is supplied.\nThe matrix is compacted so that AP contains the triangular portion column-by-column\nso that:\nAP(0) = A(0,0)\nAP(1) = A(0,1)\nAP(2) = A(1,1), etc.\nEx: (HIPBLAS_FILL_MODE_UPPER; n = 4)\n1 2 4 7\n2 3 5 8   -----> [1, 2, 3, 4, 5, 6, 7, 8, 9, 0]\n4 5 6 9\n7 8 9 0\nif uplo == HIPBLAS_FILL_MODE_LOWER:\nThe lower triangular portion of each symmetric matrix A_i is supplied.\nThe matrix is compacted so that AP contains the triangular portion column-by-column\nso that:\nAP(0) = A(0,0)\nAP(1) = A(1,0)\nAP(2) = A(2,1), etc.\nEx: (HIPBLAS_FILL_MODE_LOWER; n = 4)\n1 2 3 4\n2 5 6 7    -----> [1, 2, 3, 4, 5, 6, 7, 8, 9, 0]\n3 6 8 9\n4 7 9 0\n@param[in]\nbatchCount [int]\nnumber of instances in the batch."]
    pub fn hipblasSsprBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::std::os::raw::c_int,
        alpha: *const f32,
        x: *const *const f32,
        incx: ::std::os::raw::c_int,
        AP: *const *mut f32,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDsprBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::std::os::raw::c_int,
        alpha: *const f64,
        x: *const *const f64,
        incx: ::std::os::raw::c_int,
        AP: *const *mut f64,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsprBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::std::os::raw::c_int,
        alpha: *const hipblasComplex,
        x: *const *const hipblasComplex,
        incx: ::std::os::raw::c_int,
        AP: *const *mut hipblasComplex,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZsprBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::std::os::raw::c_int,
        alpha: *const hipblasDoubleComplex,
        x: *const *const hipblasDoubleComplex,
        incx: ::std::os::raw::c_int,
        AP: *const *mut hipblasDoubleComplex,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsprBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::std::os::raw::c_int,
        alpha: *const hipComplex,
        x: *const *const hipComplex,
        incx: ::std::os::raw::c_int,
        AP: *const *mut hipComplex,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZsprBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::std::os::raw::c_int,
        alpha: *const hipDoubleComplex,
        x: *const *const hipDoubleComplex,
        incx: ::std::os::raw::c_int,
        AP: *const *mut hipDoubleComplex,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 2 API\n\n\\details\nsprStridedBatched performs the matrix-vector operations\n\nA_i := A_i + alpha*x_i*x_i**T\n\nwhere alpha is a scalar, x_i is a vector, and A_i is an\nn by n symmetric matrix, supplied in packed form, for i = 1, ..., batchCount.\n\n- Supported precisions in rocBLAS : s,d,c,z\n- Supported precisions in cuBLAS  : No support\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n@param[in]\nuplo      [hipblasFillMode_t]\nspecifies whether the upper 'HIPBLAS_FILL_MODE_UPPER' or lower 'HIPBLAS_FILL_MODE_LOWER'\nHIPBLAS_FILL_MODE_UPPER: The upper triangular part of each A_i is supplied in AP.\nHIPBLAS_FILL_MODE_LOWER: The lower triangular part of each A_i is supplied in AP.\n@param[in]\nn         [int]\nthe number of rows and columns of each matrix A_i, must be at least 0.\n@param[in]\nalpha\ndevice pointer or host pointer to scalar alpha.\n@param[in]\nx         device pointer pointing to the first vector (x_1).\n@param[in]\nincx      [int]\nspecifies the increment for the elements of each x_i.\n@param[in]\nstridex  [hipblasStride]\nstride from the start of one vector (x_i) and the next one (x_i+1).\n@param[inout]\nAP        device pointer storing the packed version of the specified triangular portion of\neach symmetric matrix A_i. Points to the first A_1.\nif uplo == HIPBLAS_FILL_MODE_UPPER:\nThe upper triangular portion of each symmetric matrix A_i is supplied.\nThe matrix is compacted so that AP contains the triangular portion column-by-column\nso that:\nAP(0) = A(0,0)\nAP(1) = A(0,1)\nAP(2) = A(1,1), etc.\nEx: (HIPBLAS_FILL_MODE_UPPER; n = 4)\n1 2 4 7\n2 3 5 8   -----> [1, 2, 3, 4, 5, 6, 7, 8, 9, 0]\n4 5 6 9\n7 8 9 0\nif uplo == HIPBLAS_FILL_MODE_LOWER:\nThe lower triangular portion of each symmetric matrix A_i is supplied.\nThe matrix is compacted so that AP contains the triangular portion column-by-column\nso that:\nAP(0) = A(0,0)\nAP(1) = A(1,0)\nAP(2) = A(2,1), etc.\nEx: (HIPBLAS_FILL_MODE_LOWER; n = 4)\n1 2 3 4\n2 5 6 7    -----> [1, 2, 3, 4, 5, 6, 7, 8, 9, 0]\n3 6 8 9\n4 7 9 0\n@param[in]\nstrideA    [hipblasStride]\nstride from the start of one (A_i) and the next (A_i+1)\n@param[in]\nbatchCount [int]\nnumber of instances in the batch."]
    pub fn hipblasSsprStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::std::os::raw::c_int,
        alpha: *const f32,
        x: *const f32,
        incx: ::std::os::raw::c_int,
        stridex: hipblasStride,
        AP: *mut f32,
        strideA: hipblasStride,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDsprStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::std::os::raw::c_int,
        alpha: *const f64,
        x: *const f64,
        incx: ::std::os::raw::c_int,
        stridex: hipblasStride,
        AP: *mut f64,
        strideA: hipblasStride,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsprStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::std::os::raw::c_int,
        alpha: *const hipblasComplex,
        x: *const hipblasComplex,
        incx: ::std::os::raw::c_int,
        stridex: hipblasStride,
        AP: *mut hipblasComplex,
        strideA: hipblasStride,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZsprStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::std::os::raw::c_int,
        alpha: *const hipblasDoubleComplex,
        x: *const hipblasDoubleComplex,
        incx: ::std::os::raw::c_int,
        stridex: hipblasStride,
        AP: *mut hipblasDoubleComplex,
        strideA: hipblasStride,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsprStridedBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::std::os::raw::c_int,
        alpha: *const hipComplex,
        x: *const hipComplex,
        incx: ::std::os::raw::c_int,
        stridex: hipblasStride,
        AP: *mut hipComplex,
        strideA: hipblasStride,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZsprStridedBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::std::os::raw::c_int,
        alpha: *const hipDoubleComplex,
        x: *const hipDoubleComplex,
        incx: ::std::os::raw::c_int,
        stridex: hipblasStride,
        AP: *mut hipDoubleComplex,
        strideA: hipblasStride,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 2 API\n\n\\details\nspr2 performs the matrix-vector operation\n\nA := A + alpha*x*y**T + alpha*y*x**T\n\nwhere alpha is a scalar, x and y are vectors, and A is an\nn by n symmetric matrix, supplied in packed form.\n\n- Supported precisions in rocBLAS : s,d\n- Supported precisions in cuBLAS  : s,d\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n@param[in]\nuplo      [hipblasFillMode_t]\nspecifies whether the upper 'HIPBLAS_FILL_MODE_UPPER' or lower 'HIPBLAS_FILL_MODE_LOWER'\nHIPBLAS_FILL_MODE_UPPER: The upper triangular part of A is supplied in AP.\nHIPBLAS_FILL_MODE_LOWER: The lower triangular part of A is supplied in AP.\n@param[in]\nn         [int]\nthe number of rows and columns of matrix A, must be at least 0.\n@param[in]\nalpha\ndevice pointer or host pointer to scalar alpha.\n@param[in]\nx         device pointer storing vector x.\n@param[in]\nincx      [int]\nspecifies the increment for the elements of x.\n@param[in]\ny         device pointer storing vector y.\n@param[in]\nincy      [int]\nspecifies the increment for the elements of y.\n@param[inout]\nAP        device pointer storing the packed version of the specified triangular portion of\nthe symmetric matrix A. Of at least size ((n * (n + 1)) / 2).\nif uplo == HIPBLAS_FILL_MODE_UPPER:\nThe upper triangular portion of the symmetric matrix A is supplied.\nThe matrix is compacted so that AP contains the triangular portion column-by-column\nso that:\nAP(0) = A(0,0)\nAP(1) = A(0,1)\nAP(2) = A(1,1), etc.\nEx: (HIPBLAS_FILL_MODE_UPPER; n = 4)\n1 2 4 7\n2 3 5 8   -----> [1, 2, 3, 4, 5, 6, 7, 8, 9, 0]\n4 5 6 9\n7 8 9 0\nif uplo == HIPBLAS_FILL_MODE_LOWER:\nThe lower triangular portion of the symmetric matrix A is supplied.\nThe matrix is compacted so that AP contains the triangular portion column-by-column\nso that:\nAP(0) = A(0,0)\nAP(1) = A(1,0)\nAP(n) = A(2,1), etc.\nEx: (HIPBLAS_FILL_MODE_LOWER; n = 4)\n1 2 3 4\n2 5 6 7    -----> [1, 2, 3, 4, 5, 6, 7, 8, 9, 0]\n3 6 8 9\n4 7 9 0"]
    pub fn hipblasSspr2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::std::os::raw::c_int,
        alpha: *const f32,
        x: *const f32,
        incx: ::std::os::raw::c_int,
        y: *const f32,
        incy: ::std::os::raw::c_int,
        AP: *mut f32,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDspr2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::std::os::raw::c_int,
        alpha: *const f64,
        x: *const f64,
        incx: ::std::os::raw::c_int,
        y: *const f64,
        incy: ::std::os::raw::c_int,
        AP: *mut f64,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 2 API\n\n\\details\nspr2Batched performs the matrix-vector operation\n\nA_i := A_i + alpha*x_i*y_i**T + alpha*y_i*x_i**T\n\nwhere alpha is a scalar, x_i and y_i are vectors, and A_i is an\nn by n symmetric matrix, supplied in packed form, for i = 1, ..., batchCount.\n\n- Supported precisions in rocBLAS : s,d\n- Supported precisions in cuBLAS  : No support\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n@param[in]\nuplo      [hipblasFillMode_t]\nspecifies whether the upper 'HIPBLAS_FILL_MODE_UPPER' or lower 'HIPBLAS_FILL_MODE_LOWER'\nHIPBLAS_FILL_MODE_UPPER: The upper triangular part of each A_i is supplied in AP.\nHIPBLAS_FILL_MODE_LOWER: The lower triangular part of each A_i is supplied in AP.\n@param[in]\nn         [int]\nthe number of rows and columns of each matrix A_i, must be at least 0.\n@param[in]\nalpha\ndevice pointer or host pointer to scalar alpha.\n@param[in]\nx         device array of device pointers storing each vector x_i.\n@param[in]\nincx      [int]\nspecifies the increment for the elements of each x_i.\n@param[in]\ny         device array of device pointers storing each vector y_i.\n@param[in]\nincy      [int]\nspecifies the increment for the elements of each y_i.\n@param[inout]\nAP        device array of device pointers storing the packed version of the specified triangular portion of\neach symmetric matrix A_i of at least size ((n * (n + 1)) / 2). Array is of at least size batchCount.\nif uplo == HIPBLAS_FILL_MODE_UPPER:\nThe upper triangular portion of each symmetric matrix A_i is supplied.\nThe matrix is compacted so that AP contains the triangular portion column-by-column\nso that:\nAP(0) = A(0,0)\nAP(1) = A(0,1)\nAP(2) = A(1,1), etc.\nEx: (HIPBLAS_FILL_MODE_UPPER; n = 4)\n1 2 4 7\n2 3 5 8   -----> [1, 2, 3, 4, 5, 6, 7, 8, 9, 0]\n4 5 6 9\n7 8 9 0\nif uplo == HIPBLAS_FILL_MODE_LOWER:\nThe lower triangular portion of each symmetric matrix A_i is supplied.\nThe matrix is compacted so that AP contains the triangular portion column-by-column\nso that:\nAP(0) = A(0,0)\nAP(1) = A(1,0)\nAP(n) = A(2,1), etc.\nEx: (HIPBLAS_FILL_MODE_LOWER; n = 4)\n1 2 3 4\n2 5 6 7    -----> [1, 2, 3, 4, 5, 6, 7, 8, 9, 0]\n3 6 8 9\n4 7 9 0\n@param[in]\nbatchCount [int]\nnumber of instances in the batch."]
    pub fn hipblasSspr2Batched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::std::os::raw::c_int,
        alpha: *const f32,
        x: *const *const f32,
        incx: ::std::os::raw::c_int,
        y: *const *const f32,
        incy: ::std::os::raw::c_int,
        AP: *const *mut f32,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDspr2Batched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::std::os::raw::c_int,
        alpha: *const f64,
        x: *const *const f64,
        incx: ::std::os::raw::c_int,
        y: *const *const f64,
        incy: ::std::os::raw::c_int,
        AP: *const *mut f64,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 2 API\n\n\\details\nspr2StridedBatched performs the matrix-vector operation\n\nA_i := A_i + alpha*x_i*y_i**T + alpha*y_i*x_i**T\n\nwhere alpha is a scalar, x_i amd y_i are vectors, and A_i is an\nn by n symmetric matrix, supplied in packed form, for i = 1, ..., batchCount.\n\n- Supported precisions in rocBLAS : s,d\n- Supported precisions in cuBLAS  : No support\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n@param[in]\nuplo      [hipblasFillMode_t]\nspecifies whether the upper 'HIPBLAS_FILL_MODE_UPPER' or lower 'HIPBLAS_FILL_MODE_LOWER'\nHIPBLAS_FILL_MODE_UPPER: The upper triangular part of each A_i is supplied in AP.\nHIPBLAS_FILL_MODE_LOWER: The lower triangular part of each A_i is supplied in AP.\n@param[in]\nn         [int]\nthe number of rows and columns of each matrix A_i, must be at least 0.\n@param[in]\nalpha\ndevice pointer or host pointer to scalar alpha.\n@param[in]\nx         device pointer pointing to the first vector (x_1).\n@param[in]\nincx      [int]\nspecifies the increment for the elements of each x_i.\n@param[in]\nstridex  [hipblasStride]\nstride from the start of one vector (x_i) and the next one (x_i+1).\n@param[in]\ny         device pointer pointing to the first vector (y_1).\n@param[in]\nincy      [int]\nspecifies the increment for the elements of each y_i.\n@param[in]\nstridey  [hipblasStride]\nstride from the start of one vector (y_i) and the next one (y_i+1).\n@param[inout]\nAP        device pointer storing the packed version of the specified triangular portion of\neach symmetric matrix A_i. Points to the first A_1.\nif uplo == HIPBLAS_FILL_MODE_UPPER:\nThe upper triangular portion of each symmetric matrix A_i is supplied.\nThe matrix is compacted so that AP contains the triangular portion column-by-column\nso that:\nAP(0) = A(0,0)\nAP(1) = A(0,1)\nAP(2) = A(1,1), etc.\nEx: (HIPBLAS_FILL_MODE_UPPER; n = 4)\n1 2 4 7\n2 3 5 8   -----> [1, 2, 3, 4, 5, 6, 7, 8, 9, 0]\n4 5 6 9\n7 8 9 0\nif uplo == HIPBLAS_FILL_MODE_LOWER:\nThe lower triangular portion of each symmetric matrix A_i is supplied.\nThe matrix is compacted so that AP contains the triangular portion column-by-column\nso that:\nAP(0) = A(0,0)\nAP(1) = A(1,0)\nAP(n) = A(2,1), etc.\nEx: (HIPBLAS_FILL_MODE_LOWER; n = 4)\n1 2 3 4\n2 5 6 7    -----> [1, 2, 3, 4, 5, 6, 7, 8, 9, 0]\n3 6 8 9\n4 7 9 0\n@param[in]\nstrideA   [hipblasStride]\nstride from the start of one (A_i) and the next (A_i+1)\n@param[in]\nbatchCount [int]\nnumber of instances in the batch."]
    pub fn hipblasSspr2StridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::std::os::raw::c_int,
        alpha: *const f32,
        x: *const f32,
        incx: ::std::os::raw::c_int,
        stridex: hipblasStride,
        y: *const f32,
        incy: ::std::os::raw::c_int,
        stridey: hipblasStride,
        AP: *mut f32,
        strideA: hipblasStride,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDspr2StridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::std::os::raw::c_int,
        alpha: *const f64,
        x: *const f64,
        incx: ::std::os::raw::c_int,
        stridex: hipblasStride,
        y: *const f64,
        incy: ::std::os::raw::c_int,
        stridey: hipblasStride,
        AP: *mut f64,
        strideA: hipblasStride,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 2 API\n\n\\details\nsymv performs the matrix-vector operation:\n\ny := alpha*A*x + beta*y,\n\nwhere alpha and beta are scalars, x and y are n element vectors and\nA should contain an upper or lower triangular n by n symmetric matrix.\n\n- Supported precisions in rocBLAS : s,d,c,z\n- Supported precisions in cuBLAS  : s,d,c,z\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n@param[in]\nuplo      [hipblasFillMode_t]\nspecifies whether the upper 'HIPBLAS_FILL_MODE_UPPER' or lower 'HIPBLAS_FILL_MODE_LOWER'\nif HIPBLAS_FILL_MODE_UPPER, the lower part of A is not referenced\nif HIPBLAS_FILL_MODE_LOWER, the upper part of A is not referenced\n@param[in]\nn         [int]\n@param[in]\nalpha\nspecifies the scalar alpha\n@param[in]\nAP         pointer storing matrix A on the GPU\n@param[in]\nlda       [int]\nspecifies the leading dimension of A\n@param[in]\nx         pointer storing vector x on the GPU\n@param[in]\nincx      [int]\nspecifies the increment for the elements of x\n@param[in]\nbeta      specifies the scalar beta\n@param[out]\ny         pointer storing vector y on the GPU\n@param[in]\nincy      [int]\nspecifies the increment for the elements of y\n"]
    pub fn hipblasSsymv(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::std::os::raw::c_int,
        alpha: *const f32,
        AP: *const f32,
        lda: ::std::os::raw::c_int,
        x: *const f32,
        incx: ::std::os::raw::c_int,
        beta: *const f32,
        y: *mut f32,
        incy: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDsymv(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::std::os::raw::c_int,
        alpha: *const f64,
        AP: *const f64,
        lda: ::std::os::raw::c_int,
        x: *const f64,
        incx: ::std::os::raw::c_int,
        beta: *const f64,
        y: *mut f64,
        incy: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsymv(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::std::os::raw::c_int,
        alpha: *const hipblasComplex,
        AP: *const hipblasComplex,
        lda: ::std::os::raw::c_int,
        x: *const hipblasComplex,
        incx: ::std::os::raw::c_int,
        beta: *const hipblasComplex,
        y: *mut hipblasComplex,
        incy: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZsymv(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::std::os::raw::c_int,
        alpha: *const hipblasDoubleComplex,
        AP: *const hipblasDoubleComplex,
        lda: ::std::os::raw::c_int,
        x: *const hipblasDoubleComplex,
        incx: ::std::os::raw::c_int,
        beta: *const hipblasDoubleComplex,
        y: *mut hipblasDoubleComplex,
        incy: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsymv_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::std::os::raw::c_int,
        alpha: *const hipComplex,
        AP: *const hipComplex,
        lda: ::std::os::raw::c_int,
        x: *const hipComplex,
        incx: ::std::os::raw::c_int,
        beta: *const hipComplex,
        y: *mut hipComplex,
        incy: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZsymv_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::std::os::raw::c_int,
        alpha: *const hipDoubleComplex,
        AP: *const hipDoubleComplex,
        lda: ::std::os::raw::c_int,
        x: *const hipDoubleComplex,
        incx: ::std::os::raw::c_int,
        beta: *const hipDoubleComplex,
        y: *mut hipDoubleComplex,
        incy: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 2 API\n\n\\details\nsymvBatched performs the matrix-vector operation:\n\ny_i := alpha*A_i*x_i + beta*y_i,\n\nwhere (A_i, x_i, y_i) is the i-th instance of the batch.\nalpha and beta are scalars, x_i and y_i are vectors and A_i is an\nn by n symmetric matrix, for i = 1, ..., batchCount.\nA a should contain an upper or lower triangular symmetric matrix\nand the opposing triangular part of A is not referenced\n\n- Supported precisions in rocBLAS : s,d,c,z\n- Supported precisions in cuBLAS  : No support\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue\n@param[in]\nuplo      [hipblasFillMode_t]\nspecifies whether the upper 'HIPBLAS_FILL_MODE_UPPER' or lower 'HIPBLAS_FILL_MODE_LOWER'\nif HIPBLAS_FILL_MODE_UPPER, the lower part of A is not referenced\nif HIPBLAS_FILL_MODE_LOWER, the upper part of A is not referenced\n@param[in]\nn         [int]\nnumber of rows and columns of each matrix A_i\n@param[in]\nalpha\ndevice pointer or host pointer to scalar alpha\n@param[in]\nAP        device array of device pointers storing each matrix A_i\n@param[in]\nlda       [int]\nspecifies the leading dimension of each matrix A_i\n@param[in]\nx         device array of device pointers storing each vector x_i\n@param[in]\nincx      [int]\nspecifies the increment for the elements of each vector x_i\n@param[in]\nbeta      device pointer or host pointer to scalar beta\n@param[out]\ny         device array of device pointers storing each vector y_i\n@param[in]\nincy      [int]\nspecifies the increment for the elements of each vector y_i\n@param[in]\nbatchCount [int]\nnumber of instances in the batch\n"]
    pub fn hipblasSsymvBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::std::os::raw::c_int,
        alpha: *const f32,
        AP: *const *const f32,
        lda: ::std::os::raw::c_int,
        x: *const *const f32,
        incx: ::std::os::raw::c_int,
        beta: *const f32,
        y: *const *mut f32,
        incy: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDsymvBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::std::os::raw::c_int,
        alpha: *const f64,
        AP: *const *const f64,
        lda: ::std::os::raw::c_int,
        x: *const *const f64,
        incx: ::std::os::raw::c_int,
        beta: *const f64,
        y: *const *mut f64,
        incy: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsymvBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::std::os::raw::c_int,
        alpha: *const hipblasComplex,
        AP: *const *const hipblasComplex,
        lda: ::std::os::raw::c_int,
        x: *const *const hipblasComplex,
        incx: ::std::os::raw::c_int,
        beta: *const hipblasComplex,
        y: *const *mut hipblasComplex,
        incy: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZsymvBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::std::os::raw::c_int,
        alpha: *const hipblasDoubleComplex,
        AP: *const *const hipblasDoubleComplex,
        lda: ::std::os::raw::c_int,
        x: *const *const hipblasDoubleComplex,
        incx: ::std::os::raw::c_int,
        beta: *const hipblasDoubleComplex,
        y: *const *mut hipblasDoubleComplex,
        incy: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsymvBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::std::os::raw::c_int,
        alpha: *const hipComplex,
        AP: *const *const hipComplex,
        lda: ::std::os::raw::c_int,
        x: *const *const hipComplex,
        incx: ::std::os::raw::c_int,
        beta: *const hipComplex,
        y: *const *mut hipComplex,
        incy: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZsymvBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::std::os::raw::c_int,
        alpha: *const hipDoubleComplex,
        AP: *const *const hipDoubleComplex,
        lda: ::std::os::raw::c_int,
        x: *const *const hipDoubleComplex,
        incx: ::std::os::raw::c_int,
        beta: *const hipDoubleComplex,
        y: *const *mut hipDoubleComplex,
        incy: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 2 API\n\n\\details\nsymvStridedBatched performs the matrix-vector operation:\n\ny_i := alpha*A_i*x_i + beta*y_i,\n\nwhere (A_i, x_i, y_i) is the i-th instance of the batch.\nalpha and beta are scalars, x_i and y_i are vectors and A_i is an\nn by n symmetric matrix, for i = 1, ..., batchCount.\nA a should contain an upper or lower triangular symmetric matrix\nand the opposing triangular part of A is not referenced\n\n- Supported precisions in rocBLAS : s,d,c,z\n- Supported precisions in cuBLAS  : No support\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue\n@param[in]\nuplo      [hipblasFillMode_t]\nspecifies whether the upper 'HIPBLAS_FILL_MODE_UPPER' or lower 'HIPBLAS_FILL_MODE_LOWER'\nif HIPBLAS_FILL_MODE_UPPER, the lower part of A is not referenced\nif HIPBLAS_FILL_MODE_LOWER, the upper part of A is not referenced\n@param[in]\nn         [int]\nnumber of rows and columns of each matrix A_i\n@param[in]\nalpha\ndevice pointer or host pointer to scalar alpha\n@param[in]\nAP         Device pointer to the first matrix A_1 on the GPU\n@param[in]\nlda       [int]\nspecifies the leading dimension of each matrix A_i\n@param[in]\nstrideA     [hipblasStride]\nstride from the start of one matrix (A_i) and the next one (A_i+1)\n@param[in]\nx         Device pointer to the first vector x_1 on the GPU\n@param[in]\nincx      [int]\nspecifies the increment for the elements of each vector x_i\n@param[in]\nstridex     [hipblasStride]\nstride from the start of one vector (x_i) and the next one (x_i+1).\nThere are no restrictions placed on stridex, however the user should\ntake care to ensure that stridex is of appropriate size.\nThis typically means stridex >= n * incx. stridex should be non zero.\n@param[in]\nbeta      device pointer or host pointer to scalar beta\n@param[out]\ny         Device pointer to the first vector y_1 on the GPU\n@param[in]\nincy      [int]\nspecifies the increment for the elements of each vector y_i\n@param[in]\nstridey     [hipblasStride]\nstride from the start of one vector (y_i) and the next one (y_i+1).\nThere are no restrictions placed on stridey, however the user should\ntake care to ensure that stridey is of appropriate size.\nThis typically means stridey >= n * incy. stridey should be non zero.\n@param[in]\nbatchCount [int]\nnumber of instances in the batch\n"]
    pub fn hipblasSsymvStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::std::os::raw::c_int,
        alpha: *const f32,
        AP: *const f32,
        lda: ::std::os::raw::c_int,
        strideA: hipblasStride,
        x: *const f32,
        incx: ::std::os::raw::c_int,
        stridex: hipblasStride,
        beta: *const f32,
        y: *mut f32,
        incy: ::std::os::raw::c_int,
        stridey: hipblasStride,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDsymvStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::std::os::raw::c_int,
        alpha: *const f64,
        AP: *const f64,
        lda: ::std::os::raw::c_int,
        strideA: hipblasStride,
        x: *const f64,
        incx: ::std::os::raw::c_int,
        stridex: hipblasStride,
        beta: *const f64,
        y: *mut f64,
        incy: ::std::os::raw::c_int,
        stridey: hipblasStride,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsymvStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::std::os::raw::c_int,
        alpha: *const hipblasComplex,
        AP: *const hipblasComplex,
        lda: ::std::os::raw::c_int,
        strideA: hipblasStride,
        x: *const hipblasComplex,
        incx: ::std::os::raw::c_int,
        stridex: hipblasStride,
        beta: *const hipblasComplex,
        y: *mut hipblasComplex,
        incy: ::std::os::raw::c_int,
        stridey: hipblasStride,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZsymvStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::std::os::raw::c_int,
        alpha: *const hipblasDoubleComplex,
        AP: *const hipblasDoubleComplex,
        lda: ::std::os::raw::c_int,
        strideA: hipblasStride,
        x: *const hipblasDoubleComplex,
        incx: ::std::os::raw::c_int,
        stridex: hipblasStride,
        beta: *const hipblasDoubleComplex,
        y: *mut hipblasDoubleComplex,
        incy: ::std::os::raw::c_int,
        stridey: hipblasStride,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsymvStridedBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::std::os::raw::c_int,
        alpha: *const hipComplex,
        AP: *const hipComplex,
        lda: ::std::os::raw::c_int,
        strideA: hipblasStride,
        x: *const hipComplex,
        incx: ::std::os::raw::c_int,
        stridex: hipblasStride,
        beta: *const hipComplex,
        y: *mut hipComplex,
        incy: ::std::os::raw::c_int,
        stridey: hipblasStride,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZsymvStridedBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::std::os::raw::c_int,
        alpha: *const hipDoubleComplex,
        AP: *const hipDoubleComplex,
        lda: ::std::os::raw::c_int,
        strideA: hipblasStride,
        x: *const hipDoubleComplex,
        incx: ::std::os::raw::c_int,
        stridex: hipblasStride,
        beta: *const hipDoubleComplex,
        y: *mut hipDoubleComplex,
        incy: ::std::os::raw::c_int,
        stridey: hipblasStride,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 2 API\n\n\\details\nsyr performs the matrix-vector operations\n\nA := A + alpha*x*x**T\n\nwhere alpha is a scalar, x is a vector, and A is an\nn by n symmetric matrix.\n\n- Supported precisions in rocBLAS : s,d,c,z\n- Supported precisions in cuBLAS  : s,d,c,z\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n@param[in]\nuplo      [hipblasFillMode_t]\nspecifies whether the upper 'HIPBLAS_FILL_MODE_UPPER' or lower 'HIPBLAS_FILL_MODE_LOWER'\nif HIPBLAS_FILL_MODE_UPPER, the lower part of A is not referenced\nif HIPBLAS_FILL_MODE_LOWER, the upper part of A is not referenced\n\n@param[in]\nn         [int]\nthe number of rows and columns of matrix A.\n@param[in]\nalpha\ndevice pointer or host pointer to scalar alpha.\n@param[in]\nx         device pointer storing vector x.\n@param[in]\nincx      [int]\nspecifies the increment for the elements of x.\n@param[inout]\nAP         device pointer storing matrix A.\n@param[in]\nlda       [int]\nspecifies the leading dimension of A.\n"]
    pub fn hipblasSsyr(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::std::os::raw::c_int,
        alpha: *const f32,
        x: *const f32,
        incx: ::std::os::raw::c_int,
        AP: *mut f32,
        lda: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDsyr(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::std::os::raw::c_int,
        alpha: *const f64,
        x: *const f64,
        incx: ::std::os::raw::c_int,
        AP: *mut f64,
        lda: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsyr(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::std::os::raw::c_int,
        alpha: *const hipblasComplex,
        x: *const hipblasComplex,
        incx: ::std::os::raw::c_int,
        AP: *mut hipblasComplex,
        lda: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZsyr(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::std::os::raw::c_int,
        alpha: *const hipblasDoubleComplex,
        x: *const hipblasDoubleComplex,
        incx: ::std::os::raw::c_int,
        AP: *mut hipblasDoubleComplex,
        lda: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsyr_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::std::os::raw::c_int,
        alpha: *const hipComplex,
        x: *const hipComplex,
        incx: ::std::os::raw::c_int,
        AP: *mut hipComplex,
        lda: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZsyr_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::std::os::raw::c_int,
        alpha: *const hipDoubleComplex,
        x: *const hipDoubleComplex,
        incx: ::std::os::raw::c_int,
        AP: *mut hipDoubleComplex,
        lda: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 2 API\n\n\\details\nsyrBatched performs a batch of matrix-vector operations\n\nA[i] := A[i] + alpha*x[i]*x[i]**T\n\nwhere alpha is a scalar, x is an array of vectors, and A is an array of\nn by n symmetric matrices, for i = 1 , ... , batchCount.\n\n- Supported precisions in rocBLAS : s,d,c,z\n- Supported precisions in cuBLAS  : No support\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n@param[in]\nuplo      [hipblasFillMode_t]\nspecifies whether the upper 'HIPBLAS_FILL_MODE_UPPER' or lower 'HIPBLAS_FILL_MODE_LOWER'\nif HIPBLAS_FILL_MODE_UPPER, the lower part of A is not referenced\nif HIPBLAS_FILL_MODE_LOWER, the upper part of A is not referenced\n@param[in]\nn         [int]\nthe number of rows and columns of matrix A.\n@param[in]\nalpha\ndevice pointer or host pointer to scalar alpha.\n@param[in]\nx         device array of device pointers storing each vector x_i.\n@param[in]\nincx      [int]\nspecifies the increment for the elements of each x_i.\n@param[inout]\nAP         device array of device pointers storing each matrix A_i.\n@param[in]\nlda       [int]\nspecifies the leading dimension of each A_i.\n@param[in]\nbatchCount [int]\nnumber of instances in the batch\n"]
    pub fn hipblasSsyrBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::std::os::raw::c_int,
        alpha: *const f32,
        x: *const *const f32,
        incx: ::std::os::raw::c_int,
        AP: *const *mut f32,
        lda: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDsyrBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::std::os::raw::c_int,
        alpha: *const f64,
        x: *const *const f64,
        incx: ::std::os::raw::c_int,
        AP: *const *mut f64,
        lda: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsyrBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::std::os::raw::c_int,
        alpha: *const hipblasComplex,
        x: *const *const hipblasComplex,
        incx: ::std::os::raw::c_int,
        AP: *const *mut hipblasComplex,
        lda: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZsyrBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::std::os::raw::c_int,
        alpha: *const hipblasDoubleComplex,
        x: *const *const hipblasDoubleComplex,
        incx: ::std::os::raw::c_int,
        AP: *const *mut hipblasDoubleComplex,
        lda: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsyrBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::std::os::raw::c_int,
        alpha: *const hipComplex,
        x: *const *const hipComplex,
        incx: ::std::os::raw::c_int,
        AP: *const *mut hipComplex,
        lda: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZsyrBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::std::os::raw::c_int,
        alpha: *const hipDoubleComplex,
        x: *const *const hipDoubleComplex,
        incx: ::std::os::raw::c_int,
        AP: *const *mut hipDoubleComplex,
        lda: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 2 API\n\n\\details\nsyrStridedBatched performs the matrix-vector operations\n\nA[i] := A[i] + alpha*x[i]*x[i]**T\n\nwhere alpha is a scalar, vectors, and A is an array of\nn by n symmetric matrices, for i = 1 , ... , batchCount.\n\n- Supported precisions in rocBLAS : s,d,c,z\n- Supported precisions in cuBLAS  : No support\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n@param[in]\nuplo      [hipblasFillMode_t]\nspecifies whether the upper 'HIPBLAS_FILL_MODE_UPPER' or lower 'HIPBLAS_FILL_MODE_LOWER'\nif HIPBLAS_FILL_MODE_UPPER, the lower part of A is not referenced\nif HIPBLAS_FILL_MODE_LOWER, the upper part of A is not referenced\n@param[in]\nn         [int]\nthe number of rows and columns of each matrix A.\n@param[in]\nalpha\ndevice pointer or host pointer to scalar alpha.\n@param[in]\nx         device pointer to the first vector x_1.\n@param[in]\nincx      [int]\nspecifies the increment for the elements of each x_i.\n@param[in]\nstridex   [hipblasStride]\nspecifies the pointer increment between vectors (x_i) and (x_i+1).\n@param[inout]\nAP         device pointer to the first matrix A_1.\n@param[in]\nlda       [int]\nspecifies the leading dimension of each A_i.\n@param[in]\nstrideA   [hipblasStride]\nstride from the start of one matrix (A_i) and the next one (A_i+1)\n@param[in]\nbatchCount [int]\nnumber of instances in the batch\n"]
    pub fn hipblasSsyrStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::std::os::raw::c_int,
        alpha: *const f32,
        x: *const f32,
        incx: ::std::os::raw::c_int,
        stridex: hipblasStride,
        AP: *mut f32,
        lda: ::std::os::raw::c_int,
        strideA: hipblasStride,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDsyrStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::std::os::raw::c_int,
        alpha: *const f64,
        x: *const f64,
        incx: ::std::os::raw::c_int,
        stridex: hipblasStride,
        AP: *mut f64,
        lda: ::std::os::raw::c_int,
        strideA: hipblasStride,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsyrStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::std::os::raw::c_int,
        alpha: *const hipblasComplex,
        x: *const hipblasComplex,
        incx: ::std::os::raw::c_int,
        stridex: hipblasStride,
        AP: *mut hipblasComplex,
        lda: ::std::os::raw::c_int,
        strideA: hipblasStride,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZsyrStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::std::os::raw::c_int,
        alpha: *const hipblasDoubleComplex,
        x: *const hipblasDoubleComplex,
        incx: ::std::os::raw::c_int,
        stridex: hipblasStride,
        AP: *mut hipblasDoubleComplex,
        lda: ::std::os::raw::c_int,
        strideA: hipblasStride,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsyrStridedBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::std::os::raw::c_int,
        alpha: *const hipComplex,
        x: *const hipComplex,
        incx: ::std::os::raw::c_int,
        stridex: hipblasStride,
        AP: *mut hipComplex,
        lda: ::std::os::raw::c_int,
        strideA: hipblasStride,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZsyrStridedBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::std::os::raw::c_int,
        alpha: *const hipDoubleComplex,
        x: *const hipDoubleComplex,
        incx: ::std::os::raw::c_int,
        stridex: hipblasStride,
        AP: *mut hipDoubleComplex,
        lda: ::std::os::raw::c_int,
        strideA: hipblasStride,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 2 API\n\n\\details\nsyr2 performs the matrix-vector operations\n\nA := A + alpha*x*y**T + alpha*y*x**T\n\nwhere alpha is a scalar, x and y are vectors, and A is an\nn by n symmetric matrix.\n\n- Supported precisions in rocBLAS : s,d,c,z\n- Supported precisions in cuBLAS  : No support\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n@param[in]\nuplo      [hipblasFillMode_t]\nspecifies whether the upper 'HIPBLAS_FILL_MODE_UPPER' or lower 'HIPBLAS_FILL_MODE_LOWER'\nif HIPBLAS_FILL_MODE_UPPER, the lower part of A is not referenced\nif HIPBLAS_FILL_MODE_LOWER, the upper part of A is not referenced\n\n@param[in]\nn         [int]\nthe number of rows and columns of matrix A.\n@param[in]\nalpha\ndevice pointer or host pointer to scalar alpha.\n@param[in]\nx         device pointer storing vector x.\n@param[in]\nincx      [int]\nspecifies the increment for the elements of x.\n@param[in]\ny         device pointer storing vector y.\n@param[in]\nincy      [int]\nspecifies the increment for the elements of y.\n@param[inout]\nAP         device pointer storing matrix A.\n@param[in]\nlda       [int]\nspecifies the leading dimension of A.\n"]
    pub fn hipblasSsyr2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::std::os::raw::c_int,
        alpha: *const f32,
        x: *const f32,
        incx: ::std::os::raw::c_int,
        y: *const f32,
        incy: ::std::os::raw::c_int,
        AP: *mut f32,
        lda: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDsyr2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::std::os::raw::c_int,
        alpha: *const f64,
        x: *const f64,
        incx: ::std::os::raw::c_int,
        y: *const f64,
        incy: ::std::os::raw::c_int,
        AP: *mut f64,
        lda: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsyr2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::std::os::raw::c_int,
        alpha: *const hipblasComplex,
        x: *const hipblasComplex,
        incx: ::std::os::raw::c_int,
        y: *const hipblasComplex,
        incy: ::std::os::raw::c_int,
        AP: *mut hipblasComplex,
        lda: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZsyr2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::std::os::raw::c_int,
        alpha: *const hipblasDoubleComplex,
        x: *const hipblasDoubleComplex,
        incx: ::std::os::raw::c_int,
        y: *const hipblasDoubleComplex,
        incy: ::std::os::raw::c_int,
        AP: *mut hipblasDoubleComplex,
        lda: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsyr2_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::std::os::raw::c_int,
        alpha: *const hipComplex,
        x: *const hipComplex,
        incx: ::std::os::raw::c_int,
        y: *const hipComplex,
        incy: ::std::os::raw::c_int,
        AP: *mut hipComplex,
        lda: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZsyr2_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::std::os::raw::c_int,
        alpha: *const hipDoubleComplex,
        x: *const hipDoubleComplex,
        incx: ::std::os::raw::c_int,
        y: *const hipDoubleComplex,
        incy: ::std::os::raw::c_int,
        AP: *mut hipDoubleComplex,
        lda: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 2 API\n\n\\details\nsyr2Batched performs a batch of matrix-vector operations\n\nA[i] := A[i] + alpha*x[i]*y[i]**T + alpha*y[i]*x[i]**T\n\nwhere alpha is a scalar, x[i] and y[i] are vectors, and A[i] is a\nn by n symmetric matrix, for i = 1 , ... , batchCount.\n\n- Supported precisions in rocBLAS : s,d,c,z\n- Supported precisions in cuBLAS  : No support\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n@param[in]\nuplo      [hipblasFillMode_t]\nspecifies whether the upper 'HIPBLAS_FILL_MODE_UPPER' or lower 'HIPBLAS_FILL_MODE_LOWER'\nif HIPBLAS_FILL_MODE_UPPER, the lower part of A is not referenced\nif HIPBLAS_FILL_MODE_LOWER, the upper part of A is not referenced\n@param[in]\nn         [int]\nthe number of rows and columns of matrix A.\n@param[in]\nalpha\ndevice pointer or host pointer to scalar alpha.\n@param[in]\nx         device array of device pointers storing each vector x_i.\n@param[in]\nincx      [int]\nspecifies the increment for the elements of each x_i.\n@param[in]\ny         device array of device pointers storing each vector y_i.\n@param[in]\nincy      [int]\nspecifies the increment for the elements of each y_i.\n@param[inout]\nAP         device array of device pointers storing each matrix A_i.\n@param[in]\nlda       [int]\nspecifies the leading dimension of each A_i.\n@param[in]\nbatchCount [int]\nnumber of instances in the batch\n"]
    pub fn hipblasSsyr2Batched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::std::os::raw::c_int,
        alpha: *const f32,
        x: *const *const f32,
        incx: ::std::os::raw::c_int,
        y: *const *const f32,
        incy: ::std::os::raw::c_int,
        AP: *const *mut f32,
        lda: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDsyr2Batched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::std::os::raw::c_int,
        alpha: *const f64,
        x: *const *const f64,
        incx: ::std::os::raw::c_int,
        y: *const *const f64,
        incy: ::std::os::raw::c_int,
        AP: *const *mut f64,
        lda: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsyr2Batched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::std::os::raw::c_int,
        alpha: *const hipblasComplex,
        x: *const *const hipblasComplex,
        incx: ::std::os::raw::c_int,
        y: *const *const hipblasComplex,
        incy: ::std::os::raw::c_int,
        AP: *const *mut hipblasComplex,
        lda: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZsyr2Batched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::std::os::raw::c_int,
        alpha: *const hipblasDoubleComplex,
        x: *const *const hipblasDoubleComplex,
        incx: ::std::os::raw::c_int,
        y: *const *const hipblasDoubleComplex,
        incy: ::std::os::raw::c_int,
        AP: *const *mut hipblasDoubleComplex,
        lda: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsyr2Batched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::std::os::raw::c_int,
        alpha: *const hipComplex,
        x: *const *const hipComplex,
        incx: ::std::os::raw::c_int,
        y: *const *const hipComplex,
        incy: ::std::os::raw::c_int,
        AP: *const *mut hipComplex,
        lda: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZsyr2Batched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::std::os::raw::c_int,
        alpha: *const hipDoubleComplex,
        x: *const *const hipDoubleComplex,
        incx: ::std::os::raw::c_int,
        y: *const *const hipDoubleComplex,
        incy: ::std::os::raw::c_int,
        AP: *const *mut hipDoubleComplex,
        lda: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 2 API\n\n\\details\nsyr2StridedBatched the matrix-vector operations\n\nA[i] := A[i] + alpha*x[i]*y[i]**T + alpha*y[i]*x[i]**T\n\nwhere alpha is a scalar, x[i] and y[i] are vectors, and A[i] is a\nn by n symmetric matrices, for i = 1 , ... , batchCount.\n\n- Supported precisions in rocBLAS : s,d,c,z\n- Supported precisions in cuBLAS  : No support\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n@param[in]\nuplo      [hipblasFillMode_t]\nspecifies whether the upper 'HIPBLAS_FILL_MODE_UPPER' or lower 'HIPBLAS_FILL_MODE_LOWER'\nif HIPBLAS_FILL_MODE_UPPER, the lower part of A is not referenced\nif HIPBLAS_FILL_MODE_LOWER, the upper part of A is not referenced\n@param[in]\nn         [int]\nthe number of rows and columns of each matrix A.\n@param[in]\nalpha\ndevice pointer or host pointer to scalar alpha.\n@param[in]\nx         device pointer to the first vector x_1.\n@param[in]\nincx      [int]\nspecifies the increment for the elements of each x_i.\n@param[in]\nstridex   [hipblasStride]\nspecifies the pointer increment between vectors (x_i) and (x_i+1).\n@param[in]\ny         device pointer to the first vector y_1.\n@param[in]\nincy      [int]\nspecifies the increment for the elements of each y_i.\n@param[in]\nstridey   [hipblasStride]\nspecifies the pointer increment between vectors (y_i) and (y_i+1).\n@param[inout]\nAP         device pointer to the first matrix A_1.\n@param[in]\nlda       [int]\nspecifies the leading dimension of each A_i.\n@param[in]\nstrideA   [hipblasStride]\nstride from the start of one matrix (A_i) and the next one (A_i+1)\n@param[in]\nbatchCount [int]\nnumber of instances in the batch\n"]
    pub fn hipblasSsyr2StridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::std::os::raw::c_int,
        alpha: *const f32,
        x: *const f32,
        incx: ::std::os::raw::c_int,
        stridex: hipblasStride,
        y: *const f32,
        incy: ::std::os::raw::c_int,
        stridey: hipblasStride,
        AP: *mut f32,
        lda: ::std::os::raw::c_int,
        strideA: hipblasStride,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDsyr2StridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::std::os::raw::c_int,
        alpha: *const f64,
        x: *const f64,
        incx: ::std::os::raw::c_int,
        stridex: hipblasStride,
        y: *const f64,
        incy: ::std::os::raw::c_int,
        stridey: hipblasStride,
        AP: *mut f64,
        lda: ::std::os::raw::c_int,
        strideA: hipblasStride,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsyr2StridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::std::os::raw::c_int,
        alpha: *const hipblasComplex,
        x: *const hipblasComplex,
        incx: ::std::os::raw::c_int,
        stridex: hipblasStride,
        y: *const hipblasComplex,
        incy: ::std::os::raw::c_int,
        stridey: hipblasStride,
        AP: *mut hipblasComplex,
        lda: ::std::os::raw::c_int,
        strideA: hipblasStride,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZsyr2StridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::std::os::raw::c_int,
        alpha: *const hipblasDoubleComplex,
        x: *const hipblasDoubleComplex,
        incx: ::std::os::raw::c_int,
        stridex: hipblasStride,
        y: *const hipblasDoubleComplex,
        incy: ::std::os::raw::c_int,
        stridey: hipblasStride,
        AP: *mut hipblasDoubleComplex,
        lda: ::std::os::raw::c_int,
        strideA: hipblasStride,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsyr2StridedBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::std::os::raw::c_int,
        alpha: *const hipComplex,
        x: *const hipComplex,
        incx: ::std::os::raw::c_int,
        stridex: hipblasStride,
        y: *const hipComplex,
        incy: ::std::os::raw::c_int,
        stridey: hipblasStride,
        AP: *mut hipComplex,
        lda: ::std::os::raw::c_int,
        strideA: hipblasStride,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZsyr2StridedBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::std::os::raw::c_int,
        alpha: *const hipDoubleComplex,
        x: *const hipDoubleComplex,
        incx: ::std::os::raw::c_int,
        stridex: hipblasStride,
        y: *const hipDoubleComplex,
        incy: ::std::os::raw::c_int,
        stridey: hipblasStride,
        AP: *mut hipDoubleComplex,
        lda: ::std::os::raw::c_int,
        strideA: hipblasStride,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 2 API\n\n\\details\ntbmv performs one of the matrix-vector operations\n\nx := A*x      or\nx := A**T*x   or\nx := A**H*x,\n\nx is a vectors and A is a banded m by m matrix (see description below).\n\n- Supported precisions in rocBLAS : s,d,c,z\n- Supported precisions in cuBLAS  : s,d,c,z\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n@param[in]\nuplo      [hipblasFillMode_t]\nHIPBLAS_FILL_MODE_UPPER: A is an upper banded triangular matrix.\nHIPBLAS_FILL_MODE_LOWER: A is a  lower banded triangular matrix.\n@param[in]\ntransA     [hipblasOperation_t]\nindicates whether matrix A is tranposed (conjugated) or not.\n@param[in]\ndiag      [hipblasDiagType_t]\nHIPBLAS_DIAG_UNIT: The main diagonal of A is assumed to consist of only\n1's and is not referenced.\nHIPBLAS_DIAG_NON_UNIT: No assumptions are made of A's main diagonal.\n@param[in]\nm         [int]\nthe number of rows and columns of the matrix represented by A.\n@param[in]\nk         [int]\nif uplo == HIPBLAS_FILL_MODE_UPPER, k specifies the number of super-diagonals\nof the matrix A.\nif uplo == HIPBLAS_FILL_MODE_LOWER, k specifies the number of sub-diagonals\nof the matrix A.\nk must satisfy k > 0 && k < lda.\n@param[in]\nAP         device pointer storing banded triangular matrix A.\nif uplo == HIPBLAS_FILL_MODE_UPPER:\nThe matrix represented is an upper banded triangular matrix\nwith the main diagonal and k super-diagonals, everything\nelse can be assumed to be 0.\nThe matrix is compacted so that the main diagonal resides on the k'th\nrow, the first super diagonal resides on the RHS of the k-1'th row, etc,\nwith the k'th diagonal on the RHS of the 0'th row.\nEx: (HIPBLAS_FILL_MODE_UPPER; m = 5; k = 2)\n1 6 9 0 0              0 0 9 8 7\n0 2 7 8 0              0 6 7 8 9\n0 0 3 8 7     ---->    1 2 3 4 5\n0 0 0 4 9              0 0 0 0 0\n0 0 0 0 5              0 0 0 0 0\nif uplo == HIPBLAS_FILL_MODE_LOWER:\nThe matrix represnted is a lower banded triangular matrix\nwith the main diagonal and k sub-diagonals, everything else can be\nassumed to be 0.\nThe matrix is compacted so that the main diagonal resides on the 0'th row,\nworking up to the k'th diagonal residing on the LHS of the k'th row.\nEx: (HIPBLAS_FILL_MODE_LOWER; m = 5; k = 2)\n1 0 0 0 0              1 2 3 4 5\n6 2 0 0 0              6 7 8 9 0\n9 7 3 0 0     ---->    9 8 7 0 0\n0 8 8 4 0              0 0 0 0 0\n0 0 7 9 5              0 0 0 0 0\n@param[in]\nlda       [int]\nspecifies the leading dimension of A. lda must satisfy lda > k.\n@param[inout]\nx         device pointer storing vector x.\n@param[in]\nincx      [int]\nspecifies the increment for the elements of x.\n"]
    pub fn hipblasStbmv(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        AP: *const f32,
        lda: ::std::os::raw::c_int,
        x: *mut f32,
        incx: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDtbmv(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        AP: *const f64,
        lda: ::std::os::raw::c_int,
        x: *mut f64,
        incx: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCtbmv(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        AP: *const hipblasComplex,
        lda: ::std::os::raw::c_int,
        x: *mut hipblasComplex,
        incx: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZtbmv(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        AP: *const hipblasDoubleComplex,
        lda: ::std::os::raw::c_int,
        x: *mut hipblasDoubleComplex,
        incx: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCtbmv_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        AP: *const hipComplex,
        lda: ::std::os::raw::c_int,
        x: *mut hipComplex,
        incx: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZtbmv_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        AP: *const hipDoubleComplex,
        lda: ::std::os::raw::c_int,
        x: *mut hipDoubleComplex,
        incx: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 2 API\n\n\\details\ntbmvBatched performs one of the matrix-vector operations\n\nx_i := A_i*x_i      or\nx_i := A_i**T*x_i   or\nx_i := A_i**H*x_i,\n\nwhere (A_i, x_i) is the i-th instance of the batch.\nx_i is a vector and A_i is an m by m matrix, for i = 1, ..., batchCount.\n\n- Supported precisions in rocBLAS : s,d,c,z\n- Supported precisions in cuBLAS  : No support\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n@param[in]\nuplo      [hipblasFillMode_t]\nHIPBLAS_FILL_MODE_UPPER: each A_i is an upper banded triangular matrix.\nHIPBLAS_FILL_MODE_LOWER: each A_i is a  lower banded triangular matrix.\n@param[in]\ntransA     [hipblasOperation_t]\nindicates whether each matrix A_i is tranposed (conjugated) or not.\n@param[in]\ndiag      [hipblasDiagType_t]\nHIPBLAS_DIAG_UNIT: The main diagonal of each A_i is assumed to consist of only\n1's and is not referenced.\nHIPBLAS_DIAG_NON_UNIT: No assumptions are made of each A_i's main diagonal.\n@param[in]\nm         [int]\nthe number of rows and columns of the matrix represented by each A_i.\n@param[in]\nk         [int]\nif uplo == HIPBLAS_FILL_MODE_UPPER, k specifies the number of super-diagonals\nof each matrix A_i.\nif uplo == HIPBLAS_FILL_MODE_LOWER, k specifies the number of sub-diagonals\nof each matrix A_i.\nk must satisfy k > 0 && k < lda.\n@param[in]\nAP         device array of device pointers storing each banded triangular matrix A_i.\nif uplo == HIPBLAS_FILL_MODE_UPPER:\nThe matrix represented is an upper banded triangular matrix\nwith the main diagonal and k super-diagonals, everything\nelse can be assumed to be 0.\nThe matrix is compacted so that the main diagonal resides on the k'th\nrow, the first super diagonal resides on the RHS of the k-1'th row, etc,\nwith the k'th diagonal on the RHS of the 0'th row.\nEx: (HIPBLAS_FILL_MODE_UPPER; m = 5; k = 2)\n1 6 9 0 0              0 0 9 8 7\n0 2 7 8 0              0 6 7 8 9\n0 0 3 8 7     ---->    1 2 3 4 5\n0 0 0 4 9              0 0 0 0 0\n0 0 0 0 5              0 0 0 0 0\nif uplo == HIPBLAS_FILL_MODE_LOWER:\nThe matrix represnted is a lower banded triangular matrix\nwith the main diagonal and k sub-diagonals, everything else can be\nassumed to be 0.\nThe matrix is compacted so that the main diagonal resides on the 0'th row,\nworking up to the k'th diagonal residing on the LHS of the k'th row.\nEx: (HIPBLAS_FILL_MODE_LOWER; m = 5; k = 2)\n1 0 0 0 0              1 2 3 4 5\n6 2 0 0 0              6 7 8 9 0\n9 7 3 0 0     ---->    9 8 7 0 0\n0 8 8 4 0              0 0 0 0 0\n0 0 7 9 5              0 0 0 0 0\n@param[in]\nlda       [int]\nspecifies the leading dimension of each A_i. lda must satisfy lda > k.\n@param[inout]\nx         device array of device pointer storing each vector x_i.\n@param[in]\nincx      [int]\nspecifies the increment for the elements of each x_i.\n@param[in]\nbatchCount [int]\nnumber of instances in the batch.\n"]
    pub fn hipblasStbmvBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        AP: *const *const f32,
        lda: ::std::os::raw::c_int,
        x: *const *mut f32,
        incx: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDtbmvBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        AP: *const *const f64,
        lda: ::std::os::raw::c_int,
        x: *const *mut f64,
        incx: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCtbmvBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        AP: *const *const hipblasComplex,
        lda: ::std::os::raw::c_int,
        x: *const *mut hipblasComplex,
        incx: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZtbmvBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        AP: *const *const hipblasDoubleComplex,
        lda: ::std::os::raw::c_int,
        x: *const *mut hipblasDoubleComplex,
        incx: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCtbmvBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        AP: *const *const hipComplex,
        lda: ::std::os::raw::c_int,
        x: *const *mut hipComplex,
        incx: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZtbmvBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        AP: *const *const hipDoubleComplex,
        lda: ::std::os::raw::c_int,
        x: *const *mut hipDoubleComplex,
        incx: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 2 API\n\n\\details\ntbmvStridedBatched performs one of the matrix-vector operations\n\nx_i := A_i*x_i      or\nx_i := A_i**T*x_i   or\nx_i := A_i**H*x_i,\n\nwhere (A_i, x_i) is the i-th instance of the batch.\nx_i is a vector and A_i is an m by m matrix, for i = 1, ..., batchCount.\n\n- Supported precisions in rocBLAS : s,d,c,z\n- Supported precisions in cuBLAS  : No support\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n@param[in]\nuplo      [hipblasFillMode_t]\nHIPBLAS_FILL_MODE_UPPER: each A_i is an upper banded triangular matrix.\nHIPBLAS_FILL_MODE_LOWER: each A_i is a  lower banded triangular matrix.\n@param[in]\ntransA     [hipblasOperation_t]\nindicates whether each matrix A_i is tranposed (conjugated) or not.\n@param[in]\ndiag      [hipblasDiagType_t]\nHIPBLAS_DIAG_UNIT: The main diagonal of each A_i is assumed to consist of only\n1's and is not referenced.\nHIPBLAS_DIAG_NON_UNIT: No assumptions are made of each A_i's main diagonal.\n@param[in]\nm         [int]\nthe number of rows and columns of the matrix represented by each A_i.\n@param[in]\nk         [int]\nif uplo == HIPBLAS_FILL_MODE_UPPER, k specifies the number of super-diagonals\nof each matrix A_i.\nif uplo == HIPBLAS_FILL_MODE_LOWER, k specifies the number of sub-diagonals\nof each matrix A_i.\nk must satisfy k > 0 && k < lda.\n@param[in]\nAP         device array to the first matrix A_i of the batch. Stores each banded triangular matrix A_i.\nif uplo == HIPBLAS_FILL_MODE_UPPER:\nThe matrix represented is an upper banded triangular matrix\nwith the main diagonal and k super-diagonals, everything\nelse can be assumed to be 0.\nThe matrix is compacted so that the main diagonal resides on the k'th\nrow, the first super diagonal resides on the RHS of the k-1'th row, etc,\nwith the k'th diagonal on the RHS of the 0'th row.\nEx: (HIPBLAS_FILL_MODE_UPPER; m = 5; k = 2)\n1 6 9 0 0              0 0 9 8 7\n0 2 7 8 0              0 6 7 8 9\n0 0 3 8 7     ---->    1 2 3 4 5\n0 0 0 4 9              0 0 0 0 0\n0 0 0 0 5              0 0 0 0 0\nif uplo == HIPBLAS_FILL_MODE_LOWER:\nThe matrix represnted is a lower banded triangular matrix\nwith the main diagonal and k sub-diagonals, everything else can be\nassumed to be 0.\nThe matrix is compacted so that the main diagonal resides on the 0'th row,\nworking up to the k'th diagonal residing on the LHS of the k'th row.\nEx: (HIPBLAS_FILL_MODE_LOWER; m = 5; k = 2)\n1 0 0 0 0              1 2 3 4 5\n6 2 0 0 0              6 7 8 9 0\n9 7 3 0 0     ---->    9 8 7 0 0\n0 8 8 4 0              0 0 0 0 0\n0 0 7 9 5              0 0 0 0 0\n@param[in]\nlda       [int]\nspecifies the leading dimension of each A_i. lda must satisfy lda > k.\n@param[in]\nstrideA  [hipblasStride]\nstride from the start of one A_i matrix to the next A_(i + 1).\n@param[inout]\nx         device array to the first vector x_i of the batch.\n@param[in]\nincx      [int]\nspecifies the increment for the elements of each x_i.\n@param[in]\nstridex  [hipblasStride]\nstride from the start of one x_i matrix to the next x_(i + 1).\n@param[in]\nbatchCount [int]\nnumber of instances in the batch.\n"]
    pub fn hipblasStbmvStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        AP: *const f32,
        lda: ::std::os::raw::c_int,
        strideA: hipblasStride,
        x: *mut f32,
        incx: ::std::os::raw::c_int,
        stridex: hipblasStride,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDtbmvStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        AP: *const f64,
        lda: ::std::os::raw::c_int,
        strideA: hipblasStride,
        x: *mut f64,
        incx: ::std::os::raw::c_int,
        stridex: hipblasStride,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCtbmvStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        AP: *const hipblasComplex,
        lda: ::std::os::raw::c_int,
        strideA: hipblasStride,
        x: *mut hipblasComplex,
        incx: ::std::os::raw::c_int,
        stridex: hipblasStride,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZtbmvStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        AP: *const hipblasDoubleComplex,
        lda: ::std::os::raw::c_int,
        strideA: hipblasStride,
        x: *mut hipblasDoubleComplex,
        incx: ::std::os::raw::c_int,
        stridex: hipblasStride,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCtbmvStridedBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        AP: *const hipComplex,
        lda: ::std::os::raw::c_int,
        strideA: hipblasStride,
        x: *mut hipComplex,
        incx: ::std::os::raw::c_int,
        stridex: hipblasStride,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZtbmvStridedBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        AP: *const hipDoubleComplex,
        lda: ::std::os::raw::c_int,
        strideA: hipblasStride,
        x: *mut hipDoubleComplex,
        incx: ::std::os::raw::c_int,
        stridex: hipblasStride,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 2 API\n\n\\details\ntbsv solves\n\nA*x = b or A**T*x = b or A**H*x = b,\n\nwhere x and b are vectors and A is a banded triangular matrix.\n\n- Supported precisions in rocBLAS : s,d,c,z\n- Supported precisions in cuBLAS  : s,d,c,z\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n\n@param[in]\nuplo    [hipblasFillMode_t]\nHIPBLAS_FILL_MODE_UPPER:  A is an upper triangular matrix.\nHIPBLAS_FILL_MODE_LOWER:  A is a  lower triangular matrix.\n\n@param[in]\ntransA     [hipblasOperation_t]\nHIPBLAS_OP_N: Solves A*x = b\nHIPBLAS_OP_T: Solves A**T*x = b\nHIPBLAS_OP_C: Solves A**H*x = b\n\n@param[in]\ndiag    [hipblasDiagType_t]\nHIPBLAS_DIAG_UNIT:     A is assumed to be unit triangular (i.e. the diagonal elements\nof A are not used in computations).\nHIPBLAS_DIAG_NON_UNIT: A is not assumed to be unit triangular.\n\n@param[in]\nn         [int]\nn specifies the number of rows of b. n >= 0.\n@param[in]\nk         [int]\nif(uplo == HIPBLAS_FILL_MODE_UPPER)\nk specifies the number of super-diagonals of A.\nif(uplo == HIPBLAS_FILL_MODE_LOWER)\nk specifies the number of sub-diagonals of A.\nk >= 0.\n\n@param[in]\nAP         device pointer storing the matrix A in banded format.\n\n@param[in]\nlda       [int]\nspecifies the leading dimension of A.\nlda >= (k + 1).\n\n@param[inout]\nx         device pointer storing input vector b. Overwritten by the output vector x.\n\n@param[in]\nincx      [int]\nspecifies the increment for the elements of x.\n"]
    pub fn hipblasStbsv(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        AP: *const f32,
        lda: ::std::os::raw::c_int,
        x: *mut f32,
        incx: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDtbsv(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        AP: *const f64,
        lda: ::std::os::raw::c_int,
        x: *mut f64,
        incx: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCtbsv(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        AP: *const hipblasComplex,
        lda: ::std::os::raw::c_int,
        x: *mut hipblasComplex,
        incx: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZtbsv(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        AP: *const hipblasDoubleComplex,
        lda: ::std::os::raw::c_int,
        x: *mut hipblasDoubleComplex,
        incx: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCtbsv_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        AP: *const hipComplex,
        lda: ::std::os::raw::c_int,
        x: *mut hipComplex,
        incx: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZtbsv_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        AP: *const hipDoubleComplex,
        lda: ::std::os::raw::c_int,
        x: *mut hipDoubleComplex,
        incx: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 2 API\n\n\\details\ntbsvBatched solves\n\nA_i*x_i = b_i or A_i**T*x_i = b_i or A_i**H*x_i = b_i,\n\nwhere x_i and b_i are vectors and A_i is a banded triangular matrix,\nfor i = [1, batchCount].\n\nThe input vectors b_i are overwritten by the output vectors x_i.\n\n- Supported precisions in rocBLAS : s,d,c,z\n- Supported precisions in cuBLAS  : No support\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n\n@param[in]\nuplo    [hipblasFillMode_t]\nHIPBLAS_FILL_MODE_UPPER:  A_i is an upper triangular matrix.\nHIPBLAS_FILL_MODE_LOWER:  A_i is a  lower triangular matrix.\n\n@param[in]\ntransA     [hipblasOperation_t]\nHIPBLAS_OP_N: Solves A_i*x_i = b_i\nHIPBLAS_OP_T: Solves A_i**T*x_i = b_i\nHIPBLAS_OP_C: Solves A_i**H*x_i = b_i\n\n@param[in]\ndiag    [hipblasDiagType_t]\nHIPBLAS_DIAG_UNIT:     each A_i is assumed to be unit triangular (i.e. the diagonal elements\nof each A_i are not used in computations).\nHIPBLAS_DIAG_NON_UNIT: each A_i is not assumed to be unit triangular.\n\n@param[in]\nn         [int]\nn specifies the number of rows of each b_i. n >= 0.\n@param[in]\nk         [int]\nif(uplo == HIPBLAS_FILL_MODE_UPPER)\nk specifies the number of super-diagonals of each A_i.\nif(uplo == HIPBLAS_FILL_MODE_LOWER)\nk specifies the number of sub-diagonals of each A_i.\nk >= 0.\n\n@param[in]\nAP         device vector of device pointers storing each matrix A_i in banded format.\n\n@param[in]\nlda       [int]\nspecifies the leading dimension of each A_i.\nlda >= (k + 1).\n\n@param[inout]\nx         device vector of device pointers storing each input vector b_i. Overwritten by each output\nvector x_i.\n@param[in]\nincx      [int]\nspecifies the increment for the elements of each x_i.\n@param[in]\nbatchCount [int]\nnumber of instances in the batch.\n"]
    pub fn hipblasStbsvBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        AP: *const *const f32,
        lda: ::std::os::raw::c_int,
        x: *const *mut f32,
        incx: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDtbsvBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        AP: *const *const f64,
        lda: ::std::os::raw::c_int,
        x: *const *mut f64,
        incx: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCtbsvBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        AP: *const *const hipblasComplex,
        lda: ::std::os::raw::c_int,
        x: *const *mut hipblasComplex,
        incx: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZtbsvBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        AP: *const *const hipblasDoubleComplex,
        lda: ::std::os::raw::c_int,
        x: *const *mut hipblasDoubleComplex,
        incx: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCtbsvBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        AP: *const *const hipComplex,
        lda: ::std::os::raw::c_int,
        x: *const *mut hipComplex,
        incx: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZtbsvBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        AP: *const *const hipDoubleComplex,
        lda: ::std::os::raw::c_int,
        x: *const *mut hipDoubleComplex,
        incx: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 2 API\n\n\\details\ntbsvStridedBatched solves\n\nA_i*x_i = b_i or A_i**T*x_i = b_i or A_i**H*x_i = b_i,\n\nwhere x_i and b_i are vectors and A_i is a banded triangular matrix,\nfor i = [1, batchCount].\n\nThe input vectors b_i are overwritten by the output vectors x_i.\n\n- Supported precisions in rocBLAS : s,d,c,z\n- Supported precisions in cuBLAS  : No support\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n\n@param[in]\nuplo    [hipblasFillMode_t]\nHIPBLAS_FILL_MODE_UPPER:  A_i is an upper triangular matrix.\nHIPBLAS_FILL_MODE_LOWER:  A_i is a  lower triangular matrix.\n\n@param[in]\ntransA     [hipblasOperation_t]\nHIPBLAS_OP_N: Solves A_i*x_i = b_i\nHIPBLAS_OP_T: Solves A_i**T*x_i = b_i\nHIPBLAS_OP_C: Solves A_i**H*x_i = b_i\n\n@param[in]\ndiag    [hipblasDiagType_t]\nHIPBLAS_DIAG_UNIT:     each A_i is assumed to be unit triangular (i.e. the diagonal elements\nof each A_i are not used in computations).\nHIPBLAS_DIAG_NON_UNIT: each A_i is not assumed to be unit triangular.\n\n@param[in]\nn         [int]\nn specifies the number of rows of each b_i. n >= 0.\n@param[in]\nk         [int]\nif(uplo == HIPBLAS_FILL_MODE_UPPER)\nk specifies the number of super-diagonals of each A_i.\nif(uplo == HIPBLAS_FILL_MODE_LOWER)\nk specifies the number of sub-diagonals of each A_i.\nk >= 0.\n\n@param[in]\nAP         device pointer pointing to the first banded matrix A_1.\n\n@param[in]\nlda       [int]\nspecifies the leading dimension of each A_i.\nlda >= (k + 1).\n@param[in]\nstrideA  [hipblasStride]\nspecifies the distance between the start of one matrix (A_i) and the next (A_i+1).\n\n@param[inout]\nx         device pointer pointing to the first input vector b_1. Overwritten by output vectors x.\n@param[in]\nincx      [int]\nspecifies the increment for the elements of each x_i.\n@param[in]\nstridex  [hipblasStride]\nspecifies the distance between the start of one vector (x_i) and the next (x_i+1).\n@param[in]\nbatchCount [int]\nnumber of instances in the batch.\n"]
    pub fn hipblasStbsvStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        AP: *const f32,
        lda: ::std::os::raw::c_int,
        strideA: hipblasStride,
        x: *mut f32,
        incx: ::std::os::raw::c_int,
        stridex: hipblasStride,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDtbsvStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        AP: *const f64,
        lda: ::std::os::raw::c_int,
        strideA: hipblasStride,
        x: *mut f64,
        incx: ::std::os::raw::c_int,
        stridex: hipblasStride,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCtbsvStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        AP: *const hipblasComplex,
        lda: ::std::os::raw::c_int,
        strideA: hipblasStride,
        x: *mut hipblasComplex,
        incx: ::std::os::raw::c_int,
        stridex: hipblasStride,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZtbsvStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        AP: *const hipblasDoubleComplex,
        lda: ::std::os::raw::c_int,
        strideA: hipblasStride,
        x: *mut hipblasDoubleComplex,
        incx: ::std::os::raw::c_int,
        stridex: hipblasStride,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCtbsvStridedBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        AP: *const hipComplex,
        lda: ::std::os::raw::c_int,
        strideA: hipblasStride,
        x: *mut hipComplex,
        incx: ::std::os::raw::c_int,
        stridex: hipblasStride,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZtbsvStridedBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        AP: *const hipDoubleComplex,
        lda: ::std::os::raw::c_int,
        strideA: hipblasStride,
        x: *mut hipDoubleComplex,
        incx: ::std::os::raw::c_int,
        stridex: hipblasStride,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 2 API\n\n\\details\ntpmv performs one of the matrix-vector operations\n\nx = A*x or x = A**T*x,\n\nwhere x is an n element vector and A is an n by n unit, or non-unit, upper or lower triangular matrix, supplied in the pack form.\n\nThe vector x is overwritten.\n\n- Supported precisions in rocBLAS : s,d,c,z\n- Supported precisions in cuBLAS  : s,d,c,z\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n\n@param[in]\nuplo    [hipblasFillMode_t]\nHIPBLAS_FILL_MODE_UPPER:  A is an upper triangular matrix.\nHIPBLAS_FILL_MODE_LOWER:  A is a  lower triangular matrix.\n\n@param[in]\ntransA     [hipblasOperation_t]\n\n@param[in]\ndiag    [hipblasDiagType_t]\nHIPBLAS_DIAG_UNIT:     A is assumed to be unit triangular.\nHIPBLAS_DIAG_NON_UNIT:  A is not assumed to be unit triangular.\n\n@param[in]\nm       [int]\nm specifies the number of rows of A. m >= 0.\n\n@param[in]\nAP       device pointer storing matrix A,\nof dimension at least ( m * ( m + 1 ) / 2 ).\nBefore entry with uplo = HIPBLAS_FILL_MODE_UPPER, the array A\nmust contain the upper triangular matrix packed sequentially,\ncolumn by column, so that A[0] contains a_{0,0}, A[1] and A[2] contain\na_{0,1} and a_{1, 1} respectively, and so on.\nBefore entry with uplo = HIPBLAS_FILL_MODE_LOWER, the array A\nmust contain the lower triangular matrix packed sequentially,\ncolumn by column, so that A[0] contains a_{0,0}, A[1] and A[2] contain\na_{1,0} and a_{2,0} respectively, and so on.\nNote that when DIAG = HIPBLAS_DIAG_UNIT, the diagonal elements of A are\nnot referenced, but are assumed to be unity.\n\n@param[in]\nx       device pointer storing vector x.\n\n@param[in]\nincx    [int]\nspecifies the increment for the elements of x. incx must not be zero.\n"]
    pub fn hipblasStpmv(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::std::os::raw::c_int,
        AP: *const f32,
        x: *mut f32,
        incx: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDtpmv(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::std::os::raw::c_int,
        AP: *const f64,
        x: *mut f64,
        incx: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCtpmv(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::std::os::raw::c_int,
        AP: *const hipblasComplex,
        x: *mut hipblasComplex,
        incx: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZtpmv(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::std::os::raw::c_int,
        AP: *const hipblasDoubleComplex,
        x: *mut hipblasDoubleComplex,
        incx: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCtpmv_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::std::os::raw::c_int,
        AP: *const hipComplex,
        x: *mut hipComplex,
        incx: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZtpmv_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::std::os::raw::c_int,
        AP: *const hipDoubleComplex,
        x: *mut hipDoubleComplex,
        incx: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 2 API\n\n\\details\ntpmvBatched performs one of the matrix-vector operations\n\nx_i = A_i*x_i or x_i = A**T*x_i, 0 \\le i < batchCount\n\nwhere x_i is an n element vector and A_i is an n by n (unit, or non-unit, upper or lower triangular matrix)\n\nThe vectors x_i are overwritten.\n\n- Supported precisions in rocBLAS : s,d,c,z\n- Supported precisions in cuBLAS  : No support\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n\n@param[in]\nuplo    [hipblasFillMode_t]\nHIPBLAS_FILL_MODE_UPPER:  A_i is an upper triangular matrix.\nHIPBLAS_FILL_MODE_LOWER:  A_i is a  lower triangular matrix.\n\n@param[in]\ntransA     [hipblasOperation_t]\n\n@param[in]\ndiag    [hipblasDiagType_t]\nHIPBLAS_DIAG_UNIT:     A_i is assumed to be unit triangular.\nHIPBLAS_DIAG_NON_UNIT:  A_i is not assumed to be unit triangular.\n\n@param[in]\nm         [int]\nm specifies the number of rows of matrices A_i. m >= 0.\n\n@param[in]\nAP         device pointer storing pointer of matrices A_i,\nof dimension ( lda, m )\n\n@param[in]\nx         device pointer storing vectors x_i.\n\n@param[in]\nincx      [int]\nspecifies the increment for the elements of vectors x_i.\n\n@param[in]\nbatchCount [int]\nThe number of batched matrices/vectors.\n\n"]
    pub fn hipblasStpmvBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::std::os::raw::c_int,
        AP: *const *const f32,
        x: *const *mut f32,
        incx: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDtpmvBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::std::os::raw::c_int,
        AP: *const *const f64,
        x: *const *mut f64,
        incx: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCtpmvBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::std::os::raw::c_int,
        AP: *const *const hipblasComplex,
        x: *const *mut hipblasComplex,
        incx: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZtpmvBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::std::os::raw::c_int,
        AP: *const *const hipblasDoubleComplex,
        x: *const *mut hipblasDoubleComplex,
        incx: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCtpmvBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::std::os::raw::c_int,
        AP: *const *const hipComplex,
        x: *const *mut hipComplex,
        incx: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZtpmvBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::std::os::raw::c_int,
        AP: *const *const hipDoubleComplex,
        x: *const *mut hipDoubleComplex,
        incx: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 2 API\n\n\\details\ntpmvStridedBatched performs one of the matrix-vector operations\n\nx_i = A_i*x_i or x_i = A**T*x_i, 0 \\le i < batchCount\n\nwhere x_i is an n element vector and A_i is an n by n (unit, or non-unit, upper or lower triangular matrix)\nwith strides specifying how to retrieve $x_i$ (resp. $A_i$) from $x_{i-1}$ (resp. $A_i$).\n\nThe vectors x_i are overwritten.\n\n- Supported precisions in rocBLAS : s,d,c,z\n- Supported precisions in cuBLAS  : No support\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n\n@param[in]\nuplo    [hipblasFillMode_t]\nHIPBLAS_FILL_MODE_UPPER:  A_i is an upper triangular matrix.\nHIPBLAS_FILL_MODE_LOWER:  A_i is a  lower triangular matrix.\n\n@param[in]\ntransA     [hipblasOperation_t]\n\n@param[in]\ndiag    [hipblasDiagType_t]\nHIPBLAS_DIAG_UNIT:     A_i is assumed to be unit triangular.\nHIPBLAS_DIAG_NON_UNIT:  A_i is not assumed to be unit triangular.\n\n@param[in]\nm         [int]\nm specifies the number of rows of matrices A_i. m >= 0.\n\n@param[in]\nAP         device pointer of the matrix A_0,\nof dimension ( lda, m )\n\n@param[in]\nstrideA  [hipblasStride]\nstride from the start of one A_i matrix to the next A_{i + 1}\n\n@param[in]\nx         device pointer storing the vector x_0.\n\n@param[in]\nincx      [int]\nspecifies the increment for the elements of one vector x.\n\n@param[in]\nstridex  [hipblasStride]\nstride from the start of one x_i vector to the next x_{i + 1}\n\n@param[in]\nbatchCount [int]\nThe number of batched matrices/vectors.\n\n"]
    pub fn hipblasStpmvStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::std::os::raw::c_int,
        AP: *const f32,
        strideA: hipblasStride,
        x: *mut f32,
        incx: ::std::os::raw::c_int,
        stridex: hipblasStride,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDtpmvStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::std::os::raw::c_int,
        AP: *const f64,
        strideA: hipblasStride,
        x: *mut f64,
        incx: ::std::os::raw::c_int,
        stridex: hipblasStride,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCtpmvStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::std::os::raw::c_int,
        AP: *const hipblasComplex,
        strideA: hipblasStride,
        x: *mut hipblasComplex,
        incx: ::std::os::raw::c_int,
        stridex: hipblasStride,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZtpmvStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::std::os::raw::c_int,
        AP: *const hipblasDoubleComplex,
        strideA: hipblasStride,
        x: *mut hipblasDoubleComplex,
        incx: ::std::os::raw::c_int,
        stridex: hipblasStride,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCtpmvStridedBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::std::os::raw::c_int,
        AP: *const hipComplex,
        strideA: hipblasStride,
        x: *mut hipComplex,
        incx: ::std::os::raw::c_int,
        stridex: hipblasStride,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZtpmvStridedBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::std::os::raw::c_int,
        AP: *const hipDoubleComplex,
        strideA: hipblasStride,
        x: *mut hipDoubleComplex,
        incx: ::std::os::raw::c_int,
        stridex: hipblasStride,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 2 API\n\n\\details\ntpsv solves\n\nA*x = b or A**T*x = b, or A**H*x = b,\n\nwhere x and b are vectors and A is a triangular matrix stored in the packed format.\n\nThe input vector b is overwritten by the output vector x.\n\n- Supported precisions in rocBLAS : s,d,c,z\n- Supported precisions in cuBLAS  : s,d,c,z\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n\n@param[in]\nuplo    [hipblasFillMode_t]\nHIPBLAS_FILL_MODE_UPPER:  A is an upper triangular matrix.\nHIPBLAS_FILL_MODE_LOWER:  A is a  lower triangular matrix.\n\n@param[in]\ntransA  [hipblasOperation_t]\nHIPBLAS_OP_N: Solves A*x = b\nHIPBLAS_OP_T: Solves A**T*x = b\nHIPBLAS_OP_C: Solves A**H*x = b\n\n@param[in]\ndiag    [hipblasDiagType_t]\nHIPBLAS_DIAG_UNIT:     A is assumed to be unit triangular (i.e. the diagonal elements\nof A are not used in computations).\nHIPBLAS_DIAG_NON_UNIT: A is not assumed to be unit triangular.\n\n@param[in]\nm         [int]\nm specifies the number of rows of b. m >= 0.\n\n@param[in]\nAP        device pointer storing the packed version of matrix A,\nof dimension >= (n * (n + 1) / 2)\n\n@param[inout]\nx         device pointer storing vector b on input, overwritten by x on output.\n\n@param[in]\nincx      [int]\nspecifies the increment for the elements of x.\n"]
    pub fn hipblasStpsv(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::std::os::raw::c_int,
        AP: *const f32,
        x: *mut f32,
        incx: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDtpsv(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::std::os::raw::c_int,
        AP: *const f64,
        x: *mut f64,
        incx: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCtpsv(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::std::os::raw::c_int,
        AP: *const hipblasComplex,
        x: *mut hipblasComplex,
        incx: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZtpsv(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::std::os::raw::c_int,
        AP: *const hipblasDoubleComplex,
        x: *mut hipblasDoubleComplex,
        incx: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCtpsv_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::std::os::raw::c_int,
        AP: *const hipComplex,
        x: *mut hipComplex,
        incx: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZtpsv_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::std::os::raw::c_int,
        AP: *const hipDoubleComplex,
        x: *mut hipDoubleComplex,
        incx: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 2 API\n\n\\details\ntpsvBatched solves\n\nA_i*x_i = b_i or A_i**T*x_i = b_i, or A_i**H*x_i = b_i,\n\nwhere x_i and b_i are vectors and A_i is a triangular matrix stored in the packed format,\nfor i in [1, batchCount].\n\nThe input vectors b_i are overwritten by the output vectors x_i.\n\n- Supported precisions in rocBLAS : s,d,c,z\n- Supported precisions in cuBLAS  : No support\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n\n@param[in]\nuplo    [hipblasFillMode_t]\nHIPBLAS_FILL_MODE_UPPER:  each A_i is an upper triangular matrix.\nHIPBLAS_FILL_MODE_LOWER:  each A_i is a  lower triangular matrix.\n\n@param[in]\ntransA  [hipblasOperation_t]\nHIPBLAS_OP_N: Solves A*x = b\nHIPBLAS_OP_T: Solves A**T*x = b\nHIPBLAS_OP_C: Solves A**H*x = b\n\n@param[in]\ndiag    [hipblasDiagType_t]\nHIPBLAS_DIAG_UNIT:     each A_i is assumed to be unit triangular (i.e. the diagonal elements\nof each A_i are not used in computations).\nHIPBLAS_DIAG_NON_UNIT: each A_i is not assumed to be unit triangular.\n\n@param[in]\nm         [int]\nm specifies the number of rows of each b_i. m >= 0.\n\n@param[in]\nAP        device array of device pointers storing the packed versions of each matrix A_i,\nof dimension >= (n * (n + 1) / 2)\n\n@param[inout]\nx         device array of device pointers storing each input vector b_i, overwritten by x_i on output.\n\n@param[in]\nincx      [int]\nspecifies the increment for the elements of each x_i.\n@param[in]\nbatchCount [int]\nspecifies the number of instances in the batch.\n"]
    pub fn hipblasStpsvBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::std::os::raw::c_int,
        AP: *const *const f32,
        x: *const *mut f32,
        incx: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDtpsvBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::std::os::raw::c_int,
        AP: *const *const f64,
        x: *const *mut f64,
        incx: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCtpsvBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::std::os::raw::c_int,
        AP: *const *const hipblasComplex,
        x: *const *mut hipblasComplex,
        incx: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZtpsvBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::std::os::raw::c_int,
        AP: *const *const hipblasDoubleComplex,
        x: *const *mut hipblasDoubleComplex,
        incx: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCtpsvBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::std::os::raw::c_int,
        AP: *const *const hipComplex,
        x: *const *mut hipComplex,
        incx: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZtpsvBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::std::os::raw::c_int,
        AP: *const *const hipDoubleComplex,
        x: *const *mut hipDoubleComplex,
        incx: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 2 API\n\n\\details\ntpsvStridedBatched solves\n\nA_i*x_i = b_i or A_i**T*x_i = b_i, or A_i**H*x_i = b_i,\n\nwhere x_i and b_i are vectors and A_i is a triangular matrix stored in the packed format,\nfor i in [1, batchCount].\n\nThe input vectors b_i are overwritten by the output vectors x_i.\n\n- Supported precisions in rocBLAS : s,d,c,z\n- Supported precisions in cuBLAS  : No support\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n\n@param[in]\nuplo    [hipblasFillMode_t]\nHIPBLAS_FILL_MODE_UPPER:  each A_i is an upper triangular matrix.\nHIPBLAS_FILL_MODE_LOWER:  each A_i is a  lower triangular matrix.\n\n@param[in]\ntransA  [hipblasOperation_t]\nHIPBLAS_OP_N: Solves A*x = b\nHIPBLAS_OP_T: Solves A**T*x = b\nHIPBLAS_OP_C: Solves A**H*x = b\n\n@param[in]\ndiag    [hipblasDiagType_t]\nHIPBLAS_DIAG_UNIT:     each A_i is assumed to be unit triangular (i.e. the diagonal elements\nof each A_i are not used in computations).\nHIPBLAS_DIAG_NON_UNIT: each A_i is not assumed to be unit triangular.\n\n@param[in]\nm         [int]\nm specifies the number of rows of each b_i. m >= 0.\n\n@param[in]\nAP        device pointer pointing to the first packed matrix A_1,\nof dimension >= (n * (n + 1) / 2)\n\n@param[in]\nstrideA  [hipblasStride]\nstride from the beginning of one packed matrix (AP_i) and the next (AP_i+1).\n\n@param[inout]\nx         device pointer pointing to the first input vector b_1. Overwritten by each x_i on output.\n\n@param[in]\nincx      [int]\nspecifies the increment for the elements of each x_i.\n@param[in]\nstridex  [hipblasStride]\nstride from the beginning of one vector (x_i) and the next (x_i+1).\n@param[in]\nbatchCount [int]\nspecifies the number of instances in the batch.\n"]
    pub fn hipblasStpsvStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::std::os::raw::c_int,
        AP: *const f32,
        strideA: hipblasStride,
        x: *mut f32,
        incx: ::std::os::raw::c_int,
        stridex: hipblasStride,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDtpsvStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::std::os::raw::c_int,
        AP: *const f64,
        strideA: hipblasStride,
        x: *mut f64,
        incx: ::std::os::raw::c_int,
        stridex: hipblasStride,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCtpsvStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::std::os::raw::c_int,
        AP: *const hipblasComplex,
        strideA: hipblasStride,
        x: *mut hipblasComplex,
        incx: ::std::os::raw::c_int,
        stridex: hipblasStride,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZtpsvStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::std::os::raw::c_int,
        AP: *const hipblasDoubleComplex,
        strideA: hipblasStride,
        x: *mut hipblasDoubleComplex,
        incx: ::std::os::raw::c_int,
        stridex: hipblasStride,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCtpsvStridedBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::std::os::raw::c_int,
        AP: *const hipComplex,
        strideA: hipblasStride,
        x: *mut hipComplex,
        incx: ::std::os::raw::c_int,
        stridex: hipblasStride,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZtpsvStridedBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::std::os::raw::c_int,
        AP: *const hipDoubleComplex,
        strideA: hipblasStride,
        x: *mut hipDoubleComplex,
        incx: ::std::os::raw::c_int,
        stridex: hipblasStride,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 2 API\n\n\\details\ntrmv performs one of the matrix-vector operations\n\nx = A*x or x = A**T*x,\n\nwhere x is an n element vector and A is an n by n unit, or non-unit, upper or lower triangular matrix.\n\nThe vector x is overwritten.\n\n- Supported precisions in rocBLAS : s,d,c,z\n- Supported precisions in cuBLAS  : s,d,c,z\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n\n@param[in]\nuplo    [hipblasFillMode_t]\nHIPBLAS_FILL_MODE_UPPER:  A is an upper triangular matrix.\nHIPBLAS_FILL_MODE_LOWER:  A is a  lower triangular matrix.\n\n@param[in]\ntransA     [hipblasOperation_t]\n\n@param[in]\ndiag    [hipblasDiagType_t]\nHIPBLAS_DIAG_UNIT:     A is assumed to be unit triangular.\nHIPBLAS_DIAG_NON_UNIT:  A is not assumed to be unit triangular.\n\n@param[in]\nm         [int]\nm specifies the number of rows of A. m >= 0.\n\n@param[in]\nAP        device pointer storing matrix A,\nof dimension ( lda, m )\n\n@param[in]\nlda       [int]\nspecifies the leading dimension of A.\nlda = max( 1, m ).\n\n@param[in]\nx         device pointer storing vector x.\n\n@param[in]\nincx      [int]\nspecifies the increment for the elements of x.\n"]
    pub fn hipblasStrmv(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::std::os::raw::c_int,
        AP: *const f32,
        lda: ::std::os::raw::c_int,
        x: *mut f32,
        incx: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDtrmv(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::std::os::raw::c_int,
        AP: *const f64,
        lda: ::std::os::raw::c_int,
        x: *mut f64,
        incx: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCtrmv(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::std::os::raw::c_int,
        AP: *const hipblasComplex,
        lda: ::std::os::raw::c_int,
        x: *mut hipblasComplex,
        incx: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZtrmv(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::std::os::raw::c_int,
        AP: *const hipblasDoubleComplex,
        lda: ::std::os::raw::c_int,
        x: *mut hipblasDoubleComplex,
        incx: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCtrmv_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::std::os::raw::c_int,
        AP: *const hipComplex,
        lda: ::std::os::raw::c_int,
        x: *mut hipComplex,
        incx: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZtrmv_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::std::os::raw::c_int,
        AP: *const hipDoubleComplex,
        lda: ::std::os::raw::c_int,
        x: *mut hipDoubleComplex,
        incx: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 2 API\n\n\\details\ntrmvBatched performs one of the matrix-vector operations\n\nx_i = A_i*x_i or x_i = A**T*x_i, 0 \\le i < batchCount\n\nwhere x_i is an n element vector and A_i is an n by n (unit, or non-unit, upper or lower triangular matrix)\n\nThe vectors x_i are overwritten.\n\n- Supported precisions in rocBLAS : s,d,c,z\n- Supported precisions in cuBLAS  : No support\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n\n@param[in]\nuplo    [hipblasFillMode_t]\nHIPBLAS_FILL_MODE_UPPER:  A_i is an upper triangular matrix.\nHIPBLAS_FILL_MODE_LOWER:  A_i is a  lower triangular matrix.\n\n@param[in]\ntransA     [hipblasOperation_t]\n\n@param[in]\ndiag    [hipblasDiagType_t]\nHIPBLAS_DIAG_UNIT:     A_i is assumed to be unit triangular.\nHIPBLAS_DIAG_NON_UNIT:  A_i is not assumed to be unit triangular.\n\n@param[in]\nm         [int]\nm specifies the number of rows of matrices A_i. m >= 0.\n\n@param[in]\nAP        device pointer storing pointer of matrices A_i,\nof dimension ( lda, m )\n\n@param[in]\nlda       [int]\nspecifies the leading dimension of A_i.\nlda >= max( 1, m ).\n\n@param[in]\nx         device pointer storing vectors x_i.\n\n@param[in]\nincx      [int]\nspecifies the increment for the elements of vectors x_i.\n\n@param[in]\nbatchCount [int]\nThe number of batched matrices/vectors.\n\n"]
    pub fn hipblasStrmvBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::std::os::raw::c_int,
        AP: *const *const f32,
        lda: ::std::os::raw::c_int,
        x: *const *mut f32,
        incx: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDtrmvBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::std::os::raw::c_int,
        AP: *const *const f64,
        lda: ::std::os::raw::c_int,
        x: *const *mut f64,
        incx: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCtrmvBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::std::os::raw::c_int,
        AP: *const *const hipblasComplex,
        lda: ::std::os::raw::c_int,
        x: *const *mut hipblasComplex,
        incx: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZtrmvBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::std::os::raw::c_int,
        AP: *const *const hipblasDoubleComplex,
        lda: ::std::os::raw::c_int,
        x: *const *mut hipblasDoubleComplex,
        incx: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCtrmvBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::std::os::raw::c_int,
        AP: *const *const hipComplex,
        lda: ::std::os::raw::c_int,
        x: *const *mut hipComplex,
        incx: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZtrmvBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::std::os::raw::c_int,
        AP: *const *const hipDoubleComplex,
        lda: ::std::os::raw::c_int,
        x: *const *mut hipDoubleComplex,
        incx: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 2 API\n\n\\details\ntrmvStridedBatched performs one of the matrix-vector operations\n\nx_i = A_i*x_i or x_i = A**T*x_i, 0 \\le i < batchCount\n\nwhere x_i is an n element vector and A_i is an n by n (unit, or non-unit, upper or lower triangular matrix)\nwith strides specifying how to retrieve $x_i$ (resp. $A_i$) from $x_{i-1}$ (resp. $A_i$).\n\nThe vectors x_i are overwritten.\n\n- Supported precisions in rocBLAS : s,d,c,z\n- Supported precisions in cuBLAS  : No support\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n\n@param[in]\nuplo    [hipblasFillMode_t]\nHIPBLAS_FILL_MODE_UPPER:  A_i is an upper triangular matrix.\nHIPBLAS_FILL_MODE_LOWER:  A_i is a  lower triangular matrix.\n\n@param[in]\ntransA     [hipblasOperation_t]\n\n@param[in]\ndiag    [hipblasDiagType_t]\nHIPBLAS_DIAG_UNIT:     A_i is assumed to be unit triangular.\nHIPBLAS_DIAG_NON_UNIT:  A_i is not assumed to be unit triangular.\n\n@param[in]\nm         [int]\nm specifies the number of rows of matrices A_i. m >= 0.\n\n@param[in]\nAP        device pointer of the matrix A_0,\nof dimension ( lda, m )\n\n@param[in]\nlda       [int]\nspecifies the leading dimension of A_i.\nlda >= max( 1, m ).\n\n@param[in]\nstrideA  [hipblasStride]\nstride from the start of one A_i matrix to the next A_{i + 1}\n\n@param[in]\nx         device pointer storing the vector x_0.\n\n@param[in]\nincx      [int]\nspecifies the increment for the elements of one vector x.\n\n@param[in]\nstridex  [hipblasStride]\nstride from the start of one x_i vector to the next x_{i + 1}\n\n@param[in]\nbatchCount [int]\nThe number of batched matrices/vectors.\n\n"]
    pub fn hipblasStrmvStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::std::os::raw::c_int,
        AP: *const f32,
        lda: ::std::os::raw::c_int,
        strideA: hipblasStride,
        x: *mut f32,
        incx: ::std::os::raw::c_int,
        stridex: hipblasStride,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDtrmvStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::std::os::raw::c_int,
        AP: *const f64,
        lda: ::std::os::raw::c_int,
        strideA: hipblasStride,
        x: *mut f64,
        incx: ::std::os::raw::c_int,
        stridex: hipblasStride,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCtrmvStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::std::os::raw::c_int,
        AP: *const hipblasComplex,
        lda: ::std::os::raw::c_int,
        strideA: hipblasStride,
        x: *mut hipblasComplex,
        incx: ::std::os::raw::c_int,
        stridex: hipblasStride,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZtrmvStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::std::os::raw::c_int,
        AP: *const hipblasDoubleComplex,
        lda: ::std::os::raw::c_int,
        strideA: hipblasStride,
        x: *mut hipblasDoubleComplex,
        incx: ::std::os::raw::c_int,
        stridex: hipblasStride,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCtrmvStridedBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::std::os::raw::c_int,
        AP: *const hipComplex,
        lda: ::std::os::raw::c_int,
        strideA: hipblasStride,
        x: *mut hipComplex,
        incx: ::std::os::raw::c_int,
        stridex: hipblasStride,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZtrmvStridedBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::std::os::raw::c_int,
        AP: *const hipDoubleComplex,
        lda: ::std::os::raw::c_int,
        strideA: hipblasStride,
        x: *mut hipDoubleComplex,
        incx: ::std::os::raw::c_int,
        stridex: hipblasStride,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 2 API\n\n\\details\ntrsv solves\n\nA*x = b or A**T*x = b,\n\nwhere x and b are vectors and A is a triangular matrix.\n\nThe vector x is overwritten on b.\n\n- Supported precisions in rocBLAS : s,d,c,z\n- Supported precisions in cuBLAS  : s,d,c,z\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n\n@param[in]\nuplo    [hipblasFillMode_t]\nHIPBLAS_FILL_MODE_UPPER:  A is an upper triangular matrix.\nHIPBLAS_FILL_MODE_LOWER:  A is a  lower triangular matrix.\n\n@param[in]\ntransA     [hipblasOperation_t]\n\n@param[in]\ndiag    [hipblasDiagType_t]\nHIPBLAS_DIAG_UNIT:     A is assumed to be unit triangular.\nHIPBLAS_DIAG_NON_UNIT:  A is not assumed to be unit triangular.\n\n@param[in]\nm         [int]\nm specifies the number of rows of b. m >= 0.\n\n@param[in]\nAP        device pointer storing matrix A,\nof dimension ( lda, m )\n\n@param[in]\nlda       [int]\nspecifies the leading dimension of A.\nlda = max( 1, m ).\n\n@param[in]\nx         device pointer storing vector x.\n\n@param[in]\nincx      [int]\nspecifies the increment for the elements of x.\n"]
    pub fn hipblasStrsv(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::std::os::raw::c_int,
        AP: *const f32,
        lda: ::std::os::raw::c_int,
        x: *mut f32,
        incx: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDtrsv(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::std::os::raw::c_int,
        AP: *const f64,
        lda: ::std::os::raw::c_int,
        x: *mut f64,
        incx: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCtrsv(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::std::os::raw::c_int,
        AP: *const hipblasComplex,
        lda: ::std::os::raw::c_int,
        x: *mut hipblasComplex,
        incx: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZtrsv(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::std::os::raw::c_int,
        AP: *const hipblasDoubleComplex,
        lda: ::std::os::raw::c_int,
        x: *mut hipblasDoubleComplex,
        incx: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCtrsv_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::std::os::raw::c_int,
        AP: *const hipComplex,
        lda: ::std::os::raw::c_int,
        x: *mut hipComplex,
        incx: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZtrsv_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::std::os::raw::c_int,
        AP: *const hipDoubleComplex,
        lda: ::std::os::raw::c_int,
        x: *mut hipDoubleComplex,
        incx: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 2 API\n\n\\details\ntrsvBatched solves\n\nA_i*x_i = b_i or A_i**T*x_i = b_i,\n\nwhere (A_i, x_i, b_i) is the i-th instance of the batch.\nx_i and b_i are vectors and A_i is an\nm by m triangular matrix.\n\nThe vector x is overwritten on b.\n\n- Supported precisions in rocBLAS : s,d,c,z\n- Supported precisions in cuBLAS  : No support\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n\n@param[in]\nuplo    [hipblasFillMode_t]\nHIPBLAS_FILL_MODE_UPPER:  A is an upper triangular matrix.\nHIPBLAS_FILL_MODE_LOWER:  A is a  lower triangular matrix.\n\n@param[in]\ntransA     [hipblasOperation_t]\n\n@param[in]\ndiag    [hipblasDiagType_t]\nHIPBLAS_DIAG_UNIT:     A is assumed to be unit triangular.\nHIPBLAS_DIAG_NON_UNIT:  A is not assumed to be unit triangular.\n\n@param[in]\nm         [int]\nm specifies the number of rows of b. m >= 0.\n\n@param[in]\nAP         device array of device pointers storing each matrix A_i.\n\n@param[in]\nlda       [int]\nspecifies the leading dimension of each A_i.\nlda = max(1, m)\n\n@param[in]\nx         device array of device pointers storing each vector x_i.\n\n@param[in]\nincx      [int]\nspecifies the increment for the elements of x.\n\n@param[in]\nbatchCount [int]\nnumber of instances in the batch\n"]
    pub fn hipblasStrsvBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::std::os::raw::c_int,
        AP: *const *const f32,
        lda: ::std::os::raw::c_int,
        x: *const *mut f32,
        incx: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDtrsvBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::std::os::raw::c_int,
        AP: *const *const f64,
        lda: ::std::os::raw::c_int,
        x: *const *mut f64,
        incx: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCtrsvBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::std::os::raw::c_int,
        AP: *const *const hipblasComplex,
        lda: ::std::os::raw::c_int,
        x: *const *mut hipblasComplex,
        incx: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZtrsvBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::std::os::raw::c_int,
        AP: *const *const hipblasDoubleComplex,
        lda: ::std::os::raw::c_int,
        x: *const *mut hipblasDoubleComplex,
        incx: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCtrsvBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::std::os::raw::c_int,
        AP: *const *const hipComplex,
        lda: ::std::os::raw::c_int,
        x: *const *mut hipComplex,
        incx: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZtrsvBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::std::os::raw::c_int,
        AP: *const *const hipDoubleComplex,
        lda: ::std::os::raw::c_int,
        x: *const *mut hipDoubleComplex,
        incx: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 2 API\n\n\\details\ntrsvStridedBatched solves\n\nA_i*x_i = b_i or A_i**T*x_i = b_i,\n\nwhere (A_i, x_i, b_i) is the i-th instance of the batch.\nx_i and b_i are vectors and A_i is an m by m triangular matrix, for i = 1, ..., batchCount.\n\nThe vector x is overwritten on b.\n\n- Supported precisions in rocBLAS : s,d,c,z\n- Supported precisions in cuBLAS  : No support\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n\n@param[in]\nuplo    [hipblasFillMode_t]\nHIPBLAS_FILL_MODE_UPPER:  A is an upper triangular matrix.\nHIPBLAS_FILL_MODE_LOWER:  A is a  lower triangular matrix.\n\n@param[in]\ntransA     [hipblasOperation_t]\n\n@param[in]\ndiag    [hipblasDiagType_t]\nHIPBLAS_DIAG_UNIT:     A is assumed to be unit triangular.\nHIPBLAS_DIAG_NON_UNIT:  A is not assumed to be unit triangular.\n\n@param[in]\nm         [int]\nm specifies the number of rows of each b_i. m >= 0.\n\n@param[in]\nAP         device pointer to the first matrix (A_1) in the batch, of dimension ( lda, m )\n\n@param[in]\nstrideA  [hipblasStride]\nstride from the start of one A_i matrix to the next A_(i + 1)\n\n@param[in]\nlda       [int]\nspecifies the leading dimension of each A_i.\nlda = max( 1, m ).\n\n@param[in, out]\nx         device pointer to the first vector (x_1) in the batch.\n\n@param[in]\nstridex [hipblasStride]\nstride from the start of one x_i vector to the next x_(i + 1)\n\n@param[in]\nincx      [int]\nspecifies the increment for the elements of each x_i.\n\n@param[in]\nbatchCount [int]\nnumber of instances in the batch\n"]
    pub fn hipblasStrsvStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::std::os::raw::c_int,
        AP: *const f32,
        lda: ::std::os::raw::c_int,
        strideA: hipblasStride,
        x: *mut f32,
        incx: ::std::os::raw::c_int,
        stridex: hipblasStride,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDtrsvStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::std::os::raw::c_int,
        AP: *const f64,
        lda: ::std::os::raw::c_int,
        strideA: hipblasStride,
        x: *mut f64,
        incx: ::std::os::raw::c_int,
        stridex: hipblasStride,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCtrsvStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::std::os::raw::c_int,
        AP: *const hipblasComplex,
        lda: ::std::os::raw::c_int,
        strideA: hipblasStride,
        x: *mut hipblasComplex,
        incx: ::std::os::raw::c_int,
        stridex: hipblasStride,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZtrsvStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::std::os::raw::c_int,
        AP: *const hipblasDoubleComplex,
        lda: ::std::os::raw::c_int,
        strideA: hipblasStride,
        x: *mut hipblasDoubleComplex,
        incx: ::std::os::raw::c_int,
        stridex: hipblasStride,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCtrsvStridedBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::std::os::raw::c_int,
        AP: *const hipComplex,
        lda: ::std::os::raw::c_int,
        strideA: hipblasStride,
        x: *mut hipComplex,
        incx: ::std::os::raw::c_int,
        stridex: hipblasStride,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZtrsvStridedBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::std::os::raw::c_int,
        AP: *const hipDoubleComplex,
        lda: ::std::os::raw::c_int,
        strideA: hipblasStride,
        x: *mut hipDoubleComplex,
        incx: ::std::os::raw::c_int,
        stridex: hipblasStride,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 3 API\n\n\\details\ngemm performs one of the matrix-matrix operations\n\nC = alpha*op( A )*op( B ) + beta*C,\n\nwhere op( X ) is one of\n\nop( X ) = X      or\nop( X ) = X**T   or\nop( X ) = X**H,\n\nalpha and beta are scalars, and A, B and C are matrices, with\nop( A ) an m by k matrix, op( B ) a k by n matrix and C an m by n matrix.\n\n- Supported precisions in rocBLAS : h,s,d,c,z\n- Supported precisions in cuBLAS  : h,s,d,c,z\n\n@param[in]\nhandle    [hipblasHandle_t]\n\n.\n@param[in]\ntransA    [hipblasOperation_t]\nspecifies the form of op( A )\n@param[in]\ntransB    [hipblasOperation_t]\nspecifies the form of op( B )\n@param[in]\nm         [int]\nnumber or rows of matrices op( A ) and C\n@param[in]\nn         [int]\nnumber of columns of matrices op( B ) and C\n@param[in]\nk         [int]\nnumber of columns of matrix op( A ) and number of rows of matrix op( B )\n@param[in]\nalpha     device pointer or host pointer specifying the scalar alpha.\n@param[in]\nAP         device pointer storing matrix A.\n@param[in]\nlda       [int]\nspecifies the leading dimension of A.\n@param[in]\nBP         device pointer storing matrix B.\n@param[in]\nldb       [int]\nspecifies the leading dimension of B.\n@param[in]\nbeta      device pointer or host pointer specifying the scalar beta.\n@param[in, out]\nCP         device pointer storing matrix C on the GPU.\n@param[in]\nldc       [int]\nspecifies the leading dimension of C.\n"]
    pub fn hipblasHgemm(
        handle: hipblasHandle_t,
        transA: hipblasOperation_t,
        transB: hipblasOperation_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        alpha: *const hipblasHalf,
        AP: *const hipblasHalf,
        lda: ::std::os::raw::c_int,
        BP: *const hipblasHalf,
        ldb: ::std::os::raw::c_int,
        beta: *const hipblasHalf,
        CP: *mut hipblasHalf,
        ldc: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSgemm(
        handle: hipblasHandle_t,
        transA: hipblasOperation_t,
        transB: hipblasOperation_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        alpha: *const f32,
        AP: *const f32,
        lda: ::std::os::raw::c_int,
        BP: *const f32,
        ldb: ::std::os::raw::c_int,
        beta: *const f32,
        CP: *mut f32,
        ldc: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDgemm(
        handle: hipblasHandle_t,
        transA: hipblasOperation_t,
        transB: hipblasOperation_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        alpha: *const f64,
        AP: *const f64,
        lda: ::std::os::raw::c_int,
        BP: *const f64,
        ldb: ::std::os::raw::c_int,
        beta: *const f64,
        CP: *mut f64,
        ldc: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgemm(
        handle: hipblasHandle_t,
        transA: hipblasOperation_t,
        transB: hipblasOperation_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        alpha: *const hipblasComplex,
        AP: *const hipblasComplex,
        lda: ::std::os::raw::c_int,
        BP: *const hipblasComplex,
        ldb: ::std::os::raw::c_int,
        beta: *const hipblasComplex,
        CP: *mut hipblasComplex,
        ldc: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgemm(
        handle: hipblasHandle_t,
        transA: hipblasOperation_t,
        transB: hipblasOperation_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        alpha: *const hipblasDoubleComplex,
        AP: *const hipblasDoubleComplex,
        lda: ::std::os::raw::c_int,
        BP: *const hipblasDoubleComplex,
        ldb: ::std::os::raw::c_int,
        beta: *const hipblasDoubleComplex,
        CP: *mut hipblasDoubleComplex,
        ldc: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgemm_v2(
        handle: hipblasHandle_t,
        transA: hipblasOperation_t,
        transB: hipblasOperation_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        alpha: *const hipComplex,
        AP: *const hipComplex,
        lda: ::std::os::raw::c_int,
        BP: *const hipComplex,
        ldb: ::std::os::raw::c_int,
        beta: *const hipComplex,
        CP: *mut hipComplex,
        ldc: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgemm_v2(
        handle: hipblasHandle_t,
        transA: hipblasOperation_t,
        transB: hipblasOperation_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        alpha: *const hipDoubleComplex,
        AP: *const hipDoubleComplex,
        lda: ::std::os::raw::c_int,
        BP: *const hipDoubleComplex,
        ldb: ::std::os::raw::c_int,
        beta: *const hipDoubleComplex,
        CP: *mut hipDoubleComplex,
        ldc: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 3 API\n\\details\ngemmBatched performs one of the batched matrix-matrix operations\nC_i = alpha*op( A_i )*op( B_i ) + beta*C_i, for i = 1, ..., batchCount.\nwhere op( X ) is one of\nop( X ) = X      or\nop( X ) = X**T   or\nop( X ) = X**H,\nalpha and beta are scalars, and A, B and C are strided batched matrices, with\nop( A ) an m by k by batchCount strided_batched matrix,\nop( B ) an k by n by batchCount strided_batched matrix and\nC an m by n by batchCount strided_batched matrix.\n\n- Supported precisions in rocBLAS : h,s,d,c,z\n- Supported precisions in cuBLAS  : h,s,d,c,z\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n@param[in]\ntransA    [hipblasOperation_t]\nspecifies the form of op( A )\n@param[in]\ntransB    [hipblasOperation_t]\nspecifies the form of op( B )\n@param[in]\nm         [int]\nmatrix dimension m.\n@param[in]\nn         [int]\nmatrix dimension n.\n@param[in]\nk         [int]\nmatrix dimension k.\n@param[in]\nalpha     device pointer or host pointer specifying the scalar alpha.\n@param[in]\nAP         device array of device pointers storing each matrix A_i.\n@param[in]\nlda       [int]\nspecifies the leading dimension of each A_i.\n@param[in]\nBP         device array of device pointers storing each matrix B_i.\n@param[in]\nldb       [int]\nspecifies the leading dimension of each B_i.\n@param[in]\nbeta      device pointer or host pointer specifying the scalar beta.\n@param[in, out]\nCP         device array of device pointers storing each matrix C_i.\n@param[in]\nldc       [int]\nspecifies the leading dimension of each C_i.\n@param[in]\nbatchCount\n[int]\nnumber of gemm operations in the batch"]
    pub fn hipblasHgemmBatched(
        handle: hipblasHandle_t,
        transA: hipblasOperation_t,
        transB: hipblasOperation_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        alpha: *const hipblasHalf,
        AP: *const *const hipblasHalf,
        lda: ::std::os::raw::c_int,
        BP: *const *const hipblasHalf,
        ldb: ::std::os::raw::c_int,
        beta: *const hipblasHalf,
        CP: *const *mut hipblasHalf,
        ldc: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSgemmBatched(
        handle: hipblasHandle_t,
        transA: hipblasOperation_t,
        transB: hipblasOperation_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        alpha: *const f32,
        AP: *const *const f32,
        lda: ::std::os::raw::c_int,
        BP: *const *const f32,
        ldb: ::std::os::raw::c_int,
        beta: *const f32,
        CP: *const *mut f32,
        ldc: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDgemmBatched(
        handle: hipblasHandle_t,
        transA: hipblasOperation_t,
        transB: hipblasOperation_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        alpha: *const f64,
        AP: *const *const f64,
        lda: ::std::os::raw::c_int,
        BP: *const *const f64,
        ldb: ::std::os::raw::c_int,
        beta: *const f64,
        CP: *const *mut f64,
        ldc: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgemmBatched(
        handle: hipblasHandle_t,
        transA: hipblasOperation_t,
        transB: hipblasOperation_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        alpha: *const hipblasComplex,
        AP: *const *const hipblasComplex,
        lda: ::std::os::raw::c_int,
        BP: *const *const hipblasComplex,
        ldb: ::std::os::raw::c_int,
        beta: *const hipblasComplex,
        CP: *const *mut hipblasComplex,
        ldc: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgemmBatched(
        handle: hipblasHandle_t,
        transA: hipblasOperation_t,
        transB: hipblasOperation_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        alpha: *const hipblasDoubleComplex,
        AP: *const *const hipblasDoubleComplex,
        lda: ::std::os::raw::c_int,
        BP: *const *const hipblasDoubleComplex,
        ldb: ::std::os::raw::c_int,
        beta: *const hipblasDoubleComplex,
        CP: *const *mut hipblasDoubleComplex,
        ldc: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgemmBatched_v2(
        handle: hipblasHandle_t,
        transA: hipblasOperation_t,
        transB: hipblasOperation_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        alpha: *const hipComplex,
        AP: *const *const hipComplex,
        lda: ::std::os::raw::c_int,
        BP: *const *const hipComplex,
        ldb: ::std::os::raw::c_int,
        beta: *const hipComplex,
        CP: *const *mut hipComplex,
        ldc: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgemmBatched_v2(
        handle: hipblasHandle_t,
        transA: hipblasOperation_t,
        transB: hipblasOperation_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        alpha: *const hipDoubleComplex,
        AP: *const *const hipDoubleComplex,
        lda: ::std::os::raw::c_int,
        BP: *const *const hipDoubleComplex,
        ldb: ::std::os::raw::c_int,
        beta: *const hipDoubleComplex,
        CP: *const *mut hipDoubleComplex,
        ldc: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 3 API\n\n\\details\ngemmStridedBatched performs one of the strided batched matrix-matrix operations\n\nC_i = alpha*op( A_i )*op( B_i ) + beta*C_i, for i = 1, ..., batchCount.\n\nwhere op( X ) is one of\n\nop( X ) = X      or\nop( X ) = X**T   or\nop( X ) = X**H,\n\nalpha and beta are scalars, and A, B and C are strided batched matrices, with\nop( A ) an m by k by batchCount strided_batched matrix,\nop( B ) an k by n by batchCount strided_batched matrix and\nC an m by n by batchCount strided_batched matrix.\n\n- Supported precisions in rocBLAS : h,s,d,c,z\n- Supported precisions in cuBLAS  : h,s,d,c,z\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n@param[in]\ntransA    [hipblasOperation_t]\nspecifies the form of op( A )\n@param[in]\ntransB    [hipblasOperation_t]\nspecifies the form of op( B )\n@param[in]\nm         [int]\nmatrix dimension m.\n@param[in]\nn         [int]\nmatrix dimension n.\n@param[in]\nk         [int]\nmatrix dimension k.\n@param[in]\nalpha     device pointer or host pointer specifying the scalar alpha.\n@param[in]\nAP         device pointer pointing to the first matrix A_1.\n@param[in]\nlda       [int]\nspecifies the leading dimension of each A_i.\n@param[in]\nstrideA  [hipblasStride]\nstride from the start of one A_i matrix to the next A_(i + 1).\n@param[in]\nBP         device pointer pointing to the first matrix B_1.\n@param[in]\nldb       [int]\nspecifies the leading dimension of each B_i.\n@param[in]\nstrideB  [hipblasStride]\nstride from the start of one B_i matrix to the next B_(i + 1).\n@param[in]\nbeta      device pointer or host pointer specifying the scalar beta.\n@param[in, out]\nCP         device pointer pointing to the first matrix C_1.\n@param[in]\nldc       [int]\nspecifies the leading dimension of each C_i.\n@param[in]\nstrideC  [hipblasStride]\nstride from the start of one C_i matrix to the next C_(i + 1).\n@param[in]\nbatchCount\n[int]\nnumber of gemm operatons in the batch\n"]
    pub fn hipblasHgemmStridedBatched(
        handle: hipblasHandle_t,
        transA: hipblasOperation_t,
        transB: hipblasOperation_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        alpha: *const hipblasHalf,
        AP: *const hipblasHalf,
        lda: ::std::os::raw::c_int,
        strideA: ::std::os::raw::c_longlong,
        BP: *const hipblasHalf,
        ldb: ::std::os::raw::c_int,
        strideB: ::std::os::raw::c_longlong,
        beta: *const hipblasHalf,
        CP: *mut hipblasHalf,
        ldc: ::std::os::raw::c_int,
        strideC: ::std::os::raw::c_longlong,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSgemmStridedBatched(
        handle: hipblasHandle_t,
        transA: hipblasOperation_t,
        transB: hipblasOperation_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        alpha: *const f32,
        AP: *const f32,
        lda: ::std::os::raw::c_int,
        strideA: ::std::os::raw::c_longlong,
        BP: *const f32,
        ldb: ::std::os::raw::c_int,
        strideB: ::std::os::raw::c_longlong,
        beta: *const f32,
        CP: *mut f32,
        ldc: ::std::os::raw::c_int,
        strideC: ::std::os::raw::c_longlong,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDgemmStridedBatched(
        handle: hipblasHandle_t,
        transA: hipblasOperation_t,
        transB: hipblasOperation_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        alpha: *const f64,
        AP: *const f64,
        lda: ::std::os::raw::c_int,
        strideA: ::std::os::raw::c_longlong,
        BP: *const f64,
        ldb: ::std::os::raw::c_int,
        strideB: ::std::os::raw::c_longlong,
        beta: *const f64,
        CP: *mut f64,
        ldc: ::std::os::raw::c_int,
        strideC: ::std::os::raw::c_longlong,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgemmStridedBatched(
        handle: hipblasHandle_t,
        transA: hipblasOperation_t,
        transB: hipblasOperation_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        alpha: *const hipblasComplex,
        AP: *const hipblasComplex,
        lda: ::std::os::raw::c_int,
        strideA: ::std::os::raw::c_longlong,
        BP: *const hipblasComplex,
        ldb: ::std::os::raw::c_int,
        strideB: ::std::os::raw::c_longlong,
        beta: *const hipblasComplex,
        CP: *mut hipblasComplex,
        ldc: ::std::os::raw::c_int,
        strideC: ::std::os::raw::c_longlong,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgemmStridedBatched(
        handle: hipblasHandle_t,
        transA: hipblasOperation_t,
        transB: hipblasOperation_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        alpha: *const hipblasDoubleComplex,
        AP: *const hipblasDoubleComplex,
        lda: ::std::os::raw::c_int,
        strideA: ::std::os::raw::c_longlong,
        BP: *const hipblasDoubleComplex,
        ldb: ::std::os::raw::c_int,
        strideB: ::std::os::raw::c_longlong,
        beta: *const hipblasDoubleComplex,
        CP: *mut hipblasDoubleComplex,
        ldc: ::std::os::raw::c_int,
        strideC: ::std::os::raw::c_longlong,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgemmStridedBatched_v2(
        handle: hipblasHandle_t,
        transA: hipblasOperation_t,
        transB: hipblasOperation_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        alpha: *const hipComplex,
        AP: *const hipComplex,
        lda: ::std::os::raw::c_int,
        strideA: ::std::os::raw::c_longlong,
        BP: *const hipComplex,
        ldb: ::std::os::raw::c_int,
        strideB: ::std::os::raw::c_longlong,
        beta: *const hipComplex,
        CP: *mut hipComplex,
        ldc: ::std::os::raw::c_int,
        strideC: ::std::os::raw::c_longlong,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgemmStridedBatched_v2(
        handle: hipblasHandle_t,
        transA: hipblasOperation_t,
        transB: hipblasOperation_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        alpha: *const hipDoubleComplex,
        AP: *const hipDoubleComplex,
        lda: ::std::os::raw::c_int,
        strideA: ::std::os::raw::c_longlong,
        BP: *const hipDoubleComplex,
        ldb: ::std::os::raw::c_int,
        strideB: ::std::os::raw::c_longlong,
        beta: *const hipDoubleComplex,
        CP: *mut hipDoubleComplex,
        ldc: ::std::os::raw::c_int,
        strideC: ::std::os::raw::c_longlong,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 3 API\n\n\\details\n\nherk performs one of the matrix-matrix operations for a Hermitian rank-k update\n\nC := alpha*op( A )*op( A )^H + beta*C\n\nwhere  alpha and beta are scalars, op(A) is an n by k matrix, and\nC is a n x n Hermitian matrix stored as either upper or lower.\n\nop( A ) = A,  and A is n by k if transA == HIPBLAS_OP_N\nop( A ) = A^H and A is k by n if transA == HIPBLAS_OP_C\n\n- Supported precisions in rocBLAS : c,z\n- Supported precisions in cuBLAS  : c,z\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n\n@param[in]\nuplo    [hipblasFillMode_t]\nHIPBLAS_FILL_MODE_UPPER:  C is an upper triangular matrix\nHIPBLAS_FILL_MODE_LOWER:  C is a  lower triangular matrix\n\n@param[in]\ntransA  [hipblasOperation_t]\nHIPBLAS_OP_C:  op(A) = A^H\nHIPBLAS_ON_N:  op(A) = A\n\n@param[in]\nn       [int]\nn specifies the number of rows and columns of C. n >= 0.\n\n@param[in]\nk       [int]\nk specifies the number of columns of op(A). k >= 0.\n\n@param[in]\nalpha\nalpha specifies the scalar alpha. When alpha is\nzero then A is not referenced and A need not be set before\nentry.\n\n@param[in]\nAP       pointer storing matrix A on the GPU.\nMartrix dimension is ( lda, k ) when if transA = HIPBLAS_OP_N, otherwise (lda, n)\nonly the upper/lower triangular part is accessed.\n\n@param[in]\nlda     [int]\nlda specifies the first dimension of A.\nif transA = HIPBLAS_OP_N,  lda >= max( 1, n ),\notherwise lda >= max( 1, k ).\n\n@param[in]\nbeta\nbeta specifies the scalar beta. When beta is\nzero then C need not be set before entry.\n\n@param[in]\nCP       pointer storing matrix C on the GPU.\nThe imaginary component of the diagonal elements are not used but are set to zero unless quick return.\n\n@param[in]\nldc    [int]\nldc specifies the first dimension of C. ldc >= max( 1, n ).\n"]
    pub fn hipblasCherk(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        alpha: *const f32,
        AP: *const hipblasComplex,
        lda: ::std::os::raw::c_int,
        beta: *const f32,
        CP: *mut hipblasComplex,
        ldc: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZherk(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        alpha: *const f64,
        AP: *const hipblasDoubleComplex,
        lda: ::std::os::raw::c_int,
        beta: *const f64,
        CP: *mut hipblasDoubleComplex,
        ldc: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCherk_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        alpha: *const f32,
        AP: *const hipComplex,
        lda: ::std::os::raw::c_int,
        beta: *const f32,
        CP: *mut hipComplex,
        ldc: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZherk_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        alpha: *const f64,
        AP: *const hipDoubleComplex,
        lda: ::std::os::raw::c_int,
        beta: *const f64,
        CP: *mut hipDoubleComplex,
        ldc: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 3 API\n\n\\details\n\nherkBatched performs a batch of the matrix-matrix operations for a Hermitian rank-k update\n\nC_i := alpha*op( A_i )*op( A_i )^H + beta*C_i\n\nwhere  alpha and beta are scalars, op(A) is an n by k matrix, and\nC_i is a n x n Hermitian matrix stored as either upper or lower.\n\nop( A_i ) = A_i, and A_i is n by k if transA == HIPBLAS_OP_N\nop( A_i ) = A_i^H and A_i is k by n if transA == HIPBLAS_OP_C\n\n- Supported precisions in rocBLAS : c,z\n- Supported precisions in cuBLAS  : No support\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n\n@param[in]\nuplo    [hipblasFillMode_t]\nHIPBLAS_FILL_MODE_UPPER:  C_i is an upper triangular matrix\nHIPBLAS_FILL_MODE_LOWER:  C_i is a  lower triangular matrix\n\n@param[in]\ntransA  [hipblasOperation_t]\nHIPBLAS_OP_C: op(A) = A^H\nHIPBLAS_OP_N: op(A) = A\n\n@param[in]\nn       [int]\nn specifies the number of rows and columns of C_i. n >= 0.\n\n@param[in]\nk       [int]\nk specifies the number of columns of op(A). k >= 0.\n\n@param[in]\nalpha\nalpha specifies the scalar alpha. When alpha is\nzero then A is not referenced and A need not be set before\nentry.\n\n@param[in]\nAP       device array of device pointers storing each matrix_i A of dimension (lda, k)\nwhen transA is HIPBLAS_OP_N, otherwise of dimension (lda, n)\n\n@param[in]\nlda     [int]\nlda specifies the first dimension of A_i.\nif transA = HIPBLAS_OP_N,  lda >= max( 1, n ),\notherwise lda >= max( 1, k ).\n\n@param[in]\nbeta\nbeta specifies the scalar beta. When beta is\nzero then C need not be set before entry.\n\n@param[in]\nCP       device array of device pointers storing each matrix C_i on the GPU.\nThe imaginary component of the diagonal elements are not used but are set to zero unless quick return.\n\n@param[in]\nldc    [int]\nldc specifies the first dimension of C. ldc >= max( 1, n ).\n@param[in]\nbatchCount [int]\nnumber of instances in the batch.\n"]
    pub fn hipblasCherkBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        alpha: *const f32,
        AP: *const *const hipblasComplex,
        lda: ::std::os::raw::c_int,
        beta: *const f32,
        CP: *const *mut hipblasComplex,
        ldc: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZherkBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        alpha: *const f64,
        AP: *const *const hipblasDoubleComplex,
        lda: ::std::os::raw::c_int,
        beta: *const f64,
        CP: *const *mut hipblasDoubleComplex,
        ldc: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCherkBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        alpha: *const f32,
        AP: *const *const hipComplex,
        lda: ::std::os::raw::c_int,
        beta: *const f32,
        CP: *const *mut hipComplex,
        ldc: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZherkBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        alpha: *const f64,
        AP: *const *const hipDoubleComplex,
        lda: ::std::os::raw::c_int,
        beta: *const f64,
        CP: *const *mut hipDoubleComplex,
        ldc: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 3 API\n\n\\details\n\nherkStridedBatched performs a batch of the matrix-matrix operations for a Hermitian rank-k update\n\nC_i := alpha*op( A_i )*op( A_i )^H + beta*C_i\n\nwhere  alpha and beta are scalars, op(A) is an n by k matrix, and\nC_i is a n x n Hermitian matrix stored as either upper or lower.\n\nop( A_i ) = A_i, and A_i is n by k if transA == HIPBLAS_OP_N\nop( A_i ) = A_i^H and A_i is k by n if transA == HIPBLAS_OP_C\n\n- Supported precisions in rocBLAS : c,z\n- Supported precisions in cuBLAS  : No support\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n\n@param[in]\nuplo    [hipblasFillMode_t]\nHIPBLAS_FILL_MODE_UPPER:  C_i is an upper triangular matrix\nHIPBLAS_FILL_MODE_LOWER:  C_i is a  lower triangular matrix\n\n@param[in]\ntransA  [hipblasOperation_t]\nHIPBLAS_OP_C: op(A) = A^H\nHIPBLAS_OP_N: op(A) = A\n\n@param[in]\nn       [int]\nn specifies the number of rows and columns of C_i. n >= 0.\n\n@param[in]\nk       [int]\nk specifies the number of columns of op(A). k >= 0.\n\n@param[in]\nalpha\nalpha specifies the scalar alpha. When alpha is\nzero then A is not referenced and A need not be set before\nentry.\n\n@param[in]\nAP       Device pointer to the first matrix A_1 on the GPU of dimension (lda, k)\nwhen transA is HIPBLAS_OP_N, otherwise of dimension (lda, n)\n\n@param[in]\nlda     [int]\nlda specifies the first dimension of A_i.\nif transA = HIPBLAS_OP_N,  lda >= max( 1, n ),\notherwise lda >= max( 1, k ).\n\n@param[in]\nstrideA  [hipblasStride]\nstride from the start of one matrix (A_i) and the next one (A_i+1)\n\n@param[in]\nbeta\nbeta specifies the scalar beta. When beta is\nzero then C need not be set before entry.\n\n@param[in]\nCP       Device pointer to the first matrix C_1 on the GPU.\nThe imaginary component of the diagonal elements are not used but are set to zero unless quick return.\n\n@param[in]\nldc    [int]\nldc specifies the first dimension of C. ldc >= max( 1, n ).\n\n@param[inout]\nstrideC  [hipblasStride]\nstride from the start of one matrix (C_i) and the next one (C_i+1)\n\n@param[in]\nbatchCount [int]\nnumber of instances in the batch.\n"]
    pub fn hipblasCherkStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        alpha: *const f32,
        AP: *const hipblasComplex,
        lda: ::std::os::raw::c_int,
        strideA: hipblasStride,
        beta: *const f32,
        CP: *mut hipblasComplex,
        ldc: ::std::os::raw::c_int,
        strideC: hipblasStride,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZherkStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        alpha: *const f64,
        AP: *const hipblasDoubleComplex,
        lda: ::std::os::raw::c_int,
        strideA: hipblasStride,
        beta: *const f64,
        CP: *mut hipblasDoubleComplex,
        ldc: ::std::os::raw::c_int,
        strideC: hipblasStride,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCherkStridedBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        alpha: *const f32,
        AP: *const hipComplex,
        lda: ::std::os::raw::c_int,
        strideA: hipblasStride,
        beta: *const f32,
        CP: *mut hipComplex,
        ldc: ::std::os::raw::c_int,
        strideC: hipblasStride,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZherkStridedBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        alpha: *const f64,
        AP: *const hipDoubleComplex,
        lda: ::std::os::raw::c_int,
        strideA: hipblasStride,
        beta: *const f64,
        CP: *mut hipDoubleComplex,
        ldc: ::std::os::raw::c_int,
        strideC: hipblasStride,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 3 API\n\n\\details\n\nherkx performs one of the matrix-matrix operations for a Hermitian rank-k update\n\nC := alpha*op( A )*op( B )^H + beta*C\n\nwhere  alpha and beta are scalars, op(A) and op(B) are n by k matrices, and\nC is a n x n Hermitian matrix stored as either upper or lower.\nThis routine should only be used when the caller can guarantee that the result of op( A )*op( B )^T will be Hermitian.\n\n\nop( A ) = A, op( B ) = B, and A and B are n by k if trans == HIPBLAS_OP_N\nop( A ) = A^H, op( B ) = B^H,  and A and B are k by n if trans == HIPBLAS_OP_C\n\n- Supported precisions in rocBLAS : c,z\n- Supported precisions in cuBLAS  : c,z\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n\n@param[in]\nuplo    [hipblasFillMode_t]\nHIPBLAS_FILL_MODE_UPPER:  C is an upper triangular matrix\nHIPBLAS_FILL_MODE_LOWER:  C is a  lower triangular matrix\n\n@param[in]\ntransA  [hipblasOperation_t]\nHIPBLAS_OP_C:  op( A ) = A^H, op( B ) = B^H\nHIPBLAS_OP_N:  op( A ) = A, op( B ) = B\n\n@param[in]\nn       [int]\nn specifies the number of rows and columns of C. n >= 0.\n\n@param[in]\nk       [int]\nk specifies the number of columns of op(A). k >= 0.\n\n@param[in]\nalpha\nalpha specifies the scalar alpha. When alpha is\nzero then A is not referenced and A need not be set before\nentry.\n\n@param[in]\nAP      pointer storing matrix A on the GPU.\nMartrix dimension is ( lda, k ) when if trans = HIPBLAS_OP_N, otherwise (lda, n)\nonly the upper/lower triangular part is accessed.\n\n@param[in]\nlda     [int]\nlda specifies the first dimension of A.\nif trans = HIPBLAS_OP_N,  lda >= max( 1, n ),\notherwise lda >= max( 1, k ).\n@param[in]\nBP       pointer storing matrix B on the GPU.\nMartrix dimension is ( ldb, k ) when if trans = HIPBLAS_OP_N, otherwise (ldb, n)\nonly the upper/lower triangular part is accessed.\n\n@param[in]\nldb     [int]\nldb specifies the first dimension of B.\nif trans = HIPBLAS_OP_N,  ldb >= max( 1, n ),\notherwise ldb >= max( 1, k ).\n@param[in]\nbeta\nbeta specifies the scalar beta. When beta is\nzero then C need not be set before entry.\n\n@param[in]\nCP       pointer storing matrix C on the GPU.\nThe imaginary component of the diagonal elements are not used but are set to zero unless quick return.\n\n@param[in]\nldc    [int]\nldc specifies the first dimension of C. ldc >= max( 1, n ).\n"]
    pub fn hipblasCherkx(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        alpha: *const hipblasComplex,
        AP: *const hipblasComplex,
        lda: ::std::os::raw::c_int,
        BP: *const hipblasComplex,
        ldb: ::std::os::raw::c_int,
        beta: *const f32,
        CP: *mut hipblasComplex,
        ldc: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZherkx(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        alpha: *const hipblasDoubleComplex,
        AP: *const hipblasDoubleComplex,
        lda: ::std::os::raw::c_int,
        BP: *const hipblasDoubleComplex,
        ldb: ::std::os::raw::c_int,
        beta: *const f64,
        CP: *mut hipblasDoubleComplex,
        ldc: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCherkx_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        alpha: *const hipComplex,
        AP: *const hipComplex,
        lda: ::std::os::raw::c_int,
        BP: *const hipComplex,
        ldb: ::std::os::raw::c_int,
        beta: *const f32,
        CP: *mut hipComplex,
        ldc: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZherkx_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        alpha: *const hipDoubleComplex,
        AP: *const hipDoubleComplex,
        lda: ::std::os::raw::c_int,
        BP: *const hipDoubleComplex,
        ldb: ::std::os::raw::c_int,
        beta: *const f64,
        CP: *mut hipDoubleComplex,
        ldc: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 3 API\n\n\\details\n\nherkxBatched performs a batch of the matrix-matrix operations for a Hermitian rank-k update\n\nC_i := alpha*op( A_i )*op( B_i )^H + beta*C_i\n\nwhere  alpha and beta are scalars, op(A_i) and op(B_i) are n by k matrices, and\nC_i is a n x n Hermitian matrix stored as either upper or lower.\nThis routine should only be used when the caller can guarantee that the result of op( A )*op( B )^T will be Hermitian.\n\nop( A_i ) = A_i, op( B_i ) = B_i, and A_i and B_i are n by k if trans == HIPBLAS_OP_N\nop( A_i ) = A_i^H, op( B_i ) = B_i^H,  and A_i and B_i are k by n if trans == HIPBLAS_OP_C\n\n- Supported precisions in rocBLAS : c,z\n- Supported precisions in cuBLAS  : No support\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n\n@param[in]\nuplo    [hipblasFillMode_t]\nHIPBLAS_FILL_MODE_UPPER:  C_i is an upper triangular matrix\nHIPBLAS_FILL_MODE_LOWER:  C_i is a  lower triangular matrix\n\n@param[in]\ntransA  [hipblasOperation_t]\nHIPBLAS_OP_C: op(A) = A^H\nHIPBLAS_OP_N: op(A) = A\n\n@param[in]\nn       [int]\nn specifies the number of rows and columns of C_i. n >= 0.\n\n@param[in]\nk       [int]\nk specifies the number of columns of op(A). k >= 0.\n\n@param[in]\nalpha\nalpha specifies the scalar alpha. When alpha is\nzero then A is not referenced and A need not be set before\nentry.\n\n@param[in]\nAP       device array of device pointers storing each matrix_i A of dimension (lda, k)\nwhen trans is HIPBLAS_OP_N, otherwise of dimension (lda, n)\n\n@param[in]\nlda     [int]\nlda specifies the first dimension of A_i.\nif trans = HIPBLAS_OP_N,  lda >= max( 1, n ),\notherwise lda >= max( 1, k ).\n\n@param[in]\nBP       device array of device pointers storing each matrix_i B of dimension (ldb, k)\nwhen trans is HIPBLAS_OP_N, otherwise of dimension (ldb, n)\n\n@param[in]\nldb     [int]\nldb specifies the first dimension of B_i.\nif trans = HIPBLAS_OP_N,  ldb >= max( 1, n ),\notherwise ldb >= max( 1, k ).\n\n@param[in]\nbeta\nbeta specifies the scalar beta. When beta is\nzero then C need not be set before entry.\n\n@param[in]\nCP       device array of device pointers storing each matrix C_i on the GPU.\nThe imaginary component of the diagonal elements are not used but are set to zero unless quick return.\n\n@param[in]\nldc    [int]\nldc specifies the first dimension of C. ldc >= max( 1, n ).\n\n@param[in]\nbatchCount [int]\nnumber of instances in the batch.\n"]
    pub fn hipblasCherkxBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        alpha: *const hipblasComplex,
        AP: *const *const hipblasComplex,
        lda: ::std::os::raw::c_int,
        BP: *const *const hipblasComplex,
        ldb: ::std::os::raw::c_int,
        beta: *const f32,
        CP: *const *mut hipblasComplex,
        ldc: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZherkxBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        alpha: *const hipblasDoubleComplex,
        AP: *const *const hipblasDoubleComplex,
        lda: ::std::os::raw::c_int,
        BP: *const *const hipblasDoubleComplex,
        ldb: ::std::os::raw::c_int,
        beta: *const f64,
        CP: *const *mut hipblasDoubleComplex,
        ldc: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCherkxBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        alpha: *const hipComplex,
        AP: *const *const hipComplex,
        lda: ::std::os::raw::c_int,
        BP: *const *const hipComplex,
        ldb: ::std::os::raw::c_int,
        beta: *const f32,
        CP: *const *mut hipComplex,
        ldc: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZherkxBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        alpha: *const hipDoubleComplex,
        AP: *const *const hipDoubleComplex,
        lda: ::std::os::raw::c_int,
        BP: *const *const hipDoubleComplex,
        ldb: ::std::os::raw::c_int,
        beta: *const f64,
        CP: *const *mut hipDoubleComplex,
        ldc: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 3 API\n\n\\details\n\nherkxStridedBatched performs a batch of the matrix-matrix operations for a Hermitian rank-k update\n\nC_i := alpha*op( A_i )*op( B_i )^H + beta*C_i\n\nwhere  alpha and beta are scalars, op(A_i) and op(B_i) are n by k matrices, and\nC_i is a n x n Hermitian matrix stored as either upper or lower.\nThis routine should only be used when the caller can guarantee that the result of op( A )*op( B )^T will be Hermitian.\n\nop( A_i ) = A_i, op( B_i ) = B_i, and A_i and B_i are n by k if trans == HIPBLAS_OP_N\nop( A_i ) = A_i^H, op( B_i ) = B_i^H,  and A_i and B_i are k by n if trans == HIPBLAS_OP_C\n\n- Supported precisions in rocBLAS : c,z\n- Supported precisions in cuBLAS  : No support\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n\n@param[in]\nuplo    [hipblasFillMode_t]\nHIPBLAS_FILL_MODE_UPPER:  C_i is an upper triangular matrix\nHIPBLAS_FILL_MODE_LOWER:  C_i is a  lower triangular matrix\n\n@param[in]\ntransA  [hipblasOperation_t]\nHIPBLAS_OP_C: op( A_i ) = A_i^H, op( B_i ) = B_i^H\nHIPBLAS_OP_N: op( A_i ) = A_i, op( B_i ) = B_i\n\n@param[in]\nn       [int]\nn specifies the number of rows and columns of C_i. n >= 0.\n\n@param[in]\nk       [int]\nk specifies the number of columns of op(A). k >= 0.\n\n@param[in]\nalpha\nalpha specifies the scalar alpha. When alpha is\nzero then A is not referenced and A need not be set before\nentry.\n\n@param[in]\nAP       Device pointer to the first matrix A_1 on the GPU of dimension (lda, k)\nwhen trans is HIPBLAS_OP_N, otherwise of dimension (lda, n)\n\n@param[in]\nlda     [int]\nlda specifies the first dimension of A_i.\nif trans = HIPBLAS_OP_N,  lda >= max( 1, n ),\notherwise lda >= max( 1, k ).\n\n@param[in]\nstrideA  [hipblasStride]\nstride from the start of one matrix (A_i) and the next one (A_i+1)\n\n@param[in]\nBP       Device pointer to the first matrix B_1 on the GPU of dimension (ldb, k)\nwhen trans is HIPBLAS_OP_N, otherwise of dimension (ldb, n)\n\n@param[in]\nldb     [int]\nldb specifies the first dimension of B_i.\nif trans = HIPBLAS_OP_N,  ldb >= max( 1, n ),\notherwise ldb >= max( 1, k ).\n\n@param[in]\nstrideB  [hipblasStride]\nstride from the start of one matrix (B_i) and the next one (B_i+1)\n\n@param[in]\nbeta\nbeta specifies the scalar beta. When beta is\nzero then C need not be set before entry.\n\n@param[in]\nCP       Device pointer to the first matrix C_1 on the GPU.\nThe imaginary component of the diagonal elements are not used but are set to zero unless quick return.\n\n@param[in]\nldc    [int]\nldc specifies the first dimension of C. ldc >= max( 1, n ).\n\n@param[inout]\nstrideC  [hipblasStride]\nstride from the start of one matrix (C_i) and the next one (C_i+1)\n\n@param[in]\nbatchCount [int]\nnumber of instances in the batch.\n"]
    pub fn hipblasCherkxStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        alpha: *const hipblasComplex,
        AP: *const hipblasComplex,
        lda: ::std::os::raw::c_int,
        strideA: hipblasStride,
        BP: *const hipblasComplex,
        ldb: ::std::os::raw::c_int,
        strideB: hipblasStride,
        beta: *const f32,
        CP: *mut hipblasComplex,
        ldc: ::std::os::raw::c_int,
        strideC: hipblasStride,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZherkxStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        alpha: *const hipblasDoubleComplex,
        AP: *const hipblasDoubleComplex,
        lda: ::std::os::raw::c_int,
        strideA: hipblasStride,
        BP: *const hipblasDoubleComplex,
        ldb: ::std::os::raw::c_int,
        strideB: hipblasStride,
        beta: *const f64,
        CP: *mut hipblasDoubleComplex,
        ldc: ::std::os::raw::c_int,
        strideC: hipblasStride,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCherkxStridedBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        alpha: *const hipComplex,
        AP: *const hipComplex,
        lda: ::std::os::raw::c_int,
        strideA: hipblasStride,
        BP: *const hipComplex,
        ldb: ::std::os::raw::c_int,
        strideB: hipblasStride,
        beta: *const f32,
        CP: *mut hipComplex,
        ldc: ::std::os::raw::c_int,
        strideC: hipblasStride,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZherkxStridedBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        alpha: *const hipDoubleComplex,
        AP: *const hipDoubleComplex,
        lda: ::std::os::raw::c_int,
        strideA: hipblasStride,
        BP: *const hipDoubleComplex,
        ldb: ::std::os::raw::c_int,
        strideB: hipblasStride,
        beta: *const f64,
        CP: *mut hipDoubleComplex,
        ldc: ::std::os::raw::c_int,
        strideC: hipblasStride,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 3 API\n\n\\details\n\nher2k performs one of the matrix-matrix operations for a Hermitian rank-2k update\n\nC := alpha*op( A )*op( B )^H + conj(alpha)*op( B )*op( A )^H + beta*C\n\nwhere  alpha and beta are scalars, op(A) and op(B) are n by k matrices, and\nC is a n x n Hermitian matrix stored as either upper or lower.\n\nop( A ) = A, op( B ) = B, and A and B are n by k if trans == HIPBLAS_OP_N\nop( A ) = A^H, op( B ) = B^H,  and A and B are k by n if trans == HIPBLAS_OP_C\n\n- Supported precisions in rocBLAS : c,z\n- Supported precisions in cuBLAS  : c,z\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n\n@param[in]\nuplo    [hipblasFillMode_t]\nHIPBLAS_FILL_MODE_UPPER:  C is an upper triangular matrix\nHIPBLAS_FILL_MODE_LOWER:  C is a  lower triangular matrix\n\n@param[in]\ntransA  [hipblasOperation_t]\nHIPBLAS_OP_C:  op( A ) = A^H, op( B ) = B^H\nHIPBLAS_OP_N:  op( A ) = A, op( B ) = B\n\n@param[in]\nn       [int]\nn specifies the number of rows and columns of C. n >= 0.\n\n@param[in]\nk       [int]\nk specifies the number of columns of op(A). k >= 0.\n\n@param[in]\nalpha\nalpha specifies the scalar alpha. When alpha is\nzero then A is not referenced and A need not be set before\nentry.\n\n@param[in]\nAP       pointer storing matrix A on the GPU.\nMartrix dimension is ( lda, k ) when if trans = HIPBLAS_OP_N, otherwise (lda, n)\nonly the upper/lower triangular part is accessed.\n\n@param[in]\nlda     [int]\nlda specifies the first dimension of A.\nif trans = HIPBLAS_OP_N,  lda >= max( 1, n ),\notherwise lda >= max( 1, k ).\n@param[in]\nBP       pointer storing matrix B on the GPU.\nMartrix dimension is ( ldb, k ) when if trans = HIPBLAS_OP_N, otherwise (ldb, n)\nonly the upper/lower triangular part is accessed.\n\n@param[in]\nldb     [int]\nldb specifies the first dimension of B.\nif trans = HIPBLAS_OP_N,  ldb >= max( 1, n ),\notherwise ldb >= max( 1, k ).\n@param[in]\nbeta\nbeta specifies the scalar beta. When beta is\nzero then C need not be set before entry.\n\n@param[in]\nCP       pointer storing matrix C on the GPU.\nThe imaginary component of the diagonal elements are not used but are set to zero unless quick return.\n\n@param[in]\nldc    [int]\nldc specifies the first dimension of C. ldc >= max( 1, n ).\n"]
    pub fn hipblasCher2k(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        alpha: *const hipblasComplex,
        AP: *const hipblasComplex,
        lda: ::std::os::raw::c_int,
        BP: *const hipblasComplex,
        ldb: ::std::os::raw::c_int,
        beta: *const f32,
        CP: *mut hipblasComplex,
        ldc: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZher2k(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        alpha: *const hipblasDoubleComplex,
        AP: *const hipblasDoubleComplex,
        lda: ::std::os::raw::c_int,
        BP: *const hipblasDoubleComplex,
        ldb: ::std::os::raw::c_int,
        beta: *const f64,
        CP: *mut hipblasDoubleComplex,
        ldc: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCher2k_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        alpha: *const hipComplex,
        AP: *const hipComplex,
        lda: ::std::os::raw::c_int,
        BP: *const hipComplex,
        ldb: ::std::os::raw::c_int,
        beta: *const f32,
        CP: *mut hipComplex,
        ldc: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZher2k_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        alpha: *const hipDoubleComplex,
        AP: *const hipDoubleComplex,
        lda: ::std::os::raw::c_int,
        BP: *const hipDoubleComplex,
        ldb: ::std::os::raw::c_int,
        beta: *const f64,
        CP: *mut hipDoubleComplex,
        ldc: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 3 API\n\n\\details\n\nher2kBatched performs a batch of the matrix-matrix operations for a Hermitian rank-2k update\n\nC_i := alpha*op( A_i )*op( B_i )^H + conj(alpha)*op( B_i )*op( A_i )^H + beta*C_i\n\nwhere  alpha and beta are scalars, op(A_i) and op(B_i) are n by k matrices, and\nC_i is a n x n Hermitian matrix stored as either upper or lower.\n\nop( A_i ) = A_i, op( B_i ) = B_i, and A_i and B_i are n by k if trans == HIPBLAS_OP_N\nop( A_i ) = A_i^H, op( B_i ) = B_i^H,  and A_i and B_i are k by n if trans == HIPBLAS_OP_C\n\n- Supported precisions in rocBLAS : c,z\n- Supported precisions in cuBLAS  : No support\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n\n@param[in]\nuplo    [hipblasFillMode_t]\nHIPBLAS_FILL_MODE_UPPER:  C_i is an upper triangular matrix\nHIPBLAS_FILL_MODE_LOWER:  C_i is a  lower triangular matrix\n\n@param[in]\ntransA  [hipblasOperation_t]\nHIPBLAS_OP_C: op(A) = A^H\nHIPBLAS_OP_N: op(A) = A\n\n@param[in]\nn       [int]\nn specifies the number of rows and columns of C_i. n >= 0.\n\n@param[in]\nk       [int]\nk specifies the number of columns of op(A). k >= 0.\n\n@param[in]\nalpha\nalpha specifies the scalar alpha. When alpha is\nzero then A is not referenced and A need not be set before\nentry.\n\n@param[in]\nAP       device array of device pointers storing each matrix_i A of dimension (lda, k)\nwhen trans is HIPBLAS_OP_N, otherwise of dimension (lda, n)\n\n@param[in]\nlda     [int]\nlda specifies the first dimension of A_i.\nif trans = HIPBLAS_OP_N,  lda >= max( 1, n ),\notherwise lda >= max( 1, k ).\n@param[in]\nBP       device array of device pointers storing each matrix_i B of dimension (ldb, k)\nwhen trans is HIPBLAS_OP_N, otherwise of dimension (ldb, n)\n\n@param[in]\nldb     [int]\nldb specifies the first dimension of B_i.\nif trans = HIPBLAS_OP_N,  ldb >= max( 1, n ),\notherwise ldb >= max( 1, k ).\n@param[in]\nbeta\nbeta specifies the scalar beta. When beta is\nzero then C need not be set before entry.\n\n@param[in]\nCP       device array of device pointers storing each matrix C_i on the GPU.\nThe imaginary component of the diagonal elements are not used but are set to zero unless quick return.\n\n@param[in]\nldc    [int]\nldc specifies the first dimension of C. ldc >= max( 1, n ).\n@param[in]\nbatchCount [int]\nnumber of instances in the batch.\n"]
    pub fn hipblasCher2kBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        alpha: *const hipblasComplex,
        AP: *const *const hipblasComplex,
        lda: ::std::os::raw::c_int,
        BP: *const *const hipblasComplex,
        ldb: ::std::os::raw::c_int,
        beta: *const f32,
        CP: *const *mut hipblasComplex,
        ldc: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZher2kBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        alpha: *const hipblasDoubleComplex,
        AP: *const *const hipblasDoubleComplex,
        lda: ::std::os::raw::c_int,
        BP: *const *const hipblasDoubleComplex,
        ldb: ::std::os::raw::c_int,
        beta: *const f64,
        CP: *const *mut hipblasDoubleComplex,
        ldc: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCher2kBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        alpha: *const hipComplex,
        AP: *const *const hipComplex,
        lda: ::std::os::raw::c_int,
        BP: *const *const hipComplex,
        ldb: ::std::os::raw::c_int,
        beta: *const f32,
        CP: *const *mut hipComplex,
        ldc: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZher2kBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        alpha: *const hipDoubleComplex,
        AP: *const *const hipDoubleComplex,
        lda: ::std::os::raw::c_int,
        BP: *const *const hipDoubleComplex,
        ldb: ::std::os::raw::c_int,
        beta: *const f64,
        CP: *const *mut hipDoubleComplex,
        ldc: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 3 API\n\n\\details\n\nher2kStridedBatched performs a batch of the matrix-matrix operations for a Hermitian rank-2k update\n\nC_i := alpha*op( A_i )*op( B_i )^H + conj(alpha)*op( B_i )*op( A_i )^H + beta*C_i\n\nwhere  alpha and beta are scalars, op(A_i) and op(B_i) are n by k matrices, and\nC_i is a n x n Hermitian matrix stored as either upper or lower.\n\nop( A_i ) = A_i, op( B_i ) = B_i, and A_i and B_i are n by k if trans == HIPBLAS_OP_N\nop( A_i ) = A_i^H, op( B_i ) = B_i^H,  and A_i and B_i are k by n if trans == HIPBLAS_OP_C\n\n- Supported precisions in rocBLAS : c,z\n- Supported precisions in cuBLAS  : No support\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n\n@param[in]\nuplo    [hipblasFillMode_t]\nHIPBLAS_FILL_MODE_UPPER:  C_i is an upper triangular matrix\nHIPBLAS_FILL_MODE_LOWER:  C_i is a  lower triangular matrix\n\n@param[in]\ntransA  [hipblasOperation_t]\nHIPBLAS_OP_C: op( A_i ) = A_i^H, op( B_i ) = B_i^H\nHIPBLAS_OP_N: op( A_i ) = A_i, op( B_i ) = B_i\n\n@param[in]\nn       [int]\nn specifies the number of rows and columns of C_i. n >= 0.\n\n@param[in]\nk       [int]\nk specifies the number of columns of op(A). k >= 0.\n\n@param[in]\nalpha\nalpha specifies the scalar alpha. When alpha is\nzero then A is not referenced and A need not be set before\nentry.\n\n@param[in]\nAP       Device pointer to the first matrix A_1 on the GPU of dimension (lda, k)\nwhen trans is HIPBLAS_OP_N, otherwise of dimension (lda, n)\n\n@param[in]\nlda     [int]\nlda specifies the first dimension of A_i.\nif trans = HIPBLAS_OP_N,  lda >= max( 1, n ),\notherwise lda >= max( 1, k ).\n\n@param[in]\nstrideA  [hipblasStride]\nstride from the start of one matrix (A_i) and the next one (A_i+1)\n\n@param[in]\nBP       Device pointer to the first matrix B_1 on the GPU of dimension (ldb, k)\nwhen trans is HIPBLAS_OP_N, otherwise of dimension (ldb, n)\n\n@param[in]\nldb     [int]\nldb specifies the first dimension of B_i.\nif trans = HIPBLAS_OP_N,  ldb >= max( 1, n ),\notherwise ldb >= max( 1, k ).\n\n@param[in]\nstrideB  [hipblasStride]\nstride from the start of one matrix (B_i) and the next one (B_i+1)\n\n@param[in]\nbeta\nbeta specifies the scalar beta. When beta is\nzero then C need not be set before entry.\n\n@param[in]\nCP       Device pointer to the first matrix C_1 on the GPU.\nThe imaginary component of the diagonal elements are not used but are set to zero unless quick return.\n\n@param[in]\nldc    [int]\nldc specifies the first dimension of C. ldc >= max( 1, n ).\n\n@param[inout]\nstrideC  [hipblasStride]\nstride from the start of one matrix (C_i) and the next one (C_i+1)\n\n@param[in]\nbatchCount [int]\nnumber of instances in the batch.\n"]
    pub fn hipblasCher2kStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        alpha: *const hipblasComplex,
        AP: *const hipblasComplex,
        lda: ::std::os::raw::c_int,
        strideA: hipblasStride,
        BP: *const hipblasComplex,
        ldb: ::std::os::raw::c_int,
        strideB: hipblasStride,
        beta: *const f32,
        CP: *mut hipblasComplex,
        ldc: ::std::os::raw::c_int,
        strideC: hipblasStride,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZher2kStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        alpha: *const hipblasDoubleComplex,
        AP: *const hipblasDoubleComplex,
        lda: ::std::os::raw::c_int,
        strideA: hipblasStride,
        BP: *const hipblasDoubleComplex,
        ldb: ::std::os::raw::c_int,
        strideB: hipblasStride,
        beta: *const f64,
        CP: *mut hipblasDoubleComplex,
        ldc: ::std::os::raw::c_int,
        strideC: hipblasStride,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCher2kStridedBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        alpha: *const hipComplex,
        AP: *const hipComplex,
        lda: ::std::os::raw::c_int,
        strideA: hipblasStride,
        BP: *const hipComplex,
        ldb: ::std::os::raw::c_int,
        strideB: hipblasStride,
        beta: *const f32,
        CP: *mut hipComplex,
        ldc: ::std::os::raw::c_int,
        strideC: hipblasStride,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZher2kStridedBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        alpha: *const hipDoubleComplex,
        AP: *const hipDoubleComplex,
        lda: ::std::os::raw::c_int,
        strideA: hipblasStride,
        BP: *const hipDoubleComplex,
        ldb: ::std::os::raw::c_int,
        strideB: hipblasStride,
        beta: *const f64,
        CP: *mut hipDoubleComplex,
        ldc: ::std::os::raw::c_int,
        strideC: hipblasStride,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 3 API\n\n\\details\n\nsymm performs one of the matrix-matrix operations:\n\nC := alpha*A*B + beta*C if side == HIPBLAS_SIDE_LEFT,\nC := alpha*B*A + beta*C if side == HIPBLAS_SIDE_RIGHT,\n\nwhere alpha and beta are scalars, B and C are m by n matrices, and\nA is a symmetric matrix stored as either upper or lower.\n\n- Supported precisions in rocBLAS : s,d,c,z\n- Supported precisions in cuBLAS  : s,d,c,z\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n\n@param[in]\nside  [hipblasSideMode_t]\nHIPBLAS_SIDE_LEFT:      C := alpha*A*B + beta*C\nHIPBLAS_SIDE_RIGHT:     C := alpha*B*A + beta*C\n\n@param[in]\nuplo    [hipblasFillMode_t]\nHIPBLAS_FILL_MODE_UPPER:  A is an upper triangular matrix\nHIPBLAS_FILL_MODE_LOWER:  A is a  lower triangular matrix\n\n@param[in]\nm       [int]\nm specifies the number of rows of B and C. m >= 0.\n\n@param[in]\nn       [int]\nn specifies the number of columns of B and C. n >= 0.\n\n@param[in]\nalpha\nalpha specifies the scalar alpha. When alpha is\nzero then A and B are not referenced.\n\n@param[in]\nAP       pointer storing matrix A on the GPU.\nA is m by m if side == HIPBLAS_SIDE_LEFT\nA is n by n if side == HIPBLAS_SIDE_RIGHT\nonly the upper/lower triangular part is accessed.\n\n@param[in]\nlda     [int]\nlda specifies the first dimension of A.\nif side = HIPBLAS_SIDE_LEFT,  lda >= max( 1, m ),\notherwise lda >= max( 1, n ).\n\n@param[in]\nBP       pointer storing matrix B on the GPU.\nMatrix dimension is m by n\n\n@param[in]\nldb     [int]\nldb specifies the first dimension of B. ldb >= max( 1, m )\n\n@param[in]\nbeta\nbeta specifies the scalar beta. When beta is\nzero then C need not be set before entry.\n\n@param[in]\nCP       pointer storing matrix C on the GPU.\nMatrix dimension is m by n\n\n@param[in]\nldc    [int]\nldc specifies the first dimension of C. ldc >= max( 1, m )\n"]
    pub fn hipblasSsymm(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        alpha: *const f32,
        AP: *const f32,
        lda: ::std::os::raw::c_int,
        BP: *const f32,
        ldb: ::std::os::raw::c_int,
        beta: *const f32,
        CP: *mut f32,
        ldc: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDsymm(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        alpha: *const f64,
        AP: *const f64,
        lda: ::std::os::raw::c_int,
        BP: *const f64,
        ldb: ::std::os::raw::c_int,
        beta: *const f64,
        CP: *mut f64,
        ldc: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsymm(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        alpha: *const hipblasComplex,
        AP: *const hipblasComplex,
        lda: ::std::os::raw::c_int,
        BP: *const hipblasComplex,
        ldb: ::std::os::raw::c_int,
        beta: *const hipblasComplex,
        CP: *mut hipblasComplex,
        ldc: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZsymm(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        alpha: *const hipblasDoubleComplex,
        AP: *const hipblasDoubleComplex,
        lda: ::std::os::raw::c_int,
        BP: *const hipblasDoubleComplex,
        ldb: ::std::os::raw::c_int,
        beta: *const hipblasDoubleComplex,
        CP: *mut hipblasDoubleComplex,
        ldc: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsymm_v2(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        alpha: *const hipComplex,
        AP: *const hipComplex,
        lda: ::std::os::raw::c_int,
        BP: *const hipComplex,
        ldb: ::std::os::raw::c_int,
        beta: *const hipComplex,
        CP: *mut hipComplex,
        ldc: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZsymm_v2(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        alpha: *const hipDoubleComplex,
        AP: *const hipDoubleComplex,
        lda: ::std::os::raw::c_int,
        BP: *const hipDoubleComplex,
        ldb: ::std::os::raw::c_int,
        beta: *const hipDoubleComplex,
        CP: *mut hipDoubleComplex,
        ldc: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 3 API\n\n\\details\n\nsymmBatched performs a batch of the matrix-matrix operations:\n\nC_i := alpha*A_i*B_i + beta*C_i if side == HIPBLAS_SIDE_LEFT,\nC_i := alpha*B_i*A_i + beta*C_i if side == HIPBLAS_SIDE_RIGHT,\n\nwhere alpha and beta are scalars, B_i and C_i are m by n matrices, and\nA_i is a symmetric matrix stored as either upper or lower.\n\n- Supported precisions in rocBLAS : s,d,c,z\n- Supported precisions in cuBLAS  : No support\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n\n@param[in]\nside  [hipblasSideMode_t]\nHIPBLAS_SIDE_LEFT:      C_i := alpha*A_i*B_i + beta*C_i\nHIPBLAS_SIDE_RIGHT:     C_i := alpha*B_i*A_i + beta*C_i\n\n@param[in]\nuplo    [hipblasFillMode_t]\nHIPBLAS_FILL_MODE_UPPER:  A_i is an upper triangular matrix\nHIPBLAS_FILL_MODE_LOWER:  A_i is a  lower triangular matrix\n\n@param[in]\nm       [int]\nm specifies the number of rows of B_i and C_i. m >= 0.\n\n@param[in]\nn       [int]\nn specifies the number of columns of B_i and C_i. n >= 0.\n\n@param[in]\nalpha\nalpha specifies the scalar alpha. When alpha is\nzero then A_i and B_i are not referenced.\n\n@param[in]\nAP      device array of device pointers storing each matrix A_i on the GPU.\nA_i is m by m if side == HIPBLAS_SIDE_LEFT\nA_i is n by n if side == HIPBLAS_SIDE_RIGHT\nonly the upper/lower triangular part is accessed.\n\n@param[in]\nlda     [int]\nlda specifies the first dimension of A_i.\nif side = HIPBLAS_SIDE_LEFT,  lda >= max( 1, m ),\notherwise lda >= max( 1, n ).\n\n@param[in]\nBP       device array of device pointers storing each matrix B_i on the GPU.\nMatrix dimension is m by n\n\n@param[in]\nldb     [int]\nldb specifies the first dimension of B_i. ldb >= max( 1, m )\n\n@param[in]\nbeta\nbeta specifies the scalar beta. When beta is\nzero then C_i need not be set before entry.\n\n@param[in]\nCP       device array of device pointers storing each matrix C_i on the GPU.\nMatrix dimension is m by n\n\n@param[in]\nldc    [int]\nldc specifies the first dimension of C_i. ldc >= max( 1, m )\n\n@param[in]\nbatchCount [int]\nnumber of instances in the batch.\n"]
    pub fn hipblasSsymmBatched(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        alpha: *const f32,
        AP: *const *const f32,
        lda: ::std::os::raw::c_int,
        BP: *const *const f32,
        ldb: ::std::os::raw::c_int,
        beta: *const f32,
        CP: *const *mut f32,
        ldc: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDsymmBatched(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        alpha: *const f64,
        AP: *const *const f64,
        lda: ::std::os::raw::c_int,
        BP: *const *const f64,
        ldb: ::std::os::raw::c_int,
        beta: *const f64,
        CP: *const *mut f64,
        ldc: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsymmBatched(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        alpha: *const hipblasComplex,
        AP: *const *const hipblasComplex,
        lda: ::std::os::raw::c_int,
        BP: *const *const hipblasComplex,
        ldb: ::std::os::raw::c_int,
        beta: *const hipblasComplex,
        CP: *const *mut hipblasComplex,
        ldc: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZsymmBatched(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        alpha: *const hipblasDoubleComplex,
        AP: *const *const hipblasDoubleComplex,
        lda: ::std::os::raw::c_int,
        BP: *const *const hipblasDoubleComplex,
        ldb: ::std::os::raw::c_int,
        beta: *const hipblasDoubleComplex,
        CP: *const *mut hipblasDoubleComplex,
        ldc: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsymmBatched_v2(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        alpha: *const hipComplex,
        AP: *const *const hipComplex,
        lda: ::std::os::raw::c_int,
        BP: *const *const hipComplex,
        ldb: ::std::os::raw::c_int,
        beta: *const hipComplex,
        CP: *const *mut hipComplex,
        ldc: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZsymmBatched_v2(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        alpha: *const hipDoubleComplex,
        AP: *const *const hipDoubleComplex,
        lda: ::std::os::raw::c_int,
        BP: *const *const hipDoubleComplex,
        ldb: ::std::os::raw::c_int,
        beta: *const hipDoubleComplex,
        CP: *const *mut hipDoubleComplex,
        ldc: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 3 API\n\n\\details\n\nsymmStridedBatched performs a batch of the matrix-matrix operations:\n\nC_i := alpha*A_i*B_i + beta*C_i if side == HIPBLAS_SIDE_LEFT,\nC_i := alpha*B_i*A_i + beta*C_i if side == HIPBLAS_SIDE_RIGHT,\n\nwhere alpha and beta are scalars, B_i and C_i are m by n matrices, and\nA_i is a symmetric matrix stored as either upper or lower.\n\n- Supported precisions in rocBLAS : s,d,c,z\n- Supported precisions in cuBLAS  : No support\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n\n@param[in]\nside  [hipblasSideMode_t]\nHIPBLAS_SIDE_LEFT:      C_i := alpha*A_i*B_i + beta*C_i\nHIPBLAS_SIDE_RIGHT:     C_i := alpha*B_i*A_i + beta*C_i\n\n@param[in]\nuplo    [hipblasFillMode_t]\nHIPBLAS_FILL_MODE_UPPER:  A_i is an upper triangular matrix\nHIPBLAS_FILL_MODE_LOWER:  A_i is a  lower triangular matrix\n\n@param[in]\nm       [int]\nm specifies the number of rows of B_i and C_i. m >= 0.\n\n@param[in]\nn       [int]\nn specifies the number of columns of B_i and C_i. n >= 0.\n\n@param[in]\nalpha\nalpha specifies the scalar alpha. When alpha is\nzero then A_i and B_i are not referenced.\n\n@param[in]\nAP       device pointer to first matrix A_1\nA_i is m by m if side == HIPBLAS_SIDE_LEFT\nA_i is n by n if side == HIPBLAS_SIDE_RIGHT\nonly the upper/lower triangular part is accessed.\n\n@param[in]\nlda     [int]\nlda specifies the first dimension of A_i.\nif side = HIPBLAS_SIDE_LEFT,  lda >= max( 1, m ),\notherwise lda >= max( 1, n ).\n\n@param[in]\nstrideA  [hipblasStride]\nstride from the start of one matrix (A_i) and the next one (A_i+1)\n\n@param[in]\nBP       device pointer to first matrix B_1 of dimension (ldb, n) on the GPU.\n\n@param[in]\nldb     [int]\nldb specifies the first dimension of B_i. ldb >= max( 1, m )\n\n@param[in]\nstrideB  [hipblasStride]\nstride from the start of one matrix (B_i) and the next one (B_i+1)\n@param[in]\nbeta\nbeta specifies the scalar beta. When beta is\nzero then C need not be set before entry.\n\n@param[in]\nCP        device pointer to first matrix C_1 of dimension (ldc, n) on the GPU.\n\n@param[in]\nldc    [int]\nldc specifies the first dimension of C. ldc >= max( 1, m ).\n\n@param[inout]\nstrideC  [hipblasStride]\nstride from the start of one matrix (C_i) and the next one (C_i+1)\n\n@param[in]\nbatchCount [int]\nnumber of instances in the batch.\n"]
    pub fn hipblasSsymmStridedBatched(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        alpha: *const f32,
        AP: *const f32,
        lda: ::std::os::raw::c_int,
        strideA: hipblasStride,
        BP: *const f32,
        ldb: ::std::os::raw::c_int,
        strideB: hipblasStride,
        beta: *const f32,
        CP: *mut f32,
        ldc: ::std::os::raw::c_int,
        strideC: hipblasStride,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDsymmStridedBatched(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        alpha: *const f64,
        AP: *const f64,
        lda: ::std::os::raw::c_int,
        strideA: hipblasStride,
        BP: *const f64,
        ldb: ::std::os::raw::c_int,
        strideB: hipblasStride,
        beta: *const f64,
        CP: *mut f64,
        ldc: ::std::os::raw::c_int,
        strideC: hipblasStride,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsymmStridedBatched(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        alpha: *const hipblasComplex,
        AP: *const hipblasComplex,
        lda: ::std::os::raw::c_int,
        strideA: hipblasStride,
        BP: *const hipblasComplex,
        ldb: ::std::os::raw::c_int,
        strideB: hipblasStride,
        beta: *const hipblasComplex,
        CP: *mut hipblasComplex,
        ldc: ::std::os::raw::c_int,
        strideC: hipblasStride,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZsymmStridedBatched(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        alpha: *const hipblasDoubleComplex,
        AP: *const hipblasDoubleComplex,
        lda: ::std::os::raw::c_int,
        strideA: hipblasStride,
        BP: *const hipblasDoubleComplex,
        ldb: ::std::os::raw::c_int,
        strideB: hipblasStride,
        beta: *const hipblasDoubleComplex,
        CP: *mut hipblasDoubleComplex,
        ldc: ::std::os::raw::c_int,
        strideC: hipblasStride,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsymmStridedBatched_v2(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        alpha: *const hipComplex,
        AP: *const hipComplex,
        lda: ::std::os::raw::c_int,
        strideA: hipblasStride,
        BP: *const hipComplex,
        ldb: ::std::os::raw::c_int,
        strideB: hipblasStride,
        beta: *const hipComplex,
        CP: *mut hipComplex,
        ldc: ::std::os::raw::c_int,
        strideC: hipblasStride,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZsymmStridedBatched_v2(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        alpha: *const hipDoubleComplex,
        AP: *const hipDoubleComplex,
        lda: ::std::os::raw::c_int,
        strideA: hipblasStride,
        BP: *const hipDoubleComplex,
        ldb: ::std::os::raw::c_int,
        strideB: hipblasStride,
        beta: *const hipDoubleComplex,
        CP: *mut hipDoubleComplex,
        ldc: ::std::os::raw::c_int,
        strideC: hipblasStride,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 3 API\n\n\\details\n\nsyrk performs one of the matrix-matrix operations for a symmetric rank-k update\n\nC := alpha*op( A )*op( A )^T + beta*C\n\nwhere  alpha and beta are scalars, op(A) is an n by k matrix, and\nC is a symmetric n x n matrix stored as either upper or lower.\n\nop( A ) = A, and A is n by k if transA == HIPBLAS_OP_N\nop( A ) = A^T and A is k by n if transA == HIPBLAS_OP_T\n\n- Supported precisions in rocBLAS : s,d,c,z\n- Supported precisions in cuBLAS  : s,d,c,z\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n\n@param[in]\nuplo    [hipblasFillMode_t]\nHIPBLAS_FILL_MODE_UPPER:  C is an upper triangular matrix\nHIPBLAS_FILL_MODE_LOWER:  C is a  lower triangular matrix\n\n@param[in]\ntransA  [hipblasOperation_t]\nHIPBLAS_OP_T: op(A) = A^T\nHIPBLAS_OP_N: op(A) = A\nHIPBLAS_OP_C: op(A) = A^T\n\nHIPBLAS_OP_C is not supported for complex types, see cherk\nand zherk.\n\n@param[in]\nn       [int]\nn specifies the number of rows and columns of C. n >= 0.\n\n@param[in]\nk       [int]\nk specifies the number of columns of op(A). k >= 0.\n\n@param[in]\nalpha\nalpha specifies the scalar alpha. When alpha is\nzero then A is not referenced and A need not be set before\nentry.\n\n@param[in]\nAP       pointer storing matrix A on the GPU.\nMartrix dimension is ( lda, k ) when if transA = HIPBLAS_OP_N, otherwise (lda, n)\nonly the upper/lower triangular part is accessed.\n\n@param[in]\nlda     [int]\nlda specifies the first dimension of A.\nif transA = HIPBLAS_OP_N,  lda >= max( 1, n ),\notherwise lda >= max( 1, k ).\n\n@param[in]\nbeta\nbeta specifies the scalar beta. When beta is\nzero then C need not be set before entry.\n\n@param[in]\nCP       pointer storing matrix C on the GPU.\n\n@param[in]\nldc    [int]\nldc specifies the first dimension of C. ldc >= max( 1, n ).\n"]
    pub fn hipblasSsyrk(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        alpha: *const f32,
        AP: *const f32,
        lda: ::std::os::raw::c_int,
        beta: *const f32,
        CP: *mut f32,
        ldc: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDsyrk(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        alpha: *const f64,
        AP: *const f64,
        lda: ::std::os::raw::c_int,
        beta: *const f64,
        CP: *mut f64,
        ldc: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsyrk(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        alpha: *const hipblasComplex,
        AP: *const hipblasComplex,
        lda: ::std::os::raw::c_int,
        beta: *const hipblasComplex,
        CP: *mut hipblasComplex,
        ldc: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZsyrk(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        alpha: *const hipblasDoubleComplex,
        AP: *const hipblasDoubleComplex,
        lda: ::std::os::raw::c_int,
        beta: *const hipblasDoubleComplex,
        CP: *mut hipblasDoubleComplex,
        ldc: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsyrk_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        alpha: *const hipComplex,
        AP: *const hipComplex,
        lda: ::std::os::raw::c_int,
        beta: *const hipComplex,
        CP: *mut hipComplex,
        ldc: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZsyrk_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        alpha: *const hipDoubleComplex,
        AP: *const hipDoubleComplex,
        lda: ::std::os::raw::c_int,
        beta: *const hipDoubleComplex,
        CP: *mut hipDoubleComplex,
        ldc: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 3 API\n\n\\details\n\nsyrkBatched performs a batch of the matrix-matrix operations for a symmetric rank-k update\n\nC_i := alpha*op( A_i )*op( A_i )^T + beta*C_i\n\nwhere  alpha and beta are scalars, op(A_i) is an n by k matrix, and\nC_i is a symmetric n x n matrix stored as either upper or lower.\n\nop( A_i ) = A_i, and A_i is n by k if transA == HIPBLAS_OP_N\nop( A_i ) = A_i^T and A_i is k by n if transA == HIPBLAS_OP_T\n\n- Supported precisions in rocBLAS : s,d,c,z\n- Supported precisions in cuBLAS  : No support\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n\n@param[in]\nuplo    [hipblasFillMode_t]\nHIPBLAS_FILL_MODE_UPPER:  C_i is an upper triangular matrix\nHIPBLAS_FILL_MODE_LOWER:  C_i is a  lower triangular matrix\n\n@param[in]\ntransA  [hipblasOperation_t]\nHIPBLAS_OP_T: op(A) = A^T\nHIPBLAS_OP_N: op(A) = A\nHIPBLAS_OP_C: op(A) = A^T\n\nHIPBLAS_OP_C is not supported for complex types, see cherk\nand zherk.\n\n@param[in]\nn       [int]\nn specifies the number of rows and columns of C_i. n >= 0.\n\n@param[in]\nk       [int]\nk specifies the number of columns of op(A). k >= 0.\n\n@param[in]\nalpha\nalpha specifies the scalar alpha. When alpha is\nzero then A is not referenced and A need not be set before\nentry.\n\n@param[in]\nAP       device array of device pointers storing each matrix_i A of dimension (lda, k)\nwhen transA is HIPBLAS_OP_N, otherwise of dimension (lda, n)\n\n@param[in]\nlda     [int]\nlda specifies the first dimension of A_i.\nif transA = HIPBLAS_OP_N,  lda >= max( 1, n ),\notherwise lda >= max( 1, k ).\n\n@param[in]\nbeta\nbeta specifies the scalar beta. When beta is\nzero then C need not be set before entry.\n\n@param[in]\nCP       device array of device pointers storing each matrix C_i on the GPU.\n\n@param[in]\nldc    [int]\nldc specifies the first dimension of C. ldc >= max( 1, n ).\n@param[in]\nbatchCount [int]\nnumber of instances in the batch.\n"]
    pub fn hipblasSsyrkBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        alpha: *const f32,
        AP: *const *const f32,
        lda: ::std::os::raw::c_int,
        beta: *const f32,
        CP: *const *mut f32,
        ldc: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDsyrkBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        alpha: *const f64,
        AP: *const *const f64,
        lda: ::std::os::raw::c_int,
        beta: *const f64,
        CP: *const *mut f64,
        ldc: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsyrkBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        alpha: *const hipblasComplex,
        AP: *const *const hipblasComplex,
        lda: ::std::os::raw::c_int,
        beta: *const hipblasComplex,
        CP: *const *mut hipblasComplex,
        ldc: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZsyrkBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        alpha: *const hipblasDoubleComplex,
        AP: *const *const hipblasDoubleComplex,
        lda: ::std::os::raw::c_int,
        beta: *const hipblasDoubleComplex,
        CP: *const *mut hipblasDoubleComplex,
        ldc: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsyrkBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        alpha: *const hipComplex,
        AP: *const *const hipComplex,
        lda: ::std::os::raw::c_int,
        beta: *const hipComplex,
        CP: *const *mut hipComplex,
        ldc: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZsyrkBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        alpha: *const hipDoubleComplex,
        AP: *const *const hipDoubleComplex,
        lda: ::std::os::raw::c_int,
        beta: *const hipDoubleComplex,
        CP: *const *mut hipDoubleComplex,
        ldc: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 3 API\n\n\\details\n\nsyrkStridedBatched performs a batch of the matrix-matrix operations for a symmetric rank-k update\n\nC_i := alpha*op( A_i )*op( A_i )^T + beta*C_i\n\nwhere  alpha and beta are scalars, op(A_i) is an n by k matrix, and\nC_i is a symmetric n x n matrix stored as either upper or lower.\n\nop( A_i ) = A_i, and A_i is n by k if transA == HIPBLAS_OP_N\nop( A_i ) = A_i^T and A_i is k by n if transA == HIPBLAS_OP_T\n\n- Supported precisions in rocBLAS : s,d,c,z\n- Supported precisions in cuBLAS  : No support\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n\n@param[in]\nuplo    [hipblasFillMode_t]\nHIPBLAS_FILL_MODE_UPPER:  C_i is an upper triangular matrix\nHIPBLAS_FILL_MODE_LOWER:  C_i is a  lower triangular matrix\n\n@param[in]\ntransA  [hipblasOperation_t]\nHIPBLAS_OP_T: op(A) = A^T\nHIPBLAS_OP_N: op(A) = A\nHIPBLAS_OP_C: op(A) = A^T\n\nHIPBLAS_OP_C is not supported for complex types, see cherk\nand zherk.\n\n@param[in]\nn       [int]\nn specifies the number of rows and columns of C_i. n >= 0.\n\n@param[in]\nk       [int]\nk specifies the number of columns of op(A). k >= 0.\n\n@param[in]\nalpha\nalpha specifies the scalar alpha. When alpha is\nzero then A is not referenced and A need not be set before\nentry.\n\n@param[in]\nAP       Device pointer to the first matrix A_1 on the GPU of dimension (lda, k)\nwhen transA is HIPBLAS_OP_N, otherwise of dimension (lda, n)\n\n@param[in]\nlda     [int]\nlda specifies the first dimension of A_i.\nif transA = HIPBLAS_OP_N,  lda >= max( 1, n ),\notherwise lda >= max( 1, k ).\n\n@param[in]\nstrideA  [hipblasStride]\nstride from the start of one matrix (A_i) and the next one (A_i+1)\n\n@param[in]\nbeta\nbeta specifies the scalar beta. When beta is\nzero then C need not be set before entry.\n\n@param[in]\nCP       Device pointer to the first matrix C_1 on the GPU. on the GPU.\n\n@param[in]\nldc    [int]\nldc specifies the first dimension of C. ldc >= max( 1, n ).\n\n@param[inout]\nstrideC  [hipblasStride]\nstride from the start of one matrix (C_i) and the next one (C_i+1)\n\n@param[in]\nbatchCount [int]\nnumber of instances in the batch.\n"]
    pub fn hipblasSsyrkStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        alpha: *const f32,
        AP: *const f32,
        lda: ::std::os::raw::c_int,
        strideA: hipblasStride,
        beta: *const f32,
        CP: *mut f32,
        ldc: ::std::os::raw::c_int,
        strideC: hipblasStride,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDsyrkStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        alpha: *const f64,
        AP: *const f64,
        lda: ::std::os::raw::c_int,
        strideA: hipblasStride,
        beta: *const f64,
        CP: *mut f64,
        ldc: ::std::os::raw::c_int,
        strideC: hipblasStride,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsyrkStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        alpha: *const hipblasComplex,
        AP: *const hipblasComplex,
        lda: ::std::os::raw::c_int,
        strideA: hipblasStride,
        beta: *const hipblasComplex,
        CP: *mut hipblasComplex,
        ldc: ::std::os::raw::c_int,
        strideC: hipblasStride,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZsyrkStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        alpha: *const hipblasDoubleComplex,
        AP: *const hipblasDoubleComplex,
        lda: ::std::os::raw::c_int,
        strideA: hipblasStride,
        beta: *const hipblasDoubleComplex,
        CP: *mut hipblasDoubleComplex,
        ldc: ::std::os::raw::c_int,
        strideC: hipblasStride,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsyrkStridedBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        alpha: *const hipComplex,
        AP: *const hipComplex,
        lda: ::std::os::raw::c_int,
        strideA: hipblasStride,
        beta: *const hipComplex,
        CP: *mut hipComplex,
        ldc: ::std::os::raw::c_int,
        strideC: hipblasStride,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZsyrkStridedBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        alpha: *const hipDoubleComplex,
        AP: *const hipDoubleComplex,
        lda: ::std::os::raw::c_int,
        strideA: hipblasStride,
        beta: *const hipDoubleComplex,
        CP: *mut hipDoubleComplex,
        ldc: ::std::os::raw::c_int,
        strideC: hipblasStride,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 3 API\n\n\\details\n\nsyr2k performs one of the matrix-matrix operations for a symmetric rank-2k update\n\nC := alpha*(op( A )*op( B )^T + op( B )*op( A )^T) + beta*C\n\nwhere  alpha and beta are scalars, op(A) and op(B) are n by k matrix, and\nC is a symmetric n x n matrix stored as either upper or lower.\n\nop( A ) = A, op( B ) = B, and A and B are n by k if trans == HIPBLAS_OP_N\nop( A ) = A^T, op( B ) = B^T,  and A and B are k by n if trans == HIPBLAS_OP_T\n\n- Supported precisions in rocBLAS : s,d,c,z\n- Supported precisions in cuBLAS  : s,d,c,z\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n\n@param[in]\nuplo    [hipblasFillMode_t]\nHIPBLAS_FILL_MODE_UPPER:  C is an upper triangular matrix\nHIPBLAS_FILL_MODE_LOWER:  C is a  lower triangular matrix\n\n@param[in]\ntransA  [hipblasOperation_t]\nHIPBLAS_OP_T:      op( A ) = A^T, op( B ) = B^T\nHIPBLAS_OP_N:           op( A ) = A, op( B ) = B\n\n@param[in]\nn       [int]\nn specifies the number of rows and columns of C. n >= 0.\n\n@param[in]\nk       [int]\nk specifies the number of columns of op(A) and op(B). k >= 0.\n\n@param[in]\nalpha\nalpha specifies the scalar alpha. When alpha is\nzero then A is not referenced and A need not be set before\nentry.\n\n@param[in]\nAP       pointer storing matrix A on the GPU.\nMartrix dimension is ( lda, k ) when if trans = HIPBLAS_OP_N, otherwise (lda, n)\nonly the upper/lower triangular part is accessed.\n\n@param[in]\nlda     [int]\nlda specifies the first dimension of A.\nif trans = HIPBLAS_OP_N,  lda >= max( 1, n ),\notherwise lda >= max( 1, k ).\n@param[in]\nBP       pointer storing matrix B on the GPU.\nMartrix dimension is ( ldb, k ) when if trans = HIPBLAS_OP_N, otherwise (ldb, n)\nonly the upper/lower triangular part is accessed.\n\n@param[in]\nldb     [int]\nldb specifies the first dimension of B.\nif trans = HIPBLAS_OP_N,  ldb >= max( 1, n ),\notherwise ldb >= max( 1, k ).\n@param[in]\nbeta\nbeta specifies the scalar beta. When beta is\nzero then C need not be set before entry.\n\n@param[in]\nCP       pointer storing matrix C on the GPU.\n\n@param[in]\nldc    [int]\nldc specifies the first dimension of C. ldc >= max( 1, n ).\n"]
    pub fn hipblasSsyr2k(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        alpha: *const f32,
        AP: *const f32,
        lda: ::std::os::raw::c_int,
        BP: *const f32,
        ldb: ::std::os::raw::c_int,
        beta: *const f32,
        CP: *mut f32,
        ldc: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDsyr2k(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        alpha: *const f64,
        AP: *const f64,
        lda: ::std::os::raw::c_int,
        BP: *const f64,
        ldb: ::std::os::raw::c_int,
        beta: *const f64,
        CP: *mut f64,
        ldc: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsyr2k(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        alpha: *const hipblasComplex,
        AP: *const hipblasComplex,
        lda: ::std::os::raw::c_int,
        BP: *const hipblasComplex,
        ldb: ::std::os::raw::c_int,
        beta: *const hipblasComplex,
        CP: *mut hipblasComplex,
        ldc: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZsyr2k(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        alpha: *const hipblasDoubleComplex,
        AP: *const hipblasDoubleComplex,
        lda: ::std::os::raw::c_int,
        BP: *const hipblasDoubleComplex,
        ldb: ::std::os::raw::c_int,
        beta: *const hipblasDoubleComplex,
        CP: *mut hipblasDoubleComplex,
        ldc: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsyr2k_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        alpha: *const hipComplex,
        AP: *const hipComplex,
        lda: ::std::os::raw::c_int,
        BP: *const hipComplex,
        ldb: ::std::os::raw::c_int,
        beta: *const hipComplex,
        CP: *mut hipComplex,
        ldc: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZsyr2k_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        alpha: *const hipDoubleComplex,
        AP: *const hipDoubleComplex,
        lda: ::std::os::raw::c_int,
        BP: *const hipDoubleComplex,
        ldb: ::std::os::raw::c_int,
        beta: *const hipDoubleComplex,
        CP: *mut hipDoubleComplex,
        ldc: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 3 API\n\n\\details\n\nsyr2kBatched performs a batch of the matrix-matrix operations for a symmetric rank-2k update\n\nC_i := alpha*(op( A_i )*op( B_i )^T + op( B_i )*op( A_i )^T) + beta*C_i\n\nwhere  alpha and beta are scalars, op(A_i) and op(B_i) are n by k matrix, and\nC_i is a symmetric n x n matrix stored as either upper or lower.\n\nop( A_i ) = A_i, op( B_i ) = B_i, and A_i and B_i are n by k if trans == HIPBLAS_OP_N\nop( A_i ) = A_i^T, op( B_i ) = B_i^T,  and A_i and B_i are k by n if trans == HIPBLAS_OP_T\n\n- Supported precisions in rocBLAS : s,d,c,z\n- Supported precisions in cuBLAS  : No support\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n\n@param[in]\nuplo    [hipblasFillMode_t]\nHIPBLAS_FILL_MODE_UPPER:  C_i is an upper triangular matrix\nHIPBLAS_FILL_MODE_LOWER:  C_i is a  lower triangular matrix\n\n@param[in]\ntransA  [hipblasOperation_t]\nHIPBLAS_OP_T:      op( A_i ) = A_i^T, op( B_i ) = B_i^T\nHIPBLAS_OP_N:           op( A_i ) = A_i, op( B_i ) = B_i\n\n@param[in]\nn       [int]\nn specifies the number of rows and columns of C_i. n >= 0.\n\n@param[in]\nk       [int]\nk specifies the number of columns of op(A). k >= 0.\n\n@param[in]\nalpha\nalpha specifies the scalar alpha. When alpha is\nzero then A is not referenced and A need not be set before\nentry.\n\n@param[in]\nAP       device array of device pointers storing each matrix_i A of dimension (lda, k)\nwhen trans is HIPBLAS_OP_N, otherwise of dimension (lda, n)\n\n@param[in]\nlda     [int]\nlda specifies the first dimension of A_i.\nif trans = HIPBLAS_OP_N,  lda >= max( 1, n ),\notherwise lda >= max( 1, k ).\n@param[in]\nBP      device array of device pointers storing each matrix_i B of dimension (ldb, k)\nwhen trans is HIPBLAS_OP_N, otherwise of dimension (ldb, n)\n@param[in]\nldb     [int]\nldb specifies the first dimension of B.\nif trans = HIPBLAS_OP_N,  ldb >= max( 1, n ),\notherwise ldb >= max( 1, k ).\n@param[in]\nbeta\nbeta specifies the scalar beta. When beta is\nzero then C need not be set before entry.\n\n@param[in]\nCP      device array of device pointers storing each matrix C_i on the GPU.\n\n@param[in]\nldc    [int]\nldc specifies the first dimension of C. ldc >= max( 1, n ).\n@param[in]\nbatchCount [int]\nnumber of instances in the batch.\n"]
    pub fn hipblasSsyr2kBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        alpha: *const f32,
        AP: *const *const f32,
        lda: ::std::os::raw::c_int,
        BP: *const *const f32,
        ldb: ::std::os::raw::c_int,
        beta: *const f32,
        CP: *const *mut f32,
        ldc: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDsyr2kBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        alpha: *const f64,
        AP: *const *const f64,
        lda: ::std::os::raw::c_int,
        BP: *const *const f64,
        ldb: ::std::os::raw::c_int,
        beta: *const f64,
        CP: *const *mut f64,
        ldc: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsyr2kBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        alpha: *const hipblasComplex,
        AP: *const *const hipblasComplex,
        lda: ::std::os::raw::c_int,
        BP: *const *const hipblasComplex,
        ldb: ::std::os::raw::c_int,
        beta: *const hipblasComplex,
        CP: *const *mut hipblasComplex,
        ldc: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZsyr2kBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        alpha: *const hipblasDoubleComplex,
        AP: *const *const hipblasDoubleComplex,
        lda: ::std::os::raw::c_int,
        BP: *const *const hipblasDoubleComplex,
        ldb: ::std::os::raw::c_int,
        beta: *const hipblasDoubleComplex,
        CP: *const *mut hipblasDoubleComplex,
        ldc: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsyr2kBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        alpha: *const hipComplex,
        AP: *const *const hipComplex,
        lda: ::std::os::raw::c_int,
        BP: *const *const hipComplex,
        ldb: ::std::os::raw::c_int,
        beta: *const hipComplex,
        CP: *const *mut hipComplex,
        ldc: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZsyr2kBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        alpha: *const hipDoubleComplex,
        AP: *const *const hipDoubleComplex,
        lda: ::std::os::raw::c_int,
        BP: *const *const hipDoubleComplex,
        ldb: ::std::os::raw::c_int,
        beta: *const hipDoubleComplex,
        CP: *const *mut hipDoubleComplex,
        ldc: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 3 API\n\n\\details\n\nsyr2kStridedBatched performs a batch of the matrix-matrix operations for a symmetric rank-2k update\n\nC_i := alpha*(op( A_i )*op( B_i )^T + op( B_i )*op( A_i )^T) + beta*C_i\n\nwhere  alpha and beta are scalars, op(A_i) and op(B_i) are n by k matrix, and\nC_i is a symmetric n x n matrix stored as either upper or lower.\n\nop( A_i ) = A_i, op( B_i ) = B_i, and A_i and B_i are n by k if trans == HIPBLAS_OP_N\nop( A_i ) = A_i^T, op( B_i ) = B_i^T,  and A_i and B_i are k by n if trans == HIPBLAS_OP_T\n\n- Supported precisions in rocBLAS : s,d,c,z\n- Supported precisions in cuBLAS  : No support\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n\n@param[in]\nuplo    [hipblasFillMode_t]\nHIPBLAS_FILL_MODE_UPPER:  C_i is an upper triangular matrix\nHIPBLAS_FILL_MODE_LOWER:  C_i is a  lower triangular matrix\n\n@param[in]\ntransA  [hipblasOperation_t]\nHIPBLAS_OP_T:      op( A_i ) = A_i^T, op( B_i ) = B_i^T\nHIPBLAS_OP_N:           op( A_i ) = A_i, op( B_i ) = B_i\n\n@param[in]\nn       [int]\nn specifies the number of rows and columns of C_i. n >= 0.\n\n@param[in]\nk       [int]\nk specifies the number of columns of op(A). k >= 0.\n\n@param[in]\nalpha\nalpha specifies the scalar alpha. When alpha is\nzero then A is not referenced and A need not be set before\nentry.\n\n@param[in]\nAP       Device pointer to the first matrix A_1 on the GPU of dimension (lda, k)\nwhen trans is HIPBLAS_OP_N, otherwise of dimension (lda, n)\n\n@param[in]\nlda     [int]\nlda specifies the first dimension of A_i.\nif trans = HIPBLAS_OP_N,  lda >= max( 1, n ),\notherwise lda >= max( 1, k ).\n\n@param[in]\nstrideA  [hipblasStride]\nstride from the start of one matrix (A_i) and the next one (A_i+1)\n\n@param[in]\nBP       Device pointer to the first matrix B_1 on the GPU of dimension (ldb, k)\nwhen trans is HIPBLAS_OP_N, otherwise of dimension (ldb, n)\n\n@param[in]\nldb     [int]\nldb specifies the first dimension of B_i.\nif trans = HIPBLAS_OP_N,  ldb >= max( 1, n ),\notherwise ldb >= max( 1, k ).\n\n@param[in]\nstrideB  [hipblasStride]\nstride from the start of one matrix (B_i) and the next one (B_i+1)\n\n@param[in]\nbeta\nbeta specifies the scalar beta. When beta is\nzero then C need not be set before entry.\n\n@param[in]\nCP       Device pointer to the first matrix C_1 on the GPU.\n\n@param[in]\nldc    [int]\nldc specifies the first dimension of C. ldc >= max( 1, n ).\n\n@param[inout]\nstrideC  [hipblasStride]\nstride from the start of one matrix (C_i) and the next one (C_i+1)\n\n@param[in]\nbatchCount [int]\nnumber of instances in the batch.\n"]
    pub fn hipblasSsyr2kStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        alpha: *const f32,
        AP: *const f32,
        lda: ::std::os::raw::c_int,
        strideA: hipblasStride,
        BP: *const f32,
        ldb: ::std::os::raw::c_int,
        strideB: hipblasStride,
        beta: *const f32,
        CP: *mut f32,
        ldc: ::std::os::raw::c_int,
        strideC: hipblasStride,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDsyr2kStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        alpha: *const f64,
        AP: *const f64,
        lda: ::std::os::raw::c_int,
        strideA: hipblasStride,
        BP: *const f64,
        ldb: ::std::os::raw::c_int,
        strideB: hipblasStride,
        beta: *const f64,
        CP: *mut f64,
        ldc: ::std::os::raw::c_int,
        strideC: hipblasStride,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsyr2kStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        alpha: *const hipblasComplex,
        AP: *const hipblasComplex,
        lda: ::std::os::raw::c_int,
        strideA: hipblasStride,
        BP: *const hipblasComplex,
        ldb: ::std::os::raw::c_int,
        strideB: hipblasStride,
        beta: *const hipblasComplex,
        CP: *mut hipblasComplex,
        ldc: ::std::os::raw::c_int,
        strideC: hipblasStride,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZsyr2kStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        alpha: *const hipblasDoubleComplex,
        AP: *const hipblasDoubleComplex,
        lda: ::std::os::raw::c_int,
        strideA: hipblasStride,
        BP: *const hipblasDoubleComplex,
        ldb: ::std::os::raw::c_int,
        strideB: hipblasStride,
        beta: *const hipblasDoubleComplex,
        CP: *mut hipblasDoubleComplex,
        ldc: ::std::os::raw::c_int,
        strideC: hipblasStride,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsyr2kStridedBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        alpha: *const hipComplex,
        AP: *const hipComplex,
        lda: ::std::os::raw::c_int,
        strideA: hipblasStride,
        BP: *const hipComplex,
        ldb: ::std::os::raw::c_int,
        strideB: hipblasStride,
        beta: *const hipComplex,
        CP: *mut hipComplex,
        ldc: ::std::os::raw::c_int,
        strideC: hipblasStride,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZsyr2kStridedBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        alpha: *const hipDoubleComplex,
        AP: *const hipDoubleComplex,
        lda: ::std::os::raw::c_int,
        strideA: hipblasStride,
        BP: *const hipDoubleComplex,
        ldb: ::std::os::raw::c_int,
        strideB: hipblasStride,
        beta: *const hipDoubleComplex,
        CP: *mut hipDoubleComplex,
        ldc: ::std::os::raw::c_int,
        strideC: hipblasStride,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 3 API\n\n\\details\n\nsyrkx performs one of the matrix-matrix operations for a symmetric rank-k update\n\nC := alpha*op( A )*op( B )^T + beta*C\n\nwhere  alpha and beta are scalars, op(A) and op(B) are n by k matrix, and\nC is a symmetric n x n matrix stored as either upper or lower.\nThis routine should only be used when the caller can guarantee that the result of op( A )*op( B )^T will be symmetric.\n\nop( A ) = A, op( B ) = B, and A and B are n by k if trans == HIPBLAS_OP_N\nop( A ) = A^T, op( B ) = B^T,  and A and B are k by n if trans == HIPBLAS_OP_T\n\n- Supported precisions in rocBLAS : s,d,c,z\n- Supported precisions in cuBLAS  : s,d,c,z\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n\n@param[in]\nuplo    [hipblasFillMode_t]\nHIPBLAS_FILL_MODE_UPPER:  C is an upper triangular matrix\nHIPBLAS_FILL_MODE_LOWER:  C is a  lower triangular matrix\n\n@param[in]\ntransA  [hipblasOperation_t]\nHIPBLAS_OP_T:      op( A ) = A^T, op( B ) = B^T\nHIPBLAS_OP_N:           op( A ) = A, op( B ) = B\n\n@param[in]\nn       [int]\nn specifies the number of rows and columns of C. n >= 0.\n\n@param[in]\nk       [int]\nk specifies the number of columns of op(A) and op(B). k >= 0.\n\n@param[in]\nalpha\nalpha specifies the scalar alpha. When alpha is\nzero then A is not referenced and A need not be set before\nentry.\n\n@param[in]\nAP       pointer storing matrix A on the GPU.\nMartrix dimension is ( lda, k ) when if trans = HIPBLAS_OP_N, otherwise (lda, n)\nonly the upper/lower triangular part is accessed.\n\n@param[in]\nlda     [int]\nlda specifies the first dimension of A.\nif trans = HIPBLAS_OP_N,  lda >= max( 1, n ),\notherwise lda >= max( 1, k ).\n\n@param[in]\nBP       pointer storing matrix B on the GPU.\nMartrix dimension is ( ldb, k ) when if trans = HIPBLAS_OP_N, otherwise (ldb, n)\nonly the upper/lower triangular part is accessed.\n\n@param[in]\nldb     [int]\nldb specifies the first dimension of B.\nif trans = HIPBLAS_OP_N,  ldb >= max( 1, n ),\notherwise ldb >= max( 1, k ).\n\n@param[in]\nbeta\nbeta specifies the scalar beta. When beta is\nzero then C need not be set before entry.\n\n@param[in]\nCP       pointer storing matrix C on the GPU.\n\n@param[in]\nldc    [int]\nldc specifies the first dimension of C. ldc >= max( 1, n ).\n"]
    pub fn hipblasSsyrkx(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        alpha: *const f32,
        AP: *const f32,
        lda: ::std::os::raw::c_int,
        BP: *const f32,
        ldb: ::std::os::raw::c_int,
        beta: *const f32,
        CP: *mut f32,
        ldc: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDsyrkx(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        alpha: *const f64,
        AP: *const f64,
        lda: ::std::os::raw::c_int,
        BP: *const f64,
        ldb: ::std::os::raw::c_int,
        beta: *const f64,
        CP: *mut f64,
        ldc: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsyrkx(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        alpha: *const hipblasComplex,
        AP: *const hipblasComplex,
        lda: ::std::os::raw::c_int,
        BP: *const hipblasComplex,
        ldb: ::std::os::raw::c_int,
        beta: *const hipblasComplex,
        CP: *mut hipblasComplex,
        ldc: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZsyrkx(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        alpha: *const hipblasDoubleComplex,
        AP: *const hipblasDoubleComplex,
        lda: ::std::os::raw::c_int,
        BP: *const hipblasDoubleComplex,
        ldb: ::std::os::raw::c_int,
        beta: *const hipblasDoubleComplex,
        CP: *mut hipblasDoubleComplex,
        ldc: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsyrkx_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        alpha: *const hipComplex,
        AP: *const hipComplex,
        lda: ::std::os::raw::c_int,
        BP: *const hipComplex,
        ldb: ::std::os::raw::c_int,
        beta: *const hipComplex,
        CP: *mut hipComplex,
        ldc: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZsyrkx_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        alpha: *const hipDoubleComplex,
        AP: *const hipDoubleComplex,
        lda: ::std::os::raw::c_int,
        BP: *const hipDoubleComplex,
        ldb: ::std::os::raw::c_int,
        beta: *const hipDoubleComplex,
        CP: *mut hipDoubleComplex,
        ldc: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 3 API\n\n\\details\n\nsyrkxBatched performs a batch of the matrix-matrix operations for a symmetric rank-k update\n\nC_i := alpha*op( A_i )*op( B_i )^T + beta*C_i\n\nwhere  alpha and beta are scalars, op(A_i) and op(B_i) are n by k matrix, and\nC_i is a symmetric n x n matrix stored as either upper or lower.\nThis routine should only be used when the caller can guarantee that the result of op( A_i )*op( B_i )^T will be symmetric.\n\nop( A_i ) = A_i, op( B_i ) = B_i, and A_i and B_i are n by k if trans == HIPBLAS_OP_N\nop( A_i ) = A_i^T, op( B_i ) = B_i^T,  and A_i and B_i are k by n if trans == HIPBLAS_OP_T\n\n- Supported precisions in rocBLAS : s,d,c,z\n- Supported precisions in cuBLAS  : No support\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n\n@param[in]\nuplo    [hipblasFillMode_t]\nHIPBLAS_FILL_MODE_UPPER:  C_i is an upper triangular matrix\nHIPBLAS_FILL_MODE_LOWER:  C_i is a  lower triangular matrix\n\n@param[in]\ntransA  [hipblasOperation_t]\nHIPBLAS_OP_T:      op( A_i ) = A_i^T, op( B_i ) = B_i^T\nHIPBLAS_OP_N:           op( A_i ) = A_i, op( B_i ) = B_i\n\n@param[in]\nn       [int]\nn specifies the number of rows and columns of C_i. n >= 0.\n\n@param[in]\nk       [int]\nk specifies the number of columns of op(A). k >= 0.\n\n@param[in]\nalpha\nalpha specifies the scalar alpha. When alpha is\nzero then A is not referenced and A need not be set before\nentry.\n\n@param[in]\nAP       device array of device pointers storing each matrix_i A of dimension (lda, k)\nwhen trans is HIPBLAS_OP_N, otherwise of dimension (lda, n)\n\n@param[in]\nlda     [int]\nlda specifies the first dimension of A_i.\nif trans = HIPBLAS_OP_N,  lda >= max( 1, n ),\notherwise lda >= max( 1, k ).\n\n@param[in]\nBP       device array of device pointers storing each matrix_i B of dimension (ldb, k)\nwhen trans is HIPBLAS_OP_N, otherwise of dimension (ldb, n)\n\n@param[in]\nldb     [int]\nldb specifies the first dimension of B.\nif trans = HIPBLAS_OP_N,  ldb >= max( 1, n ),\notherwise ldb >= max( 1, k ).\n\n@param[in]\nbeta\nbeta specifies the scalar beta. When beta is\nzero then C need not be set before entry.\n\n@param[in]\nCP       device array of device pointers storing each matrix C_i on the GPU.\n\n@param[in]\nldc    [int]\nldc specifies the first dimension of C. ldc >= max( 1, n ).\n\n@param[in]\nbatchCount [int]\nnumber of instances in the batch.\n"]
    pub fn hipblasSsyrkxBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        alpha: *const f32,
        AP: *const *const f32,
        lda: ::std::os::raw::c_int,
        BP: *const *const f32,
        ldb: ::std::os::raw::c_int,
        beta: *const f32,
        CP: *const *mut f32,
        ldc: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDsyrkxBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        alpha: *const f64,
        AP: *const *const f64,
        lda: ::std::os::raw::c_int,
        BP: *const *const f64,
        ldb: ::std::os::raw::c_int,
        beta: *const f64,
        CP: *const *mut f64,
        ldc: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsyrkxBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        alpha: *const hipblasComplex,
        AP: *const *const hipblasComplex,
        lda: ::std::os::raw::c_int,
        BP: *const *const hipblasComplex,
        ldb: ::std::os::raw::c_int,
        beta: *const hipblasComplex,
        CP: *const *mut hipblasComplex,
        ldc: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZsyrkxBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        alpha: *const hipblasDoubleComplex,
        AP: *const *const hipblasDoubleComplex,
        lda: ::std::os::raw::c_int,
        BP: *const *const hipblasDoubleComplex,
        ldb: ::std::os::raw::c_int,
        beta: *const hipblasDoubleComplex,
        CP: *const *mut hipblasDoubleComplex,
        ldc: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsyrkxBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        alpha: *const hipComplex,
        AP: *const *const hipComplex,
        lda: ::std::os::raw::c_int,
        BP: *const *const hipComplex,
        ldb: ::std::os::raw::c_int,
        beta: *const hipComplex,
        CP: *const *mut hipComplex,
        ldc: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZsyrkxBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        alpha: *const hipDoubleComplex,
        AP: *const *const hipDoubleComplex,
        lda: ::std::os::raw::c_int,
        BP: *const *const hipDoubleComplex,
        ldb: ::std::os::raw::c_int,
        beta: *const hipDoubleComplex,
        CP: *const *mut hipDoubleComplex,
        ldc: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 3 API\n\n\\details\n\nsyrkxStridedBatched performs a batch of the matrix-matrix operations for a symmetric rank-k update\n\nC_i := alpha*op( A_i )*op( B_i )^T + beta*C_i\n\nwhere  alpha and beta are scalars, op(A_i) and op(B_i) are n by k matrix, and\nC_i is a symmetric n x n matrix stored as either upper or lower.\nThis routine should only be used when the caller can guarantee that the result of op( A_i )*op( B_i )^T will be symmetric.\n\nop( A_i ) = A_i, op( B_i ) = B_i, and A_i and B_i are n by k if trans == HIPBLAS_OP_N\nop( A_i ) = A_i^T, op( B_i ) = B_i^T,  and A_i and B_i are k by n if trans == HIPBLAS_OP_T\n\n- Supported precisions in rocBLAS : s,d,c,z\n- Supported precisions in cuBLAS  : No support\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n\n@param[in]\nuplo    [hipblasFillMode_t]\nHIPBLAS_FILL_MODE_UPPER:  C_i is an upper triangular matrix\nHIPBLAS_FILL_MODE_LOWER:  C_i is a  lower triangular matrix\n\n@param[in]\ntransA  [hipblasOperation_t]\nHIPBLAS_OP_T:      op( A_i ) = A_i^T, op( B_i ) = B_i^T\nHIPBLAS_OP_N:           op( A_i ) = A_i, op( B_i ) = B_i\n\n@param[in]\nn       [int]\nn specifies the number of rows and columns of C_i. n >= 0.\n\n@param[in]\nk       [int]\nk specifies the number of columns of op(A). k >= 0.\n\n@param[in]\nalpha\nalpha specifies the scalar alpha. When alpha is\nzero then A is not referenced and A need not be set before\nentry.\n\n@param[in]\nAP       Device pointer to the first matrix A_1 on the GPU of dimension (lda, k)\nwhen trans is HIPBLAS_OP_N, otherwise of dimension (lda, n)\n\n@param[in]\nlda     [int]\nlda specifies the first dimension of A_i.\nif trans = HIPBLAS_OP_N,  lda >= max( 1, n ),\notherwise lda >= max( 1, k ).\n\n@param[in]\nstrideA  [hipblasStride]\nstride from the start of one matrix (A_i) and the next one (A_i+1)\n\n@param[in]\nBP       Device pointer to the first matrix B_1 on the GPU of dimension (ldb, k)\nwhen trans is HIPBLAS_OP_N, otherwise of dimension (ldb, n)\n\n@param[in]\nldb     [int]\nldb specifies the first dimension of B_i.\nif trans = HIPBLAS_OP_N,  ldb >= max( 1, n ),\notherwise ldb >= max( 1, k ).\n\n@param[in]\nstrideB  [hipblasStride]\nstride from the start of one matrix (B_i) and the next one (B_i+1)\n\n@param[in]\nbeta\nbeta specifies the scalar beta. When beta is\nzero then C need not be set before entry.\n\n@param[in]\nCP       Device pointer to the first matrix C_1 on the GPU.\n\n@param[in]\nldc    [int]\nldc specifies the first dimension of C. ldc >= max( 1, n ).\n\n@param[inout]\nstrideC  [hipblasStride]\nstride from the start of one matrix (C_i) and the next one (C_i+1)\n\n@param[in]\nbatchCount [int]\nnumber of instances in the batch.\n"]
    pub fn hipblasSsyrkxStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        alpha: *const f32,
        AP: *const f32,
        lda: ::std::os::raw::c_int,
        strideA: hipblasStride,
        BP: *const f32,
        ldb: ::std::os::raw::c_int,
        strideB: hipblasStride,
        beta: *const f32,
        CP: *mut f32,
        ldc: ::std::os::raw::c_int,
        strideC: hipblasStride,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDsyrkxStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        alpha: *const f64,
        AP: *const f64,
        lda: ::std::os::raw::c_int,
        strideA: hipblasStride,
        BP: *const f64,
        ldb: ::std::os::raw::c_int,
        strideB: hipblasStride,
        beta: *const f64,
        CP: *mut f64,
        ldc: ::std::os::raw::c_int,
        strideC: hipblasStride,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsyrkxStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        alpha: *const hipblasComplex,
        AP: *const hipblasComplex,
        lda: ::std::os::raw::c_int,
        strideA: hipblasStride,
        BP: *const hipblasComplex,
        ldb: ::std::os::raw::c_int,
        strideB: hipblasStride,
        beta: *const hipblasComplex,
        CP: *mut hipblasComplex,
        ldc: ::std::os::raw::c_int,
        strideC: hipblasStride,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZsyrkxStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        alpha: *const hipblasDoubleComplex,
        AP: *const hipblasDoubleComplex,
        lda: ::std::os::raw::c_int,
        strideA: hipblasStride,
        BP: *const hipblasDoubleComplex,
        ldb: ::std::os::raw::c_int,
        strideB: hipblasStride,
        beta: *const hipblasDoubleComplex,
        CP: *mut hipblasDoubleComplex,
        ldc: ::std::os::raw::c_int,
        strideC: hipblasStride,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsyrkxStridedBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        alpha: *const hipComplex,
        AP: *const hipComplex,
        lda: ::std::os::raw::c_int,
        strideA: hipblasStride,
        BP: *const hipComplex,
        ldb: ::std::os::raw::c_int,
        strideB: hipblasStride,
        beta: *const hipComplex,
        CP: *mut hipComplex,
        ldc: ::std::os::raw::c_int,
        strideC: hipblasStride,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZsyrkxStridedBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        alpha: *const hipDoubleComplex,
        AP: *const hipDoubleComplex,
        lda: ::std::os::raw::c_int,
        strideA: hipblasStride,
        BP: *const hipDoubleComplex,
        ldb: ::std::os::raw::c_int,
        strideB: hipblasStride,
        beta: *const hipDoubleComplex,
        CP: *mut hipDoubleComplex,
        ldc: ::std::os::raw::c_int,
        strideC: hipblasStride,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 3 API\n\n\\details\ngeam performs one of the matrix-matrix operations\n\nC = alpha*op( A ) + beta*op( B ),\n\nwhere op( X ) is one of\n\nop( X ) = X      or\nop( X ) = X**T   or\nop( X ) = X**H,\n\nalpha and beta are scalars, and A, B and C are matrices, with\nop( A ) an m by n matrix, op( B ) an m by n matrix, and C an m by n matrix.\n\n- Supported precisions in rocBLAS : s,d,c,z\n- Supported precisions in cuBLAS  : s,d,c,z\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n@param[in]\ntransA    [hipblasOperation_t]\nspecifies the form of op( A )\n@param[in]\ntransB    [hipblasOperation_t]\nspecifies the form of op( B )\n@param[in]\nm         [int]\nmatrix dimension m.\n@param[in]\nn         [int]\nmatrix dimension n.\n@param[in]\nalpha     device pointer or host pointer specifying the scalar alpha.\n@param[in]\nAP         device pointer storing matrix A.\n@param[in]\nlda       [int]\nspecifies the leading dimension of A.\n@param[in]\nbeta      device pointer or host pointer specifying the scalar beta.\n@param[in]\nBP         device pointer storing matrix B.\n@param[in]\nldb       [int]\nspecifies the leading dimension of B.\n@param[in, out]\nCP         device pointer storing matrix C.\n@param[in]\nldc       [int]\nspecifies the leading dimension of C.\n"]
    pub fn hipblasSgeam(
        handle: hipblasHandle_t,
        transA: hipblasOperation_t,
        transB: hipblasOperation_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        alpha: *const f32,
        AP: *const f32,
        lda: ::std::os::raw::c_int,
        beta: *const f32,
        BP: *const f32,
        ldb: ::std::os::raw::c_int,
        CP: *mut f32,
        ldc: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDgeam(
        handle: hipblasHandle_t,
        transA: hipblasOperation_t,
        transB: hipblasOperation_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        alpha: *const f64,
        AP: *const f64,
        lda: ::std::os::raw::c_int,
        beta: *const f64,
        BP: *const f64,
        ldb: ::std::os::raw::c_int,
        CP: *mut f64,
        ldc: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgeam(
        handle: hipblasHandle_t,
        transA: hipblasOperation_t,
        transB: hipblasOperation_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        alpha: *const hipblasComplex,
        AP: *const hipblasComplex,
        lda: ::std::os::raw::c_int,
        beta: *const hipblasComplex,
        BP: *const hipblasComplex,
        ldb: ::std::os::raw::c_int,
        CP: *mut hipblasComplex,
        ldc: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgeam(
        handle: hipblasHandle_t,
        transA: hipblasOperation_t,
        transB: hipblasOperation_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        alpha: *const hipblasDoubleComplex,
        AP: *const hipblasDoubleComplex,
        lda: ::std::os::raw::c_int,
        beta: *const hipblasDoubleComplex,
        BP: *const hipblasDoubleComplex,
        ldb: ::std::os::raw::c_int,
        CP: *mut hipblasDoubleComplex,
        ldc: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgeam_v2(
        handle: hipblasHandle_t,
        transA: hipblasOperation_t,
        transB: hipblasOperation_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        alpha: *const hipComplex,
        AP: *const hipComplex,
        lda: ::std::os::raw::c_int,
        beta: *const hipComplex,
        BP: *const hipComplex,
        ldb: ::std::os::raw::c_int,
        CP: *mut hipComplex,
        ldc: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgeam_v2(
        handle: hipblasHandle_t,
        transA: hipblasOperation_t,
        transB: hipblasOperation_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        alpha: *const hipDoubleComplex,
        AP: *const hipDoubleComplex,
        lda: ::std::os::raw::c_int,
        beta: *const hipDoubleComplex,
        BP: *const hipDoubleComplex,
        ldb: ::std::os::raw::c_int,
        CP: *mut hipDoubleComplex,
        ldc: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 3 API\n\n\\details\ngeamBatched performs one of the batched matrix-matrix operations\n\nC_i = alpha*op( A_i ) + beta*op( B_i )  for i = 0, 1, ... batchCount - 1\n\nwhere alpha and beta are scalars, and op(A_i), op(B_i) and C_i are m by n matrices\nand op( X ) is one of\n\nop( X ) = X      or\nop( X ) = X**T\n\n- Supported precisions in rocBLAS : s,d,c,z\n- Supported precisions in cuBLAS  : No support\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n@param[in]\ntransA    [hipblasOperation_t]\nspecifies the form of op( A )\n@param[in]\ntransB    [hipblasOperation_t]\nspecifies the form of op( B )\n@param[in]\nm         [int]\nmatrix dimension m.\n@param[in]\nn         [int]\nmatrix dimension n.\n@param[in]\nalpha     device pointer or host pointer specifying the scalar alpha.\n@param[in]\nAP         device array of device pointers storing each matrix A_i on the GPU.\nEach A_i is of dimension ( lda, k ), where k is m\nwhen  transA == HIPBLAS_OP_N and\nis  n  when  transA == HIPBLAS_OP_T.\n@param[in]\nlda       [int]\nspecifies the leading dimension of A.\n@param[in]\nbeta      device pointer or host pointer specifying the scalar beta.\n@param[in]\nBP         device array of device pointers storing each matrix B_i on the GPU.\nEach B_i is of dimension ( ldb, k ), where k is m\nwhen  transB == HIPBLAS_OP_N and\nis  n  when  transB == HIPBLAS_OP_T.\n@param[in]\nldb       [int]\nspecifies the leading dimension of B.\n@param[in, out]\nCP         device array of device pointers storing each matrix C_i on the GPU.\nEach C_i is of dimension ( ldc, n ).\n@param[in]\nldc       [int]\nspecifies the leading dimension of C.\n\n@param[in]\nbatchCount [int]\nnumber of instances i in the batch.\n"]
    pub fn hipblasSgeamBatched(
        handle: hipblasHandle_t,
        transA: hipblasOperation_t,
        transB: hipblasOperation_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        alpha: *const f32,
        AP: *const *const f32,
        lda: ::std::os::raw::c_int,
        beta: *const f32,
        BP: *const *const f32,
        ldb: ::std::os::raw::c_int,
        CP: *const *mut f32,
        ldc: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDgeamBatched(
        handle: hipblasHandle_t,
        transA: hipblasOperation_t,
        transB: hipblasOperation_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        alpha: *const f64,
        AP: *const *const f64,
        lda: ::std::os::raw::c_int,
        beta: *const f64,
        BP: *const *const f64,
        ldb: ::std::os::raw::c_int,
        CP: *const *mut f64,
        ldc: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgeamBatched(
        handle: hipblasHandle_t,
        transA: hipblasOperation_t,
        transB: hipblasOperation_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        alpha: *const hipblasComplex,
        AP: *const *const hipblasComplex,
        lda: ::std::os::raw::c_int,
        beta: *const hipblasComplex,
        BP: *const *const hipblasComplex,
        ldb: ::std::os::raw::c_int,
        CP: *const *mut hipblasComplex,
        ldc: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgeamBatched(
        handle: hipblasHandle_t,
        transA: hipblasOperation_t,
        transB: hipblasOperation_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        alpha: *const hipblasDoubleComplex,
        AP: *const *const hipblasDoubleComplex,
        lda: ::std::os::raw::c_int,
        beta: *const hipblasDoubleComplex,
        BP: *const *const hipblasDoubleComplex,
        ldb: ::std::os::raw::c_int,
        CP: *const *mut hipblasDoubleComplex,
        ldc: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgeamBatched_v2(
        handle: hipblasHandle_t,
        transA: hipblasOperation_t,
        transB: hipblasOperation_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        alpha: *const hipComplex,
        AP: *const *const hipComplex,
        lda: ::std::os::raw::c_int,
        beta: *const hipComplex,
        BP: *const *const hipComplex,
        ldb: ::std::os::raw::c_int,
        CP: *const *mut hipComplex,
        ldc: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgeamBatched_v2(
        handle: hipblasHandle_t,
        transA: hipblasOperation_t,
        transB: hipblasOperation_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        alpha: *const hipDoubleComplex,
        AP: *const *const hipDoubleComplex,
        lda: ::std::os::raw::c_int,
        beta: *const hipDoubleComplex,
        BP: *const *const hipDoubleComplex,
        ldb: ::std::os::raw::c_int,
        CP: *const *mut hipDoubleComplex,
        ldc: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 3 API\n\n\\details\ngeamStridedBatched performs one of the batched matrix-matrix operations\n\nC_i = alpha*op( A_i ) + beta*op( B_i )  for i = 0, 1, ... batchCount - 1\n\nwhere alpha and beta are scalars, and op(A_i), op(B_i) and C_i are m by n matrices\nand op( X ) is one of\n\nop( X ) = X      or\nop( X ) = X**T\n\n- Supported precisions in rocBLAS : s,d,c,z\n- Supported precisions in cuBLAS  : No support\n\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n\n@param[in]\ntransA    [hipblasOperation_t]\nspecifies the form of op( A )\n\n@param[in]\ntransB    [hipblasOperation_t]\nspecifies the form of op( B )\n\n@param[in]\nm         [int]\nmatrix dimension m.\n\n@param[in]\nn         [int]\nmatrix dimension n.\n\n@param[in]\nalpha     device pointer or host pointer specifying the scalar alpha.\n\n@param[in]\nAP         device pointer to the first matrix A_0 on the GPU.\nEach A_i is of dimension ( lda, k ), where k is m\nwhen  transA == HIPBLAS_OP_N and\nis  n  when  transA == HIPBLAS_OP_T.\n\n@param[in]\nlda       [int]\nspecifies the leading dimension of A.\n\n@param[in]\nstrideA  [hipblasStride]\nstride from the start of one matrix (A_i) and the next one (A_i+1)\n\n@param[in]\nbeta      device pointer or host pointer specifying the scalar beta.\n\n@param[in]\nBP         pointer to the first matrix B_0 on the GPU.\nEach B_i is of dimension ( ldb, k ), where k is m\nwhen  transB == HIPBLAS_OP_N and\nis  n  when  transB == HIPBLAS_OP_T.\n\n@param[in]\nldb       [int]\nspecifies the leading dimension of B.\n\n@param[in]\nstrideB  [hipblasStride]\nstride from the start of one matrix (B_i) and the next one (B_i+1)\n\n@param[in, out]\nCP         pointer to the first matrix C_0 on the GPU.\nEach C_i is of dimension ( ldc, n ).\n\n@param[in]\nldc       [int]\nspecifies the leading dimension of C.\n\n@param[in]\nstrideC  [hipblasStride]\nstride from the start of one matrix (C_i) and the next one (C_i+1)\n\n@param[in]\nbatchCount [int]\nnumber of instances i in the batch.\n"]
    pub fn hipblasSgeamStridedBatched(
        handle: hipblasHandle_t,
        transA: hipblasOperation_t,
        transB: hipblasOperation_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        alpha: *const f32,
        AP: *const f32,
        lda: ::std::os::raw::c_int,
        strideA: hipblasStride,
        beta: *const f32,
        BP: *const f32,
        ldb: ::std::os::raw::c_int,
        strideB: hipblasStride,
        CP: *mut f32,
        ldc: ::std::os::raw::c_int,
        strideC: hipblasStride,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDgeamStridedBatched(
        handle: hipblasHandle_t,
        transA: hipblasOperation_t,
        transB: hipblasOperation_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        alpha: *const f64,
        AP: *const f64,
        lda: ::std::os::raw::c_int,
        strideA: hipblasStride,
        beta: *const f64,
        BP: *const f64,
        ldb: ::std::os::raw::c_int,
        strideB: hipblasStride,
        CP: *mut f64,
        ldc: ::std::os::raw::c_int,
        strideC: hipblasStride,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgeamStridedBatched(
        handle: hipblasHandle_t,
        transA: hipblasOperation_t,
        transB: hipblasOperation_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        alpha: *const hipblasComplex,
        AP: *const hipblasComplex,
        lda: ::std::os::raw::c_int,
        strideA: hipblasStride,
        beta: *const hipblasComplex,
        BP: *const hipblasComplex,
        ldb: ::std::os::raw::c_int,
        strideB: hipblasStride,
        CP: *mut hipblasComplex,
        ldc: ::std::os::raw::c_int,
        strideC: hipblasStride,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgeamStridedBatched(
        handle: hipblasHandle_t,
        transA: hipblasOperation_t,
        transB: hipblasOperation_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        alpha: *const hipblasDoubleComplex,
        AP: *const hipblasDoubleComplex,
        lda: ::std::os::raw::c_int,
        strideA: hipblasStride,
        beta: *const hipblasDoubleComplex,
        BP: *const hipblasDoubleComplex,
        ldb: ::std::os::raw::c_int,
        strideB: hipblasStride,
        CP: *mut hipblasDoubleComplex,
        ldc: ::std::os::raw::c_int,
        strideC: hipblasStride,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgeamStridedBatched_v2(
        handle: hipblasHandle_t,
        transA: hipblasOperation_t,
        transB: hipblasOperation_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        alpha: *const hipComplex,
        AP: *const hipComplex,
        lda: ::std::os::raw::c_int,
        strideA: hipblasStride,
        beta: *const hipComplex,
        BP: *const hipComplex,
        ldb: ::std::os::raw::c_int,
        strideB: hipblasStride,
        CP: *mut hipComplex,
        ldc: ::std::os::raw::c_int,
        strideC: hipblasStride,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgeamStridedBatched_v2(
        handle: hipblasHandle_t,
        transA: hipblasOperation_t,
        transB: hipblasOperation_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        alpha: *const hipDoubleComplex,
        AP: *const hipDoubleComplex,
        lda: ::std::os::raw::c_int,
        strideA: hipblasStride,
        beta: *const hipDoubleComplex,
        BP: *const hipDoubleComplex,
        ldb: ::std::os::raw::c_int,
        strideB: hipblasStride,
        CP: *mut hipDoubleComplex,
        ldc: ::std::os::raw::c_int,
        strideC: hipblasStride,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 3 API\n\n\\details\n\nhemm performs one of the matrix-matrix operations:\n\nC := alpha*A*B + beta*C if side == HIPBLAS_SIDE_LEFT,\nC := alpha*B*A + beta*C if side == HIPBLAS_SIDE_RIGHT,\n\nwhere alpha and beta are scalars, B and C are m by n matrices, and\nA is a Hermitian matrix stored as either upper or lower.\n\n- Supported precisions in rocBLAS : c,z\n- Supported precisions in cuBLAS  : c,z\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n\n@param[in]\nside  [hipblasSideMode_t]\nHIPBLAS_SIDE_LEFT:      C := alpha*A*B + beta*C\nHIPBLAS_SIDE_RIGHT:     C := alpha*B*A + beta*C\n\n@param[in]\nuplo    [hipblasFillMode_t]\nHIPBLAS_FILL_MODE_UPPER:  A is an upper triangular matrix\nHIPBLAS_FILL_MODE_LOWER:  A is a  lower triangular matrix\n\n@param[in]\nn       [int]\nn specifies the number of rows of B and C. n >= 0.\n\n@param[in]\nk       [int]\nn specifies the number of columns of B and C. k >= 0.\n\n@param[in]\nalpha\nalpha specifies the scalar alpha. When alpha is\nzero then A and B are not referenced.\n\n@param[in]\nAP       pointer storing matrix A on the GPU.\nA is m by m if side == HIPBLAS_SIDE_LEFT\nA is n by n if side == HIPBLAS_SIDE_RIGHT\nOnly the upper/lower triangular part is accessed.\nThe imaginary component of the diagonal elements is not used.\n\n@param[in]\nlda     [int]\nlda specifies the first dimension of A.\nif side = HIPBLAS_SIDE_LEFT,  lda >= max( 1, m ),\notherwise lda >= max( 1, n ).\n\n@param[in]\nBP       pointer storing matrix B on the GPU.\nMatrix dimension is m by n\n\n@param[in]\nldb     [int]\nldb specifies the first dimension of B. ldb >= max( 1, m )\n\n@param[in]\nbeta\nbeta specifies the scalar beta. When beta is\nzero then C need not be set before entry.\n\n@param[in]\nCP       pointer storing matrix C on the GPU.\nMatrix dimension is m by n\n\n@param[in]\nldc    [int]\nldc specifies the first dimension of C. ldc >= max( 1, m )\n"]
    pub fn hipblasChemm(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        alpha: *const hipblasComplex,
        AP: *const hipblasComplex,
        lda: ::std::os::raw::c_int,
        BP: *const hipblasComplex,
        ldb: ::std::os::raw::c_int,
        beta: *const hipblasComplex,
        CP: *mut hipblasComplex,
        ldc: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZhemm(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        alpha: *const hipblasDoubleComplex,
        AP: *const hipblasDoubleComplex,
        lda: ::std::os::raw::c_int,
        BP: *const hipblasDoubleComplex,
        ldb: ::std::os::raw::c_int,
        beta: *const hipblasDoubleComplex,
        CP: *mut hipblasDoubleComplex,
        ldc: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasChemm_v2(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        alpha: *const hipComplex,
        AP: *const hipComplex,
        lda: ::std::os::raw::c_int,
        BP: *const hipComplex,
        ldb: ::std::os::raw::c_int,
        beta: *const hipComplex,
        CP: *mut hipComplex,
        ldc: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZhemm_v2(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        alpha: *const hipDoubleComplex,
        AP: *const hipDoubleComplex,
        lda: ::std::os::raw::c_int,
        BP: *const hipDoubleComplex,
        ldb: ::std::os::raw::c_int,
        beta: *const hipDoubleComplex,
        CP: *mut hipDoubleComplex,
        ldc: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 3 API\n\n\\details\n\nhemmBatched performs a batch of the matrix-matrix operations:\n\nC_i := alpha*A_i*B_i + beta*C_i if side == HIPBLAS_SIDE_LEFT,\nC_i := alpha*B_i*A_i + beta*C_i if side == HIPBLAS_SIDE_RIGHT,\n\nwhere alpha and beta are scalars, B_i and C_i are m by n matrices, and\nA_i is a Hermitian matrix stored as either upper or lower.\n\n- Supported precisions in rocBLAS : c,z\n- Supported precisions in cuBLAS  : No support\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n\n@param[in]\nside  [hipblasSideMode_t]\nHIPBLAS_SIDE_LEFT:      C_i := alpha*A_i*B_i + beta*C_i\nHIPBLAS_SIDE_RIGHT:     C_i := alpha*B_i*A_i + beta*C_i\n\n@param[in]\nuplo    [hipblasFillMode_t]\nHIPBLAS_FILL_MODE_UPPER:  A_i is an upper triangular matrix\nHIPBLAS_FILL_MODE_LOWER:  A_i is a  lower triangular matrix\n\n@param[in]\nn       [int]\nn specifies the number of rows of B_i and C_i. n >= 0.\n\n@param[in]\nk       [int]\nk specifies the number of columns of B_i and C_i. k >= 0.\n\n@param[in]\nalpha\nalpha specifies the scalar alpha. When alpha is\nzero then A_i and B_i are not referenced.\n\n@param[in]\nAP       device array of device pointers storing each matrix A_i on the GPU.\nA_i is m by m if side == HIPBLAS_SIDE_LEFT\nA_i is n by n if side == HIPBLAS_SIDE_RIGHT\nOnly the upper/lower triangular part is accessed.\nThe imaginary component of the diagonal elements is not used.\n\n@param[in]\nlda     [int]\nlda specifies the first dimension of A_i.\nif side = HIPBLAS_SIDE_LEFT,  lda >= max( 1, m ),\notherwise lda >= max( 1, n ).\n\n@param[in]\nBP       device array of device pointers storing each matrix B_i on the GPU.\nMatrix dimension is m by n\n\n@param[in]\nldb     [int]\nldb specifies the first dimension of B_i. ldb >= max( 1, m )\n\n@param[in]\nbeta\nbeta specifies the scalar beta. When beta is\nzero then C_i need not be set before entry.\n\n@param[in]\nCP       device array of device pointers storing each matrix C_i on the GPU.\nMatrix dimension is m by n\n\n@param[in]\nldc    [int]\nldc specifies the first dimension of C_i. ldc >= max( 1, m )\n\n@param[in]\nbatchCount [int]\nnumber of instances in the batch.\n"]
    pub fn hipblasChemmBatched(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        alpha: *const hipblasComplex,
        AP: *const *const hipblasComplex,
        lda: ::std::os::raw::c_int,
        BP: *const *const hipblasComplex,
        ldb: ::std::os::raw::c_int,
        beta: *const hipblasComplex,
        CP: *const *mut hipblasComplex,
        ldc: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZhemmBatched(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        alpha: *const hipblasDoubleComplex,
        AP: *const *const hipblasDoubleComplex,
        lda: ::std::os::raw::c_int,
        BP: *const *const hipblasDoubleComplex,
        ldb: ::std::os::raw::c_int,
        beta: *const hipblasDoubleComplex,
        CP: *const *mut hipblasDoubleComplex,
        ldc: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasChemmBatched_v2(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        alpha: *const hipComplex,
        AP: *const *const hipComplex,
        lda: ::std::os::raw::c_int,
        BP: *const *const hipComplex,
        ldb: ::std::os::raw::c_int,
        beta: *const hipComplex,
        CP: *const *mut hipComplex,
        ldc: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZhemmBatched_v2(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        alpha: *const hipDoubleComplex,
        AP: *const *const hipDoubleComplex,
        lda: ::std::os::raw::c_int,
        BP: *const *const hipDoubleComplex,
        ldb: ::std::os::raw::c_int,
        beta: *const hipDoubleComplex,
        CP: *const *mut hipDoubleComplex,
        ldc: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 3 API\n\n\\details\n\nhemmStridedBatched performs a batch of the matrix-matrix operations:\n\nC_i := alpha*A_i*B_i + beta*C_i if side == HIPBLAS_SIDE_LEFT,\nC_i := alpha*B_i*A_i + beta*C_i if side == HIPBLAS_SIDE_RIGHT,\n\nwhere alpha and beta are scalars, B_i and C_i are m by n matrices, and\nA_i is a Hermitian matrix stored as either upper or lower.\n\n- Supported precisions in rocBLAS : c,z\n- Supported precisions in cuBLAS  : No support\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n\n@param[in]\nside  [hipblasSideMode_t]\nHIPBLAS_SIDE_LEFT:      C_i := alpha*A_i*B_i + beta*C_i\nHIPBLAS_SIDE_RIGHT:     C_i := alpha*B_i*A_i + beta*C_i\n\n@param[in]\nuplo    [hipblasFillMode_t]\nHIPBLAS_FILL_MODE_UPPER:  A_i is an upper triangular matrix\nHIPBLAS_FILL_MODE_LOWER:  A_i is a  lower triangular matrix\n\n@param[in]\nn       [int]\nn specifies the number of rows of B_i and C_i. n >= 0.\n\n@param[in]\nk       [int]\nk specifies the number of columns of B_i and C_i. k >= 0.\n\n@param[in]\nalpha\nalpha specifies the scalar alpha. When alpha is\nzero then A_i and B_i are not referenced.\n\n@param[in]\nAP       device pointer to first matrix A_1\nA_i is m by m if side == HIPBLAS_SIDE_LEFT\nA_i is n by n if side == HIPBLAS_SIDE_RIGHT\nOnly the upper/lower triangular part is accessed.\nThe imaginary component of the diagonal elements is not used.\n\n@param[in]\nlda     [int]\nlda specifies the first dimension of A_i.\nif side = HIPBLAS_SIDE_LEFT,  lda >= max( 1, m ),\notherwise lda >= max( 1, n ).\n\n@param[in]\nstrideA  [hipblasStride]\nstride from the start of one matrix (A_i) and the next one (A_i+1)\n\n@param[in]\nBP       device pointer to first matrix B_1 of dimension (ldb, n) on the GPU\n\n@param[in]\nldb     [int]\nldb specifies the first dimension of B_i.\nif side = HIPBLAS_OP_N,  ldb >= max( 1, m ),\notherwise ldb >= max( 1, n ).\n\n@param[in]\nstrideB  [hipblasStride]\nstride from the start of one matrix (B_i) and the next one (B_i+1)\n\n@param[in]\nbeta\nbeta specifies the scalar beta. When beta is\nzero then C need not be set before entry.\n\n@param[in]\nCP        device pointer to first matrix C_1 of dimension (ldc, n) on the GPU.\n\n@param[in]\nldc    [int]\nldc specifies the first dimension of C. ldc >= max( 1, m )\n\n@param[inout]\nstrideC  [hipblasStride]\nstride from the start of one matrix (C_i) and the next one (C_i+1)\n\n@param[in]\nbatchCount [int]\nnumber of instances in the batch\n"]
    pub fn hipblasChemmStridedBatched(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        alpha: *const hipblasComplex,
        AP: *const hipblasComplex,
        lda: ::std::os::raw::c_int,
        strideA: hipblasStride,
        BP: *const hipblasComplex,
        ldb: ::std::os::raw::c_int,
        strideB: hipblasStride,
        beta: *const hipblasComplex,
        CP: *mut hipblasComplex,
        ldc: ::std::os::raw::c_int,
        strideC: hipblasStride,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZhemmStridedBatched(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        alpha: *const hipblasDoubleComplex,
        AP: *const hipblasDoubleComplex,
        lda: ::std::os::raw::c_int,
        strideA: hipblasStride,
        BP: *const hipblasDoubleComplex,
        ldb: ::std::os::raw::c_int,
        strideB: hipblasStride,
        beta: *const hipblasDoubleComplex,
        CP: *mut hipblasDoubleComplex,
        ldc: ::std::os::raw::c_int,
        strideC: hipblasStride,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasChemmStridedBatched_v2(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        alpha: *const hipComplex,
        AP: *const hipComplex,
        lda: ::std::os::raw::c_int,
        strideA: hipblasStride,
        BP: *const hipComplex,
        ldb: ::std::os::raw::c_int,
        strideB: hipblasStride,
        beta: *const hipComplex,
        CP: *mut hipComplex,
        ldc: ::std::os::raw::c_int,
        strideC: hipblasStride,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZhemmStridedBatched_v2(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        alpha: *const hipDoubleComplex,
        AP: *const hipDoubleComplex,
        lda: ::std::os::raw::c_int,
        strideA: hipblasStride,
        BP: *const hipDoubleComplex,
        ldb: ::std::os::raw::c_int,
        strideB: hipblasStride,
        beta: *const hipDoubleComplex,
        CP: *mut hipDoubleComplex,
        ldc: ::std::os::raw::c_int,
        strideC: hipblasStride,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 3 API\n\n\\details\n\ntrmm performs one of the matrix-matrix operations\n\nC := alpha*op( A )*B,   or   C := alpha*B*op( A )\n\nwhere  alpha  is a scalar, B and C are an m by n matrices,  A  is a unit, or\nnon-unit,  upper or lower triangular matrix  and  op( A )  is one  of\n\nop( A ) = A   or   op( A ) = A^T   or   op( A ) = A^H.\n\nNote that trmm can provide in-place functionality by passing in the same address for both\nmatrices B and C and by setting ldb equal to ldc.\n\n- Supported precisions in rocBLAS : s,d,c,z\n- Supported precisions in cuBLAS  : s,d,c,z\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n\n@param[in]\nside    [hipblasSideMode_t]\nSpecifies whether op(A) multiplies B from the left or right as follows:\nHIPBLAS_SIDE_LEFT:       C := alpha*op( A )*B.\nHIPBLAS_SIDE_RIGHT:      C := alpha*B*op( A ).\n\n@param[in]\nuplo    [hipblasFillMode_t]\nSpecifies whether the matrix A is an upper or lower triangular matrix as follows:\nHIPBLAS_FILL_MODE_UPPER:  A is an upper triangular matrix.\nHIPBLAS_FILL_MODE_LOWER:  A is a  lower triangular matrix.\n\n@param[in]\ntransA  [hipblasOperation_t]\nSpecifies the form of op(A) to be used in the matrix multiplication as follows:\nHIPBLAS_OP_N: op(A) = A.\nHIPBLAS_OP_T: op(A) = A^T.\nHIPBLAS_OP_C: op(A) = A^H.\n\n@param[in]\ndiag    [hipblasDiagType_t]\nSpecifies whether or not A is unit triangular as follows:\nHIPBLAS_DIAG_UNIT:      A is assumed to be unit triangular.\nHIPBLAS_DIAG_NON_UNIT:  A is not assumed to be unit triangular.\n\n@param[in]\nm       [int]\nm specifies the number of rows of B and C. m >= 0.\n\n@param[in]\nn       [int]\nn specifies the number of columns of B and C. n >= 0.\n\n@param[in]\nalpha\nalpha specifies the scalar alpha. When alpha is\nzero then A is not referenced and B need not be set before\nentry.\n\n@param[in]\nA       Device pointer to matrix A on the GPU.\nA has dimension ( lda, k ), where k is m\nwhen  side == HIPBLAS_SIDE_LEFT  and\nis  n  when  side == HIPBLAS_SIDE_RIGHT.\n\nWhen uplo == HIPBLAS_FILL_MODE_UPPER the  leading  k by k\nupper triangular part of the array  A must contain the upper\ntriangular matrix  and the strictly lower triangular part of\nA is not referenced.\n\nWhen uplo == HIPBLAS_FILL_MODE_LOWER the  leading  k by k\nlower triangular part of the array  A must contain the lower\ntriangular matrix  and the strictly upper triangular part of\nA is not referenced.\n\nNote that when  diag == HIPBLAS_DIAG_UNIT  the diagonal elements of\nA  are not referenced either,  but are assumed to be  unity.\n\n@param[in]\nlda     [int]\nlda specifies the first dimension of A.\nif side == HIPBLAS_SIDE_LEFT,  lda >= max( 1, m ),\nif side == HIPBLAS_SIDE_RIGHT, lda >= max( 1, n ).\n\n@param[inout]\nB       Device pointer to the matrix B of dimension (ldb, n) on the GPU.\n\n@param[in]\nldb    [int]\nldb specifies the first dimension of B. ldb >= max( 1, m ).\n\n@param[in]\nC      Device pointer to the matrix C of dimension (ldc, n) on the GPU.\nUsers can pass in the same matrix B to parameter C to achieve\nin-place functionality of trmm.\n@param[in]\nldc    [int]\nldc specifies the first dimension of C. ldc >= max( 1, m ).\n"]
    pub fn hipblasStrmm(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        alpha: *const f32,
        A: *const f32,
        lda: ::std::os::raw::c_int,
        B: *const f32,
        ldb: ::std::os::raw::c_int,
        C: *mut f32,
        ldc: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDtrmm(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        alpha: *const f64,
        A: *const f64,
        lda: ::std::os::raw::c_int,
        B: *const f64,
        ldb: ::std::os::raw::c_int,
        C: *mut f64,
        ldc: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCtrmm(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        alpha: *const hipblasComplex,
        A: *const hipblasComplex,
        lda: ::std::os::raw::c_int,
        B: *const hipblasComplex,
        ldb: ::std::os::raw::c_int,
        C: *mut hipblasComplex,
        ldc: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZtrmm(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        alpha: *const hipblasDoubleComplex,
        A: *const hipblasDoubleComplex,
        lda: ::std::os::raw::c_int,
        B: *const hipblasDoubleComplex,
        ldb: ::std::os::raw::c_int,
        C: *mut hipblasDoubleComplex,
        ldc: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCtrmm_v2(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        alpha: *const hipComplex,
        A: *const hipComplex,
        lda: ::std::os::raw::c_int,
        B: *const hipComplex,
        ldb: ::std::os::raw::c_int,
        C: *mut hipComplex,
        ldc: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZtrmm_v2(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        alpha: *const hipDoubleComplex,
        A: *const hipDoubleComplex,
        lda: ::std::os::raw::c_int,
        B: *const hipDoubleComplex,
        ldb: ::std::os::raw::c_int,
        C: *mut hipDoubleComplex,
        ldc: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 3 API\n\n\\details\n\ntrmmBatched performs one of the batched matrix-matrix operations\n\nC_i := alpha*op( A_i )*B_i,   or   C_i := alpha*B_i*op( A_i )  for i = 0, 1, ... batchCount -1\n\nwhere alpha is a scalar, B_i and C_i are m by n matrices, A_i is a unit, or\nnon-unit, upper or lower triangular matrix and op( A_i ) is one of\n\nop( A_i ) = A_i   or   op( A_i ) = A_i^T   or   op( A_i ) = A_i^H.\n\nNote that trmmBatched can provide in-place functionality by passing in the same address for both\nmatrices B and C and by setting ldb equal to ldc.\n\n- Supported precisions in rocBLAS : s,d,c,z\n- Supported precisions in cuBLAS  : No support\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n\n@param[in]\nside    [hipblasSideMode_t]\nSpecifies whether op(A_i) multiplies B_i from the left or right as follows:\nHIPBLAS_SIDE_LEFT:       B_i := alpha*op( A_i )*B_i.\nHIPBLAS_SIDE_RIGHT:      B_i := alpha*B_i*op( A_i ).\n\n@param[in]\nuplo    [hipblasFillMode_t]\nSpecifies whether the matrix A is an upper or lower triangular matrix as follows:\nHIPBLAS_FILL_MODE_UPPER:  A is an upper triangular matrix.\nHIPBLAS_FILL_MODE_LOWER:  A is a  lower triangular matrix.\n\n@param[in]\ntransA  [hipblasOperation_t]\nSpecifies the form of op(A_i) to be used in the matrix multiplication as follows:\nHIPBLAS_OP_N:  op(A_i) = A_i.\nHIPBLAS_OP_T:  op(A_i) = A_i^T.\nHIPBLAS_OP_C:  op(A_i) = A_i^H.\n\n@param[in]\ndiag    [hipblasDiagType_t]\nSpecifies whether or not A_i is unit triangular as follows:\nHIPBLAS_DIAG_UNIT:      A_i is assumed to be unit triangular.\nHIPBLAS_DIAG_NON_UNIT:  A_i is not assumed to be unit triangular.\n\n@param[in]\nm       [int]\nm specifies the number of rows of B_i and C_i. m >= 0.\n\n@param[in]\nn       [int]\nn specifies the number of columns of B_i and C_i. n >= 0.\n\n@param[in]\nalpha\nalpha specifies the scalar alpha. When alpha is\nzero then A_i is not referenced and B_i need not be set before\nentry.\n\n@param[in]\nA       Device array of device pointers storing each matrix A_i on the GPU.\nEach A_i is of dimension ( lda, k ), where k is m\nwhen  side == HIPBLAS_SIDE_LEFT  and\nis  n  when  side == HIPBLAS_SIDE_RIGHT.\n\nWhen uplo == HIPBLAS_FILL_MODE_UPPER the  leading  k by k\nupper triangular part of the array  A must contain the upper\ntriangular matrix  and the strictly lower triangular part of\nA is not referenced.\n\nWhen uplo == HIPBLAS_FILL_MODE_LOWER the  leading  k by k\nlower triangular part of the array  A must contain the lower\ntriangular matrix  and the strictly upper triangular part of\nA is not referenced.\n\nNote that when  diag == HIPBLAS_DIAG_UNIT  the diagonal elements of\nA_i  are not referenced either,  but are assumed to be  unity.\n\n@param[in]\nlda     [int]\nlda specifies the first dimension of A.\nif side == HIPBLAS_SIDE_LEFT,  lda >= max( 1, m ),\nif side == HIPBLAS_SIDE_RIGHT, lda >= max( 1, n ).\n\n@param[inout]\nB       device array of device pointers storing each matrix B_i of\ndimension (ldb, n) on the GPU.\n\n@param[in]\nldb    [int]\nldb specifies the first dimension of B_i. ldb >= max( 1, m ).\n\n@param[in]\nC      device array of device pointers storing each matrix C_i of\ndimension (ldc, n) on the GPU. Users can pass in the same\nmatrices B to parameter C to achieve in-place functionality of trmmBatched.\n\n@param[in]\nldc    lec specifies the first dimension of C_i. ldc >= max( 1, m ).\n\n@param[in]\nbatchCount [int]\nnumber of instances i in the batch."]
    pub fn hipblasStrmmBatched(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        alpha: *const f32,
        A: *const *const f32,
        lda: ::std::os::raw::c_int,
        B: *const *const f32,
        ldb: ::std::os::raw::c_int,
        C: *const *mut f32,
        ldc: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDtrmmBatched(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        alpha: *const f64,
        A: *const *const f64,
        lda: ::std::os::raw::c_int,
        B: *const *const f64,
        ldb: ::std::os::raw::c_int,
        C: *const *mut f64,
        ldc: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCtrmmBatched(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        alpha: *const hipblasComplex,
        A: *const *const hipblasComplex,
        lda: ::std::os::raw::c_int,
        B: *const *const hipblasComplex,
        ldb: ::std::os::raw::c_int,
        C: *const *mut hipblasComplex,
        ldc: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZtrmmBatched(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        alpha: *const hipblasDoubleComplex,
        A: *const *const hipblasDoubleComplex,
        lda: ::std::os::raw::c_int,
        B: *const *const hipblasDoubleComplex,
        ldb: ::std::os::raw::c_int,
        C: *const *mut hipblasDoubleComplex,
        ldc: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCtrmmBatched_v2(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        alpha: *const hipComplex,
        A: *const *const hipComplex,
        lda: ::std::os::raw::c_int,
        B: *const *const hipComplex,
        ldb: ::std::os::raw::c_int,
        C: *const *mut hipComplex,
        ldc: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZtrmmBatched_v2(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        alpha: *const hipDoubleComplex,
        A: *const *const hipDoubleComplex,
        lda: ::std::os::raw::c_int,
        B: *const *const hipDoubleComplex,
        ldb: ::std::os::raw::c_int,
        C: *const *mut hipDoubleComplex,
        ldc: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 3 API\n\n\\details\n\ntrmmStridedBatched performs one of the strided_batched matrix-matrix operations\n\nC_i := alpha*op( A_i )*B_i,   or   C_i := alpha*B_i*op( A_i )  for i = 0, 1, ... batchCount -1\n\nwhere alpha is a scalar,  B_i and C_i are m by n matrices, A_i is a unit, or\nnon-unit, upper or lower triangular matrix and op( A_i ) is one of\n\nop( A_i ) = A_i   or   op( A_i ) = A_i^T   or   op( A_i ) = A_i^H.\n\nNote that trmmStridedBatched can provide in-place functionality by passing\nin the same address for both matrices B and C and by setting ldb equal to ldc.\n\n- Supported precisions in rocBLAS : s,d,c,z\n- Supported precisions in cuBLAS  : No support\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n\n@param[in]\nside    [hipblasSideMode_t]\nSpecifies whether op(A_i) multiplies B_i from the left or right as follows:\nHIPBLAS_SIDE_LEFT:       C_i := alpha*op( A_i )*B_i.\nHIPBLAS_SIDE_RIGHT:      C_i := alpha*B_i*op( A_i ).\n\n@param[in]\nuplo    [hipblasFillMode_t]\nSpecifies whether the matrix A is an upper or lower triangular matrix as follows:\nHIPBLAS_FILL_MODE_UPPER:  A is an upper triangular matrix.\nHIPBLAS_FILL_MODE_LOWER:  A is a  lower triangular matrix.\n\n@param[in]\ntransA  [hipblasOperation_t]\nSpecifies the form of op(A_i) to be used in the matrix multiplication as follows:\nHIPBLAS_OP_N:  op(A_i) = A_i.\nHIPBLAS_OP_T:  op(A_i) = A_i^T.\nHIPBLAS_OP_C:  op(A_i) = A_i^H.\n\n@param[in]\ndiag    [hipblasDiagType_t]\nSpecifies whether or not A_i is unit triangular as follows:\nHIPBLAS_DIAG_UNIT:      A_i is assumed to be unit triangular.\nHIPBLAS_DIAG_NON_UNIT:  A_i is not assumed to be unit triangular.\n\n@param[in]\nm       [int]\nm specifies the number of rows of B_i and C_i. m >= 0.\n\n@param[in]\nn       [int]\nn specifies the number of columns of B_i and C_i. n >= 0.\n\n@param[in]\nalpha\nalpha specifies the scalar alpha. When alpha is\nzero then A_i is not referenced and B_i need not be set before\nentry.\n\n@param[in]\nA       Device pointer to the first matrix A_0 on the GPU.\nEach A_i is of dimension ( lda, k ), where k is m\nwhen  side == HIPBLAS_SIDE_LEFT  and\nis  n  when  side == HIPBLAS_SIDE_RIGHT.\n\nWhen uplo == HIPBLAS_FILL_MODE_UPPER the  leading  k by k\nupper triangular part of the array  A must contain the upper\ntriangular matrix  and the strictly lower triangular part of\nA is not referenced.\n\nWhen uplo == HIPBLAS_FILL_MODE_LOWER the  leading  k by k\nlower triangular part of the array  A must contain the lower\ntriangular matrix  and the strictly upper triangular part of\nA is not referenced.\n\nNote that when  diag == HIPBLAS_DIAG_UNIT  the diagonal elements of\nA_i  are not referenced either,  but are assumed to be  unity.\n\n@param[in]\nlda     [int]\nlda specifies the first dimension of A.\nif side == HIPBLAS_SIDE_LEFT,  lda >= max( 1, m ),\nif side == HIPBLAS_SIDE_RIGHT, lda >= max( 1, n ).\n\n@param[in]\nstrideA  [hipblasStride]\nstride from the start of one matrix (A_i) and the next one (A_i+1)\n\n@param[inout]\nB      Device pointer to the first matrix B_0 on the GPU. Each B_i is of\ndimension ( ldb, n )\n\n@param[in]\nldb    [int]\nldb specifies the first dimension of B_i. ldb >= max( 1, m ).\n\n@param[in]\nstrideB  [hipblasStride]\nstride from the start of one matrix (B_i) and the next one (B_i+1)\n\n@param[in]\nC      Device pointer to the first matrix C_0 on the GPU. Each C_i is of\ndimension ( ldc, n ).\n\n@param[in]\nldc    [int]\nldc specifies the first dimension of C_i. ldc >= max( 1, m ).\n\n@param[in]\nstrideC [hipblasStride]\nstride from the start of one matrix (C_i) and the next one (C_i+1)\n\n@param[in]\nbatchCount [int]\nnumber of instances i in the batch."]
    pub fn hipblasStrmmStridedBatched(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        alpha: *const f32,
        A: *const f32,
        lda: ::std::os::raw::c_int,
        strideA: hipblasStride,
        B: *const f32,
        ldb: ::std::os::raw::c_int,
        strideB: hipblasStride,
        C: *mut f32,
        ldc: ::std::os::raw::c_int,
        strideC: hipblasStride,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDtrmmStridedBatched(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        alpha: *const f64,
        A: *const f64,
        lda: ::std::os::raw::c_int,
        strideA: hipblasStride,
        B: *const f64,
        ldb: ::std::os::raw::c_int,
        strideB: hipblasStride,
        C: *mut f64,
        ldc: ::std::os::raw::c_int,
        strideC: hipblasStride,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCtrmmStridedBatched(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        alpha: *const hipblasComplex,
        A: *const hipblasComplex,
        lda: ::std::os::raw::c_int,
        strideA: hipblasStride,
        B: *const hipblasComplex,
        ldb: ::std::os::raw::c_int,
        strideB: hipblasStride,
        C: *mut hipblasComplex,
        ldc: ::std::os::raw::c_int,
        strideC: hipblasStride,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZtrmmStridedBatched(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        alpha: *const hipblasDoubleComplex,
        A: *const hipblasDoubleComplex,
        lda: ::std::os::raw::c_int,
        strideA: hipblasStride,
        B: *const hipblasDoubleComplex,
        ldb: ::std::os::raw::c_int,
        strideB: hipblasStride,
        C: *mut hipblasDoubleComplex,
        ldc: ::std::os::raw::c_int,
        strideC: hipblasStride,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCtrmmStridedBatched_v2(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        alpha: *const hipComplex,
        A: *const hipComplex,
        lda: ::std::os::raw::c_int,
        strideA: hipblasStride,
        B: *const hipComplex,
        ldb: ::std::os::raw::c_int,
        strideB: hipblasStride,
        C: *mut hipComplex,
        ldc: ::std::os::raw::c_int,
        strideC: hipblasStride,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZtrmmStridedBatched_v2(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        alpha: *const hipDoubleComplex,
        A: *const hipDoubleComplex,
        lda: ::std::os::raw::c_int,
        strideA: hipblasStride,
        B: *const hipDoubleComplex,
        ldb: ::std::os::raw::c_int,
        strideB: hipblasStride,
        C: *mut hipDoubleComplex,
        ldc: ::std::os::raw::c_int,
        strideC: hipblasStride,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 3 API\n\n\\details\n\ntrsm solves\n\nop(A)*X = alpha*B or  X*op(A) = alpha*B,\n\nwhere alpha is a scalar, X and B are m by n matrices,\nA is triangular matrix and op(A) is one of\n\nop( A ) = A   or   op( A ) = A^T   or   op( A ) = A^H.\n\nThe matrix X is overwritten on B.\n\nNote about memory allocation:\nWhen trsm is launched with a k evenly divisible by the internal block size of 128,\nand is no larger than 10 of these blocks, the API takes advantage of utilizing pre-allocated\nmemory found in the handle to increase overall performance. This memory can be managed by using\nthe environment variable WORKBUF_TRSM_B_CHNK. When this variable is not set the device memory\nused for temporary storage will default to 1 MB and may result in chunking, which in turn may\nreduce performance. Under these circumstances it is recommended that WORKBUF_TRSM_B_CHNK be set\nto the desired chunk of right hand sides to be used at a time.\n\n(where k is m when HIPBLAS_SIDE_LEFT and is n when HIPBLAS_SIDE_RIGHT)\n\n- Supported precisions in rocBLAS : s,d,c,z\n- Supported precisions in cuBLAS  : s,d,c,z\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n\n@param[in]\nside    [hipblasSideMode_t]\nHIPBLAS_SIDE_LEFT:       op(A)*X = alpha*B.\nHIPBLAS_SIDE_RIGHT:      X*op(A) = alpha*B.\n\n@param[in]\nuplo    [hipblasFillMode_t]\nHIPBLAS_FILL_MODE_UPPER:  A is an upper triangular matrix.\nHIPBLAS_FILL_MODE_LOWER:  A is a  lower triangular matrix.\n\n@param[in]\ntransA  [hipblasOperation_t]\nHIPBLAS_OP_N: op(A) = A.\nHIPBLAS_OP_T: op(A) = A^T.\nHIPBLAS_OP_C: op(A) = A^H.\n\n@param[in]\ndiag    [hipblasDiagType_t]\nHIPBLAS_DIAG_UNIT:     A is assumed to be unit triangular.\nHIPBLAS_DIAG_NON_UNIT:  A is not assumed to be unit triangular.\n\n@param[in]\nm       [int]\nm specifies the number of rows of B. m >= 0.\n\n@param[in]\nn       [int]\nn specifies the number of columns of B. n >= 0.\n\n@param[in]\nalpha\ndevice pointer or host pointer specifying the scalar alpha. When alpha is\n&zero then A is not referenced and B need not be set before\nentry.\n\n@param[in]\nAP       device pointer storing matrix A.\nof dimension ( lda, k ), where k is m\nwhen  HIPBLAS_SIDE_LEFT  and\nis  n  when  HIPBLAS_SIDE_RIGHT\nonly the upper/lower triangular part is accessed.\n\n@param[in]\nlda     [int]\nlda specifies the first dimension of A.\nif side = HIPBLAS_SIDE_LEFT,  lda >= max( 1, m ),\nif side = HIPBLAS_SIDE_RIGHT, lda >= max( 1, n ).\n\n@param[in,out]\nBP       device pointer storing matrix B.\n\n@param[in]\nldb    [int]\nldb specifies the first dimension of B. ldb >= max( 1, m ).\n"]
    pub fn hipblasStrsm(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        alpha: *const f32,
        AP: *const f32,
        lda: ::std::os::raw::c_int,
        BP: *mut f32,
        ldb: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDtrsm(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        alpha: *const f64,
        AP: *const f64,
        lda: ::std::os::raw::c_int,
        BP: *mut f64,
        ldb: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCtrsm(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        alpha: *const hipblasComplex,
        AP: *const hipblasComplex,
        lda: ::std::os::raw::c_int,
        BP: *mut hipblasComplex,
        ldb: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZtrsm(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        alpha: *const hipblasDoubleComplex,
        AP: *const hipblasDoubleComplex,
        lda: ::std::os::raw::c_int,
        BP: *mut hipblasDoubleComplex,
        ldb: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCtrsm_v2(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        alpha: *const hipComplex,
        AP: *const hipComplex,
        lda: ::std::os::raw::c_int,
        BP: *mut hipComplex,
        ldb: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZtrsm_v2(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        alpha: *const hipDoubleComplex,
        AP: *const hipDoubleComplex,
        lda: ::std::os::raw::c_int,
        BP: *mut hipDoubleComplex,
        ldb: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 3 API\n\\details\ntrsmBatched performs the following batched operation:\n\nop(A_i)*X_i = alpha*B_i or  X_i*op(A_i) = alpha*B_i, for i = 1, ..., batchCount.\n\nwhere alpha is a scalar, X and B are batched m by n matrices,\nA is triangular batched matrix and op(A) is one of\n\nop( A ) = A   or   op( A ) = A^T   or   op( A ) = A^H.\n\nEach matrix X_i is overwritten on B_i for i = 1, ..., batchCount.\n\nNote about memory allocation:\nWhen trsm is launched with a k evenly divisible by the internal block size of 128,\nand is no larger than 10 of these blocks, the API takes advantage of utilizing pre-allocated\nmemory found in the handle to increase overall performance. This memory can be managed by using\nthe environment variable WORKBUF_TRSM_B_CHNK. When this variable is not set the device memory\nused for temporary storage will default to 1 MB and may result in chunking, which in turn may\nreduce performance. Under these circumstances it is recommended that WORKBUF_TRSM_B_CHNK be set\nto the desired chunk of right hand sides to be used at a time.\n(where k is m when HIPBLAS_SIDE_LEFT and is n when HIPBLAS_SIDE_RIGHT)\n\n- Supported precisions in rocBLAS : s,d,c,z\n- Supported precisions in cuBLAS  : s,d,c,z\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n@param[in]\nside    [hipblasSideMode_t]\nHIPBLAS_SIDE_LEFT:       op(A)*X = alpha*B.\nHIPBLAS_SIDE_RIGHT:      X*op(A) = alpha*B.\n@param[in]\nuplo    [hipblasFillMode_t]\nHIPBLAS_FILL_MODE_UPPER:  each A_i is an upper triangular matrix.\nHIPBLAS_FILL_MODE_LOWER:  each A_i is a  lower triangular matrix.\n@param[in]\ntransA  [hipblasOperation_t]\nHIPBLAS_OP_N: op(A) = A.\nHIPBLAS_OP_T: op(A) = A^T.\nHIPBLAS_OP_C: op(A) = A^H.\n@param[in]\ndiag    [hipblasDiagType_t]\nHIPBLAS_DIAG_UNIT:     each A_i is assumed to be unit triangular.\nHIPBLAS_DIAG_NON_UNIT:  each A_i is not assumed to be unit triangular.\n@param[in]\nm       [int]\nm specifies the number of rows of each B_i. m >= 0.\n@param[in]\nn       [int]\nn specifies the number of columns of each B_i. n >= 0.\n@param[in]\nalpha\ndevice pointer or host pointer specifying the scalar alpha. When alpha is\n&zero then A is not referenced and B need not be set before\nentry.\n@param[in]\nAP       device array of device pointers storing each matrix A_i on the GPU.\nMatricies are of dimension ( lda, k ), where k is m\nwhen  HIPBLAS_SIDE_LEFT  and is  n  when  HIPBLAS_SIDE_RIGHT\nonly the upper/lower triangular part is accessed.\n@param[in]\nlda     [int]\nlda specifies the first dimension of each A_i.\nif side = HIPBLAS_SIDE_LEFT,  lda >= max( 1, m ),\nif side = HIPBLAS_SIDE_RIGHT, lda >= max( 1, n ).\n@param[in,out]\nBP       device array of device pointers storing each matrix B_i on the GPU.\n@param[in]\nldb    [int]\nldb specifies the first dimension of each B_i. ldb >= max( 1, m ).\n@param[in]\nbatchCount [int]\nnumber of trsm operatons in the batch."]
    pub fn hipblasStrsmBatched(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        alpha: *const f32,
        AP: *const *const f32,
        lda: ::std::os::raw::c_int,
        BP: *const *mut f32,
        ldb: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDtrsmBatched(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        alpha: *const f64,
        AP: *const *const f64,
        lda: ::std::os::raw::c_int,
        BP: *const *mut f64,
        ldb: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCtrsmBatched(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        alpha: *const hipblasComplex,
        AP: *const *const hipblasComplex,
        lda: ::std::os::raw::c_int,
        BP: *const *mut hipblasComplex,
        ldb: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZtrsmBatched(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        alpha: *const hipblasDoubleComplex,
        AP: *const *const hipblasDoubleComplex,
        lda: ::std::os::raw::c_int,
        BP: *const *mut hipblasDoubleComplex,
        ldb: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCtrsmBatched_v2(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        alpha: *const hipComplex,
        AP: *const *const hipComplex,
        lda: ::std::os::raw::c_int,
        BP: *const *mut hipComplex,
        ldb: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZtrsmBatched_v2(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        alpha: *const hipDoubleComplex,
        AP: *const *const hipDoubleComplex,
        lda: ::std::os::raw::c_int,
        BP: *const *mut hipDoubleComplex,
        ldb: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 3 API\n\\details\ntrsmSridedBatched performs the following strided batched operation:\n\nop(A_i)*X_i = alpha*B_i or  X_i*op(A_i) = alpha*B_i, for i = 1, ..., batchCount.\n\nwhere alpha is a scalar, X and B are strided batched m by n matrices,\nA is triangular strided batched matrix and op(A) is one of\n\nop( A ) = A   or   op( A ) = A^T   or   op( A ) = A^H.\n\nEach matrix X_i is overwritten on B_i for i = 1, ..., batchCount.\n\nNote about memory allocation:\nWhen trsm is launched with a k evenly divisible by the internal block size of 128,\nand is no larger than 10 of these blocks, the API takes advantage of utilizing pre-allocated\nmemory found in the handle to increase overall performance. This memory can be managed by using\nthe environment variable WORKBUF_TRSM_B_CHNK. When this variable is not set the device memory\nused for temporary storage will default to 1 MB and may result in chunking, which in turn may\nreduce performance. Under these circumstances it is recommended that WORKBUF_TRSM_B_CHNK be set\nto the desired chunk of right hand sides to be used at a time.\n(where k is m when HIPBLAS_SIDE_LEFT and is n when HIPBLAS_SIDE_RIGHT)\n\n- Supported precisions in rocBLAS : s,d,c,z\n- Supported precisions in cuBLAS  : No support\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n@param[in]\nside    [hipblasSideMode_t]\nHIPBLAS_SIDE_LEFT:       op(A)*X = alpha*B.\nHIPBLAS_SIDE_RIGHT:      X*op(A) = alpha*B.\n@param[in]\nuplo    [hipblasFillMode_t]\nHIPBLAS_FILL_MODE_UPPER:  each A_i is an upper triangular matrix.\nHIPBLAS_FILL_MODE_LOWER:  each A_i is a  lower triangular matrix.\n@param[in]\ntransA  [hipblasOperation_t]\nHIPBLAS_OP_N: op(A) = A.\nHIPBLAS_OP_T: op(A) = A^T.\nHIPBLAS_OP_C: op(A) = A^H.\n@param[in]\ndiag    [hipblasDiagType_t]\nHIPBLAS_DIAG_UNIT:     each A_i is assumed to be unit triangular.\nHIPBLAS_DIAG_NON_UNIT:  each A_i is not assumed to be unit triangular.\n@param[in]\nm       [int]\nm specifies the number of rows of each B_i. m >= 0.\n@param[in]\nn       [int]\nn specifies the number of columns of each B_i. n >= 0.\n@param[in]\nalpha\ndevice pointer or host pointer specifying the scalar alpha. When alpha is\n&zero then A is not referenced and B need not be set before\nentry.\n@param[in]\nAP       device pointer pointing to the first matrix A_1.\nof dimension ( lda, k ), where k is m\nwhen  HIPBLAS_SIDE_LEFT  and\nis  n  when  HIPBLAS_SIDE_RIGHT\nonly the upper/lower triangular part is accessed.\n@param[in]\nlda     [int]\nlda specifies the first dimension of each A_i.\nif side = HIPBLAS_SIDE_LEFT,  lda >= max( 1, m ),\nif side = HIPBLAS_SIDE_RIGHT, lda >= max( 1, n ).\n@param[in]\nstrideA [hipblasStride]\nstride from the start of one A_i matrix to the next A_(i + 1).\n@param[in,out]\nBP       device pointer pointing to the first matrix B_1.\n@param[in]\nldb    [int]\nldb specifies the first dimension of each B_i. ldb >= max( 1, m ).\n@param[in]\nstrideB [hipblasStride]\nstride from the start of one B_i matrix to the next B_(i + 1).\n@param[in]\nbatchCount [int]\nnumber of trsm operatons in the batch."]
    pub fn hipblasStrsmStridedBatched(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        alpha: *const f32,
        AP: *const f32,
        lda: ::std::os::raw::c_int,
        strideA: hipblasStride,
        BP: *mut f32,
        ldb: ::std::os::raw::c_int,
        strideB: hipblasStride,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDtrsmStridedBatched(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        alpha: *const f64,
        AP: *const f64,
        lda: ::std::os::raw::c_int,
        strideA: hipblasStride,
        BP: *mut f64,
        ldb: ::std::os::raw::c_int,
        strideB: hipblasStride,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCtrsmStridedBatched(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        alpha: *const hipblasComplex,
        AP: *const hipblasComplex,
        lda: ::std::os::raw::c_int,
        strideA: hipblasStride,
        BP: *mut hipblasComplex,
        ldb: ::std::os::raw::c_int,
        strideB: hipblasStride,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZtrsmStridedBatched(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        alpha: *const hipblasDoubleComplex,
        AP: *const hipblasDoubleComplex,
        lda: ::std::os::raw::c_int,
        strideA: hipblasStride,
        BP: *mut hipblasDoubleComplex,
        ldb: ::std::os::raw::c_int,
        strideB: hipblasStride,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCtrsmStridedBatched_v2(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        alpha: *const hipComplex,
        AP: *const hipComplex,
        lda: ::std::os::raw::c_int,
        strideA: hipblasStride,
        BP: *mut hipComplex,
        ldb: ::std::os::raw::c_int,
        strideB: hipblasStride,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZtrsmStridedBatched_v2(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        alpha: *const hipDoubleComplex,
        AP: *const hipDoubleComplex,
        lda: ::std::os::raw::c_int,
        strideA: hipblasStride,
        BP: *mut hipDoubleComplex,
        ldb: ::std::os::raw::c_int,
        strideB: hipblasStride,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 3 API\n\n\\details\ntrtri  compute the inverse of a matrix A, namely, invA\n\nand write the result into invA;\n\n- Supported precisions in rocBLAS : s,d,c,z\n- Supported precisions in cuBLAS  : No support\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n@param[in]\nuplo      [hipblasFillMode_t]\nspecifies whether the upper 'HIPBLAS_FILL_MODE_UPPER' or lower 'HIPBLAS_FILL_MODE_LOWER'\nif HIPBLAS_FILL_MODE_UPPER, the lower part of A is not referenced\nif HIPBLAS_FILL_MODE_LOWER, the upper part of A is not referenced\n@param[in]\ndiag      [hipblasDiagType_t]\n= 'HIPBLAS_DIAG_NON_UNIT', A is non-unit triangular;\n= 'HIPBLAS_DIAG_UNIT', A is unit triangular;\n@param[in]\nn         [int]\nsize of matrix A and invA\n@param[in]\nAP         device pointer storing matrix A.\n@param[in]\nlda       [int]\nspecifies the leading dimension of A.\n@param[out]\ninvA      device pointer storing matrix invA.\n@param[in]\nldinvA    [int]\nspecifies the leading dimension of invA."]
    pub fn hipblasStrtri(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        diag: hipblasDiagType_t,
        n: ::std::os::raw::c_int,
        AP: *const f32,
        lda: ::std::os::raw::c_int,
        invA: *mut f32,
        ldinvA: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDtrtri(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        diag: hipblasDiagType_t,
        n: ::std::os::raw::c_int,
        AP: *const f64,
        lda: ::std::os::raw::c_int,
        invA: *mut f64,
        ldinvA: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCtrtri(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        diag: hipblasDiagType_t,
        n: ::std::os::raw::c_int,
        AP: *const hipblasComplex,
        lda: ::std::os::raw::c_int,
        invA: *mut hipblasComplex,
        ldinvA: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZtrtri(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        diag: hipblasDiagType_t,
        n: ::std::os::raw::c_int,
        AP: *const hipblasDoubleComplex,
        lda: ::std::os::raw::c_int,
        invA: *mut hipblasDoubleComplex,
        ldinvA: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCtrtri_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        diag: hipblasDiagType_t,
        n: ::std::os::raw::c_int,
        AP: *const hipComplex,
        lda: ::std::os::raw::c_int,
        invA: *mut hipComplex,
        ldinvA: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZtrtri_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        diag: hipblasDiagType_t,
        n: ::std::os::raw::c_int,
        AP: *const hipDoubleComplex,
        lda: ::std::os::raw::c_int,
        invA: *mut hipDoubleComplex,
        ldinvA: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 3 API\n\n\\details\ntrtriBatched  compute the inverse of A_i and write into invA_i where\nA_i and invA_i are the i-th matrices in the batch,\nfor i = 1, ..., batchCount.\n\n- Supported precisions in rocBLAS : s,d,c,z\n- Supported precisions in cuBLAS  : No support\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n@param[in]\nuplo      [hipblasFillMode_t]\nspecifies whether the upper 'HIPBLAS_FILL_MODE_UPPER' or lower 'HIPBLAS_FILL_MODE_LOWER'\n@param[in]\ndiag      [hipblasDiagType_t]\n= 'HIPBLAS_DIAG_NON_UNIT', A is non-unit triangular;\n= 'HIPBLAS_DIAG_UNIT', A is unit triangular;\n@param[in]\nn         [int]\n@param[in]\nAP         device array of device pointers storing each matrix A_i.\n@param[in]\nlda       [int]\nspecifies the leading dimension of each A_i.\n@param[out]\ninvA      device array of device pointers storing the inverse of each matrix A_i.\nPartial inplace operation is supported, see below.\nIf UPLO = 'U', the leading N-by-N upper triangular part of the invA will store\nthe inverse of the upper triangular matrix, and the strictly lower\ntriangular part of invA is cleared.\nIf UPLO = 'L', the leading N-by-N lower triangular part of the invA will store\nthe inverse of the lower triangular matrix, and the strictly upper\ntriangular part of invA is cleared.\n@param[in]\nldinvA    [int]\nspecifies the leading dimension of each invA_i.\n@param[in]\nbatchCount [int]\nnumbers of matrices in the batch"]
    pub fn hipblasStrtriBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        diag: hipblasDiagType_t,
        n: ::std::os::raw::c_int,
        AP: *const *const f32,
        lda: ::std::os::raw::c_int,
        invA: *mut *mut f32,
        ldinvA: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDtrtriBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        diag: hipblasDiagType_t,
        n: ::std::os::raw::c_int,
        AP: *const *const f64,
        lda: ::std::os::raw::c_int,
        invA: *mut *mut f64,
        ldinvA: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCtrtriBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        diag: hipblasDiagType_t,
        n: ::std::os::raw::c_int,
        AP: *const *const hipblasComplex,
        lda: ::std::os::raw::c_int,
        invA: *mut *mut hipblasComplex,
        ldinvA: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZtrtriBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        diag: hipblasDiagType_t,
        n: ::std::os::raw::c_int,
        AP: *const *const hipblasDoubleComplex,
        lda: ::std::os::raw::c_int,
        invA: *mut *mut hipblasDoubleComplex,
        ldinvA: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCtrtriBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        diag: hipblasDiagType_t,
        n: ::std::os::raw::c_int,
        AP: *const *const hipComplex,
        lda: ::std::os::raw::c_int,
        invA: *mut *mut hipComplex,
        ldinvA: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZtrtriBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        diag: hipblasDiagType_t,
        n: ::std::os::raw::c_int,
        AP: *const *const hipDoubleComplex,
        lda: ::std::os::raw::c_int,
        invA: *mut *mut hipDoubleComplex,
        ldinvA: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 3 API\n\n\\details\ntrtriStridedBatched compute the inverse of A_i and write into invA_i where\nA_i and invA_i are the i-th matrices in the batch,\nfor i = 1, ..., batchCount\n\n- Supported precisions in rocBLAS : s,d,c,z\n- Supported precisions in cuBLAS  : No support\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n@param[in]\nuplo      [hipblasFillMode_t]\nspecifies whether the upper 'HIPBLAS_FILL_MODE_UPPER' or lower 'HIPBLAS_FILL_MODE_LOWER'\n@param[in]\ndiag      [hipblasDiagType_t]\n= 'HIPBLAS_DIAG_NON_UNIT', A is non-unit triangular;\n= 'HIPBLAS_DIAG_UNIT', A is unit triangular;\n@param[in]\nn         [int]\n@param[in]\nAP         device pointer pointing to address of first matrix A_1.\n@param[in]\nlda       [int]\nspecifies the leading dimension of each A.\n@param[in]\nstrideA  [hipblasStride]\n\"batch stride a\": stride from the start of one A_i matrix to the next A_(i + 1).\n@param[out]\ninvA      device pointer storing the inverses of each matrix A_i.\nPartial inplace operation is supported, see below.\nIf UPLO = 'U', the leading N-by-N upper triangular part of the invA will store\nthe inverse of the upper triangular matrix, and the strictly lower\ntriangular part of invA is cleared.\nIf UPLO = 'L', the leading N-by-N lower triangular part of the invA will store\nthe inverse of the lower triangular matrix, and the strictly upper\ntriangular part of invA is cleared.\n@param[in]\nldinvA    [int]\nspecifies the leading dimension of each invA_i.\n@param[in]\nstride_invA  [hipblasStride]\n\"batch stride invA\": stride from the start of one invA_i matrix to the next invA_(i + 1).\n@param[in]\nbatchCount  [int]\nnumbers of matrices in the batch"]
    pub fn hipblasStrtriStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        diag: hipblasDiagType_t,
        n: ::std::os::raw::c_int,
        AP: *const f32,
        lda: ::std::os::raw::c_int,
        strideA: hipblasStride,
        invA: *mut f32,
        ldinvA: ::std::os::raw::c_int,
        stride_invA: hipblasStride,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDtrtriStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        diag: hipblasDiagType_t,
        n: ::std::os::raw::c_int,
        AP: *const f64,
        lda: ::std::os::raw::c_int,
        strideA: hipblasStride,
        invA: *mut f64,
        ldinvA: ::std::os::raw::c_int,
        stride_invA: hipblasStride,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCtrtriStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        diag: hipblasDiagType_t,
        n: ::std::os::raw::c_int,
        AP: *const hipblasComplex,
        lda: ::std::os::raw::c_int,
        strideA: hipblasStride,
        invA: *mut hipblasComplex,
        ldinvA: ::std::os::raw::c_int,
        stride_invA: hipblasStride,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZtrtriStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        diag: hipblasDiagType_t,
        n: ::std::os::raw::c_int,
        AP: *const hipblasDoubleComplex,
        lda: ::std::os::raw::c_int,
        strideA: hipblasStride,
        invA: *mut hipblasDoubleComplex,
        ldinvA: ::std::os::raw::c_int,
        stride_invA: hipblasStride,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCtrtriStridedBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        diag: hipblasDiagType_t,
        n: ::std::os::raw::c_int,
        AP: *const hipComplex,
        lda: ::std::os::raw::c_int,
        strideA: hipblasStride,
        invA: *mut hipComplex,
        ldinvA: ::std::os::raw::c_int,
        stride_invA: hipblasStride,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZtrtriStridedBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        diag: hipblasDiagType_t,
        n: ::std::os::raw::c_int,
        AP: *const hipDoubleComplex,
        lda: ::std::os::raw::c_int,
        strideA: hipblasStride,
        invA: *mut hipDoubleComplex,
        ldinvA: ::std::os::raw::c_int,
        stride_invA: hipblasStride,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 3 API\n\n\\details\ndgmm performs one of the matrix-matrix operations\n\nC = A * diag(x) if side == HIPBLAS_SIDE_RIGHT\nC = diag(x) * A if side == HIPBLAS_SIDE_LEFT\n\nwhere C and A are m by n dimensional matrices. diag( x ) is a diagonal matrix\nand x is vector of dimension n if side == HIPBLAS_SIDE_RIGHT and dimension m\nif side == HIPBLAS_SIDE_LEFT.\n\n- Supported precisions in rocBLAS : s,d,c,z\n- Supported precisions in cuBLAS  : s,d,c,z\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n@param[in]\nside      [hipblasSideMode_t]\nspecifies the side of diag(x)\n@param[in]\nm         [int]\nmatrix dimension m.\n@param[in]\nn         [int]\nmatrix dimension n.\n@param[in]\nAP         device pointer storing matrix A.\n@param[in]\nlda       [int]\nspecifies the leading dimension of A.\n@param[in]\nx         device pointer storing vector x.\n@param[in]\nincx      [int]\nspecifies the increment between values of x\n@param[in, out]\nCP         device pointer storing matrix C.\n@param[in]\nldc       [int]\nspecifies the leading dimension of C.\n"]
    pub fn hipblasSdgmm(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        AP: *const f32,
        lda: ::std::os::raw::c_int,
        x: *const f32,
        incx: ::std::os::raw::c_int,
        CP: *mut f32,
        ldc: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDdgmm(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        AP: *const f64,
        lda: ::std::os::raw::c_int,
        x: *const f64,
        incx: ::std::os::raw::c_int,
        CP: *mut f64,
        ldc: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCdgmm(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        AP: *const hipblasComplex,
        lda: ::std::os::raw::c_int,
        x: *const hipblasComplex,
        incx: ::std::os::raw::c_int,
        CP: *mut hipblasComplex,
        ldc: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZdgmm(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        AP: *const hipblasDoubleComplex,
        lda: ::std::os::raw::c_int,
        x: *const hipblasDoubleComplex,
        incx: ::std::os::raw::c_int,
        CP: *mut hipblasDoubleComplex,
        ldc: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCdgmm_v2(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        AP: *const hipComplex,
        lda: ::std::os::raw::c_int,
        x: *const hipComplex,
        incx: ::std::os::raw::c_int,
        CP: *mut hipComplex,
        ldc: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZdgmm_v2(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        AP: *const hipDoubleComplex,
        lda: ::std::os::raw::c_int,
        x: *const hipDoubleComplex,
        incx: ::std::os::raw::c_int,
        CP: *mut hipDoubleComplex,
        ldc: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 3 API\n\n\\details\ndgmmBatched performs one of the batched matrix-matrix operations\n\nC_i = A_i * diag(x_i) for i = 0, 1, ... batchCount-1 if side == HIPBLAS_SIDE_RIGHT\nC_i = diag(x_i) * A_i for i = 0, 1, ... batchCount-1 if side == HIPBLAS_SIDE_LEFT\n\nwhere C_i and A_i are m by n dimensional matrices. diag(x_i) is a diagonal matrix\nand x_i is vector of dimension n if side == HIPBLAS_SIDE_RIGHT and dimension m\nif side == HIPBLAS_SIDE_LEFT.\n\n- Supported precisions in rocBLAS : s,d,c,z\n- Supported precisions in cuBLAS  : No support\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n@param[in]\nside      [hipblasSideMode_t]\nspecifies the side of diag(x)\n@param[in]\nm         [int]\nmatrix dimension m.\n@param[in]\nn         [int]\nmatrix dimension n.\n@param[in]\nAP         device array of device pointers storing each matrix A_i on the GPU.\nEach A_i is of dimension ( lda, n )\n@param[in]\nlda       [int]\nspecifies the leading dimension of A_i.\n@param[in]\nx         device array of device pointers storing each vector x_i on the GPU.\nEach x_i is of dimension n if side == HIPBLAS_SIDE_RIGHT and dimension\nm if side == HIPBLAS_SIDE_LEFT\n@param[in]\nincx      [int]\nspecifies the increment between values of x_i\n@param[in, out]\nCP         device array of device pointers storing each matrix C_i on the GPU.\nEach C_i is of dimension ( ldc, n ).\n@param[in]\nldc       [int]\nspecifies the leading dimension of C_i.\n@param[in]\nbatchCount [int]\nnumber of instances in the batch.\n"]
    pub fn hipblasSdgmmBatched(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        AP: *const *const f32,
        lda: ::std::os::raw::c_int,
        x: *const *const f32,
        incx: ::std::os::raw::c_int,
        CP: *const *mut f32,
        ldc: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDdgmmBatched(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        AP: *const *const f64,
        lda: ::std::os::raw::c_int,
        x: *const *const f64,
        incx: ::std::os::raw::c_int,
        CP: *const *mut f64,
        ldc: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCdgmmBatched(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        AP: *const *const hipblasComplex,
        lda: ::std::os::raw::c_int,
        x: *const *const hipblasComplex,
        incx: ::std::os::raw::c_int,
        CP: *const *mut hipblasComplex,
        ldc: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZdgmmBatched(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        AP: *const *const hipblasDoubleComplex,
        lda: ::std::os::raw::c_int,
        x: *const *const hipblasDoubleComplex,
        incx: ::std::os::raw::c_int,
        CP: *const *mut hipblasDoubleComplex,
        ldc: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCdgmmBatched_v2(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        AP: *const *const hipComplex,
        lda: ::std::os::raw::c_int,
        x: *const *const hipComplex,
        incx: ::std::os::raw::c_int,
        CP: *const *mut hipComplex,
        ldc: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZdgmmBatched_v2(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        AP: *const *const hipDoubleComplex,
        lda: ::std::os::raw::c_int,
        x: *const *const hipDoubleComplex,
        incx: ::std::os::raw::c_int,
        CP: *const *mut hipDoubleComplex,
        ldc: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 3 API\n\n\\details\ndgmmStridedBatched performs one of the batched matrix-matrix operations\n\nC_i = A_i * diag(x_i)   if side == HIPBLAS_SIDE_RIGHT   for i = 0, 1, ... batchCount-1\nC_i = diag(x_i) * A_i   if side == HIPBLAS_SIDE_LEFT    for i = 0, 1, ... batchCount-1\n\nwhere C_i and A_i are m by n dimensional matrices. diag(x_i) is a diagonal matrix\nand x_i is vector of dimension n if side == HIPBLAS_SIDE_RIGHT and dimension m\nif side == HIPBLAS_SIDE_LEFT.\n\n- Supported precisions in rocBLAS : s,d,c,z\n- Supported precisions in cuBLAS  : No support\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n@param[in]\nside      [hipblasSideMode_t]\nspecifies the side of diag(x)\n@param[in]\nm         [int]\nmatrix dimension m.\n@param[in]\nn         [int]\nmatrix dimension n.\n@param[in]\nAP         device pointer to the first matrix A_0 on the GPU.\nEach A_i is of dimension ( lda, n )\n@param[in]\nlda       [int]\nspecifies the leading dimension of A.\n@param[in]\nstrideA  [hipblasStride]\nstride from the start of one matrix (A_i) and the next one (A_i+1)\n@param[in]\nx         pointer to the first vector x_0 on the GPU.\nEach x_i is of dimension n if side == HIPBLAS_SIDE_RIGHT and dimension\nm if side == HIPBLAS_SIDE_LEFT\n@param[in]\nincx      [int]\nspecifies the increment between values of x\n@param[in]\nstridex  [hipblasStride]\nstride from the start of one vector(x_i) and the next one (x_i+1)\n@param[in, out]\nCP         device pointer to the first matrix C_0 on the GPU.\nEach C_i is of dimension ( ldc, n ).\n@param[in]\nldc       [int]\nspecifies the leading dimension of C.\n@param[in]\nstrideC  [hipblasStride]\nstride from the start of one matrix (C_i) and the next one (C_i+1)\n@param[in]\nbatchCount [int]\nnumber of instances i in the batch.\n"]
    pub fn hipblasSdgmmStridedBatched(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        AP: *const f32,
        lda: ::std::os::raw::c_int,
        strideA: hipblasStride,
        x: *const f32,
        incx: ::std::os::raw::c_int,
        stridex: hipblasStride,
        CP: *mut f32,
        ldc: ::std::os::raw::c_int,
        strideC: hipblasStride,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDdgmmStridedBatched(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        AP: *const f64,
        lda: ::std::os::raw::c_int,
        strideA: hipblasStride,
        x: *const f64,
        incx: ::std::os::raw::c_int,
        stridex: hipblasStride,
        CP: *mut f64,
        ldc: ::std::os::raw::c_int,
        strideC: hipblasStride,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCdgmmStridedBatched(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        AP: *const hipblasComplex,
        lda: ::std::os::raw::c_int,
        strideA: hipblasStride,
        x: *const hipblasComplex,
        incx: ::std::os::raw::c_int,
        stridex: hipblasStride,
        CP: *mut hipblasComplex,
        ldc: ::std::os::raw::c_int,
        strideC: hipblasStride,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZdgmmStridedBatched(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        AP: *const hipblasDoubleComplex,
        lda: ::std::os::raw::c_int,
        strideA: hipblasStride,
        x: *const hipblasDoubleComplex,
        incx: ::std::os::raw::c_int,
        stridex: hipblasStride,
        CP: *mut hipblasDoubleComplex,
        ldc: ::std::os::raw::c_int,
        strideC: hipblasStride,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCdgmmStridedBatched_v2(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        AP: *const hipComplex,
        lda: ::std::os::raw::c_int,
        strideA: hipblasStride,
        x: *const hipComplex,
        incx: ::std::os::raw::c_int,
        stridex: hipblasStride,
        CP: *mut hipComplex,
        ldc: ::std::os::raw::c_int,
        strideC: hipblasStride,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZdgmmStridedBatched_v2(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        AP: *const hipDoubleComplex,
        lda: ::std::os::raw::c_int,
        strideA: hipblasStride,
        x: *const hipDoubleComplex,
        incx: ::std::os::raw::c_int,
        stridex: hipblasStride,
        CP: *mut hipDoubleComplex,
        ldc: ::std::os::raw::c_int,
        strideC: hipblasStride,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief SOLVER API\n\n\\details\ngetrf computes the LU factorization of a general n-by-n matrix A\nusing partial pivoting with row interchanges. The LU factorization can\nbe done without pivoting if ipiv is passed as a nullptr.\n\nIn the case that ipiv is not null, the factorization has the form:\n\n\\f[\nA = PLU\n\\f]\n\nwhere P is a permutation matrix, L is lower triangular with unit\ndiagonal elements, and U is upper triangular.\n\nIn the case that ipiv is null, the factorization is done without pivoting:\n\n\\f[\nA = LU\n\\f]\n\n- Supported precisions in rocSOLVER : s,d,c,z\n- Supported precisions in cuBLAS    : s,d,c,z\n\n@param[in]\nhandle    hipblasHandle_t.\n@param[in]\nn         int. n >= 0.\\n\nThe number of columns and rows of the matrix A.\n@param[inout]\nA         pointer to type. Array on the GPU of dimension lda*n.\\n\nOn entry, the n-by-n matrix A to be factored.\nOn exit, the factors L and U from the factorization.\nThe unit diagonal elements of L are not stored.\n@param[in]\nlda       int. lda >= n.\\n\nSpecifies the leading dimension of A.\n@param[out]\nipiv      pointer to int. Array on the GPU of dimension n.\\n\nThe vector of pivot indices. Elements of ipiv are 1-based indices.\nFor 1 <= i <= n, the row i of the\nmatrix was interchanged with row ipiv[i].\nMatrix P of the factorization can be derived from ipiv.\nThe factorization here can be done without pivoting if ipiv is passed\nin as a nullptr.\n@param[out]\ninfo      pointer to a int on the GPU.\\n\nIf info = 0, successful exit.\nIf info = j > 0, U is singular. U[j,j] is the first zero pivot."]
    pub fn hipblasSgetrf(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        A: *mut f32,
        lda: ::std::os::raw::c_int,
        ipiv: *mut ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDgetrf(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        A: *mut f64,
        lda: ::std::os::raw::c_int,
        ipiv: *mut ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgetrf(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        A: *mut hipblasComplex,
        lda: ::std::os::raw::c_int,
        ipiv: *mut ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgetrf(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        A: *mut hipblasDoubleComplex,
        lda: ::std::os::raw::c_int,
        ipiv: *mut ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgetrf_v2(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        A: *mut hipComplex,
        lda: ::std::os::raw::c_int,
        ipiv: *mut ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgetrf_v2(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        A: *mut hipDoubleComplex,
        lda: ::std::os::raw::c_int,
        ipiv: *mut ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief SOLVER API\n\n\\details\ngetrfBatched computes the LU factorization of a batch of general\nn-by-n matrices using partial pivoting with row interchanges. The LU factorization can\nbe done without pivoting if ipiv is passed as a nullptr.\n\nIn the case that ipiv is not null, the factorization of matrix \\f$A_i\\f$ in the batch has the form:\n\n\\f[\nA_i = P_iL_iU_i\n\\f]\n\nwhere \\f$P_i\\f$ is a permutation matrix, \\f$L_i\\f$ is lower triangular with unit\ndiagonal elements, and \\f$U_i\\f$ is upper triangular.\n\nIn the case that ipiv is null, the factorization is done without pivoting:\n\n\\f[\nA_i = L_iU_i\n\\f]\n\n- Supported precisions in rocSOLVER : s,d,c,z\n- Supported precisions in cuBLAS    : s,d,c,z\n\n@param[in]\nhandle    hipblasHandle_t.\n@param[in]\nn         int. n >= 0.\\n\nThe number of columns and rows of all matrices A_i in the batch.\n@param[inout]\nA         array of pointers to type. Each pointer points to an array on the GPU of dimension lda*n.\\n\nOn entry, the n-by-n matrices A_i to be factored.\nOn exit, the factors L_i and U_i from the factorizations.\nThe unit diagonal elements of L_i are not stored.\n@param[in]\nlda       int. lda >= n.\\n\nSpecifies the leading dimension of matrices A_i.\n@param[out]\nipiv      pointer to int. Array on the GPU.\\n\nContains the vectors of pivot indices ipiv_i (corresponding to A_i).\nDimension of ipiv_i is n.\nElements of ipiv_i are 1-based indices.\nFor each instance A_i in the batch and for 1 <= j <= n, the row j of the\nmatrix A_i was interchanged with row ipiv_i[j].\nMatrix P_i of the factorization can be derived from ipiv_i.\nThe factorization here can be done without pivoting if ipiv is passed\nin as a nullptr.\n@param[out]\ninfo      pointer to int. Array of batchCount integers on the GPU.\\n\nIf info[i] = 0, successful exit for factorization of A_i.\nIf info[i] = j > 0, U_i is singular. U_i[j,j] is the first zero pivot.\n@param[in]\nbatchCount int. batchCount >= 0.\\n\nNumber of matrices in the batch."]
    pub fn hipblasSgetrfBatched(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        A: *const *mut f32,
        lda: ::std::os::raw::c_int,
        ipiv: *mut ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDgetrfBatched(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        A: *const *mut f64,
        lda: ::std::os::raw::c_int,
        ipiv: *mut ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgetrfBatched(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        A: *const *mut hipblasComplex,
        lda: ::std::os::raw::c_int,
        ipiv: *mut ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgetrfBatched(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        A: *const *mut hipblasDoubleComplex,
        lda: ::std::os::raw::c_int,
        ipiv: *mut ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgetrfBatched_v2(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        A: *const *mut hipComplex,
        lda: ::std::os::raw::c_int,
        ipiv: *mut ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgetrfBatched_v2(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        A: *const *mut hipDoubleComplex,
        lda: ::std::os::raw::c_int,
        ipiv: *mut ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief SOLVER API\n\n\\details\ngetrfStridedBatched computes the LU factorization of a batch of\ngeneral n-by-n matrices using partial pivoting with row interchanges. The LU factorization can\nbe done without pivoting if ipiv is passed as a nullptr.\n\nIn the case that ipiv is not null, the factorization of matrix \\f$A_i\\f$ in the batch has the form:\n\n\\f[\nA_i = P_iL_iU_i\n\\f]\n\nwhere \\f$P_i\\f$ is a permutation matrix, \\f$L_i\\f$ is lower triangular with unit\ndiagonal elements, and \\f$U_i\\f$ is upper triangular.\n\nIn the case that ipiv is null, the factorization is done without pivoting:\n\n\\f[\nA_i = L_iU_i\n\\f]\n\n- Supported precisions in rocSOLVER : s,d,c,z\n- Supported precisions in cuBLAS    : s,d,c,z\n\n@param[in]\nhandle    hipblasHandle_t.\n@param[in]\nn         int. n >= 0.\\n\nThe number of columns and rows of all matrices A_i in the batch.\n@param[inout]\nA         pointer to type. Array on the GPU (the size depends on the value of strideA).\\n\nOn entry, the n-by-n matrices A_i to be factored.\nOn exit, the factors L_i and U_i from the factorization.\nThe unit diagonal elements of L_i are not stored.\n@param[in]\nlda       int. lda >= n.\\n\nSpecifies the leading dimension of matrices A_i.\n@param[in]\nstrideA   hipblasStride.\\n\nStride from the start of one matrix A_i to the next one A_(i+1).\nThere is no restriction for the value of strideA. Normal use case is strideA >= lda*n\n@param[out]\nipiv      pointer to int. Array on the GPU (the size depends on the value of strideP).\\n\nContains the vectors of pivots indices ipiv_i (corresponding to A_i).\nDimension of ipiv_i is n.\nElements of ipiv_i are 1-based indices.\nFor each instance A_i in the batch and for 1 <= j <= n, the row j of the\nmatrix A_i was interchanged with row ipiv_i[j].\nMatrix P_i of the factorization can be derived from ipiv_i.\nThe factorization here can be done without pivoting if ipiv is passed\nin as a nullptr.\n@param[in]\nstrideP   hipblasStride.\\n\nStride from the start of one vector ipiv_i to the next one ipiv_(i+1).\nThere is no restriction for the value of strideP. Normal use case is strideP >= n.\n@param[out]\ninfo      pointer to int. Array of batchCount integers on the GPU.\\n\nIf info[i] = 0, successful exit for factorization of A_i.\nIf info[i] = j > 0, U_i is singular. U_i[j,j] is the first zero pivot.\n@param[in]\nbatchCount int. batchCount >= 0.\\n\nNumber of matrices in the batch."]
    pub fn hipblasSgetrfStridedBatched(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        A: *mut f32,
        lda: ::std::os::raw::c_int,
        strideA: hipblasStride,
        ipiv: *mut ::std::os::raw::c_int,
        strideP: hipblasStride,
        info: *mut ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDgetrfStridedBatched(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        A: *mut f64,
        lda: ::std::os::raw::c_int,
        strideA: hipblasStride,
        ipiv: *mut ::std::os::raw::c_int,
        strideP: hipblasStride,
        info: *mut ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgetrfStridedBatched(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        A: *mut hipblasComplex,
        lda: ::std::os::raw::c_int,
        strideA: hipblasStride,
        ipiv: *mut ::std::os::raw::c_int,
        strideP: hipblasStride,
        info: *mut ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgetrfStridedBatched(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        A: *mut hipblasDoubleComplex,
        lda: ::std::os::raw::c_int,
        strideA: hipblasStride,
        ipiv: *mut ::std::os::raw::c_int,
        strideP: hipblasStride,
        info: *mut ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgetrfStridedBatched_v2(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        A: *mut hipComplex,
        lda: ::std::os::raw::c_int,
        strideA: hipblasStride,
        ipiv: *mut ::std::os::raw::c_int,
        strideP: hipblasStride,
        info: *mut ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgetrfStridedBatched_v2(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        A: *mut hipDoubleComplex,
        lda: ::std::os::raw::c_int,
        strideA: hipblasStride,
        ipiv: *mut ::std::os::raw::c_int,
        strideP: hipblasStride,
        info: *mut ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief SOLVER API\n\n\\details\ngetrs solves a system of n linear equations on n variables in its factorized form.\n\nIt solves one of the following systems, depending on the value of trans:\n\n\\f[\n\\begin{array}{cl}\nA X = B & \\: \\text{not transposed,}\\\\\nA^T X = B & \\: \\text{transposed, or}\\\\\nA^H X = B & \\: \\text{conjugate transposed.}\n\\end{array}\n\\f]\n\nMatrix A is defined by its triangular factors as returned by \\ref hipblasSgetrf \"getrf\".\n\n- Supported precisions in rocSOLVER : s,d,c,z\n- Supported precisions in cuBLAS    : s,d,c,z\n\n\n@param[in]\nhandle      hipblasHandle_t.\n@param[in]\ntrans       hipblasOperation_t.\\n\nSpecifies the form of the system of equations.\n@param[in]\nn           int. n >= 0.\\n\nThe order of the system, i.e. the number of columns and rows of A.\n@param[in]\nnrhs        int. nrhs >= 0.\\n\nThe number of right hand sides, i.e., the number of columns\nof the matrix B.\n@param[in]\nA           pointer to type. Array on the GPU of dimension lda*n.\\n\nThe factors L and U of the factorization A = P*L*U returned by \\ref hipblasSgetrf \"getrf\".\n@param[in]\nlda         int. lda >= n.\\n\nThe leading dimension of A.\n@param[in]\nipiv        pointer to int. Array on the GPU of dimension n.\\n\nThe pivot indices returned by \\ref hipblasSgetrf \"getrf\".\n@param[in,out]\nB           pointer to type. Array on the GPU of dimension ldb*nrhs.\\n\nOn entry, the right hand side matrix B.\nOn exit, the solution matrix X.\n@param[in]\nldb         int. ldb >= n.\\n\nThe leading dimension of B.\n@param[out]\ninfo      pointer to a int on the host.\\n\nIf info = 0, successful exit.\nIf info = j < 0, the argument at position -j is invalid."]
    pub fn hipblasSgetrs(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        n: ::std::os::raw::c_int,
        nrhs: ::std::os::raw::c_int,
        A: *mut f32,
        lda: ::std::os::raw::c_int,
        ipiv: *const ::std::os::raw::c_int,
        B: *mut f32,
        ldb: ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDgetrs(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        n: ::std::os::raw::c_int,
        nrhs: ::std::os::raw::c_int,
        A: *mut f64,
        lda: ::std::os::raw::c_int,
        ipiv: *const ::std::os::raw::c_int,
        B: *mut f64,
        ldb: ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgetrs(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        n: ::std::os::raw::c_int,
        nrhs: ::std::os::raw::c_int,
        A: *mut hipblasComplex,
        lda: ::std::os::raw::c_int,
        ipiv: *const ::std::os::raw::c_int,
        B: *mut hipblasComplex,
        ldb: ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgetrs(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        n: ::std::os::raw::c_int,
        nrhs: ::std::os::raw::c_int,
        A: *mut hipblasDoubleComplex,
        lda: ::std::os::raw::c_int,
        ipiv: *const ::std::os::raw::c_int,
        B: *mut hipblasDoubleComplex,
        ldb: ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgetrs_v2(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        n: ::std::os::raw::c_int,
        nrhs: ::std::os::raw::c_int,
        A: *mut hipComplex,
        lda: ::std::os::raw::c_int,
        ipiv: *const ::std::os::raw::c_int,
        B: *mut hipComplex,
        ldb: ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgetrs_v2(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        n: ::std::os::raw::c_int,
        nrhs: ::std::os::raw::c_int,
        A: *mut hipDoubleComplex,
        lda: ::std::os::raw::c_int,
        ipiv: *const ::std::os::raw::c_int,
        B: *mut hipDoubleComplex,
        ldb: ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief SOLVER API\n\n\\details getrsBatched solves a batch of systems of n linear equations on n\nvariables in its factorized forms.\n\nFor each instance i in the batch, it solves one of the following systems, depending on the value of trans:\n\n\\f[\n\\begin{array}{cl}\nA_i X_i = B_i & \\: \\text{not transposed,}\\\\\nA_i^T X_i = B_i & \\: \\text{transposed, or}\\\\\nA_i^H X_i = B_i & \\: \\text{conjugate transposed.}\n\\end{array}\n\\f]\n\nMatrix \\f$A_i\\f$ is defined by its triangular factors as returned by \\ref hipblasSgetrfBatched \"getrfBatched\".\n\n- Supported precisions in rocSOLVER : s,d,c,z\n- Supported precisions in cuBLAS    : s,d,c,z\n\n@param[in]\nhandle      hipblasHandle_t.\n@param[in]\ntrans       hipblasOperation_t.\\n\nSpecifies the form of the system of equations of each instance in the batch.\n@param[in]\nn           int. n >= 0.\\n\nThe order of the system, i.e. the number of columns and rows of all A_i matrices.\n@param[in]\nnrhs        int. nrhs >= 0.\\n\nThe number of right hand sides, i.e., the number of columns\nof all the matrices B_i.\n@param[in]\nA           Array of pointers to type. Each pointer points to an array on the GPU of dimension lda*n.\\n\nThe factors L_i and U_i of the factorization A_i = P_i*L_i*U_i returned by \\ref hipblasSgetrfBatched \"getrfBatched\".\n@param[in]\nlda         int. lda >= n.\\n\nThe leading dimension of matrices A_i.\n@param[in]\nipiv        pointer to int. Array on the GPU.\\n\nContains the vectors ipiv_i of pivot indices returned by \\ref hipblasSgetrfBatched \"getrfBatched\".\n@param[in,out]\nB           Array of pointers to type. Each pointer points to an array on the GPU of dimension ldb*nrhs.\\n\nOn entry, the right hand side matrices B_i.\nOn exit, the solution matrix X_i of each system in the batch.\n@param[in]\nldb         int. ldb >= n.\\n\nThe leading dimension of matrices B_i.\n@param[out]\ninfo      pointer to a int on the host.\\n\nIf info = 0, successful exit.\nIf info = j < 0, the argument at position -j is invalid.\n@param[in]\nbatchCount int. batchCount >= 0.\\n\nNumber of instances (systems) in the batch.\n"]
    pub fn hipblasSgetrsBatched(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        n: ::std::os::raw::c_int,
        nrhs: ::std::os::raw::c_int,
        A: *const *mut f32,
        lda: ::std::os::raw::c_int,
        ipiv: *const ::std::os::raw::c_int,
        B: *const *mut f32,
        ldb: ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDgetrsBatched(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        n: ::std::os::raw::c_int,
        nrhs: ::std::os::raw::c_int,
        A: *const *mut f64,
        lda: ::std::os::raw::c_int,
        ipiv: *const ::std::os::raw::c_int,
        B: *const *mut f64,
        ldb: ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgetrsBatched(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        n: ::std::os::raw::c_int,
        nrhs: ::std::os::raw::c_int,
        A: *const *mut hipblasComplex,
        lda: ::std::os::raw::c_int,
        ipiv: *const ::std::os::raw::c_int,
        B: *const *mut hipblasComplex,
        ldb: ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgetrsBatched(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        n: ::std::os::raw::c_int,
        nrhs: ::std::os::raw::c_int,
        A: *const *mut hipblasDoubleComplex,
        lda: ::std::os::raw::c_int,
        ipiv: *const ::std::os::raw::c_int,
        B: *const *mut hipblasDoubleComplex,
        ldb: ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgetrsBatched_v2(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        n: ::std::os::raw::c_int,
        nrhs: ::std::os::raw::c_int,
        A: *const *mut hipComplex,
        lda: ::std::os::raw::c_int,
        ipiv: *const ::std::os::raw::c_int,
        B: *const *mut hipComplex,
        ldb: ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgetrsBatched_v2(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        n: ::std::os::raw::c_int,
        nrhs: ::std::os::raw::c_int,
        A: *const *mut hipDoubleComplex,
        lda: ::std::os::raw::c_int,
        ipiv: *const ::std::os::raw::c_int,
        B: *const *mut hipDoubleComplex,
        ldb: ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief SOLVER API\n\n\\details\ngetrsStridedBatched solves a batch of systems of n linear equations\non n variables in its factorized forms.\n\nFor each instance i in the batch, it solves one of the following systems, depending on the value of trans:\n\n\\f[\n\\begin{array}{cl}\nA_i X_i = B_i & \\: \\text{not transposed,}\\\\\nA_i^T X_i = B_i & \\: \\text{transposed, or}\\\\\nA_i^H X_i = B_i & \\: \\text{conjugate transposed.}\n\\end{array}\n\\f]\n\nMatrix \\f$A_i\\f$ is defined by its triangular factors as returned by \\ref hipblasSgetrfStridedBatched \"getrfStridedBatched\".\n\n- Supported precisions in rocSOLVER : s,d,c,z\n- Supported precisions in cuBLAS    : No support\n\n@param[in]\nhandle      hipblasHandle_t.\n@param[in]\ntrans       hipblasOperation_t.\\n\nSpecifies the form of the system of equations of each instance in the batch.\n@param[in]\nn           int. n >= 0.\\n\nThe order of the system, i.e. the number of columns and rows of all A_i matrices.\n@param[in]\nnrhs        int. nrhs >= 0.\\n\nThe number of right hand sides, i.e., the number of columns\nof all the matrices B_i.\n@param[in]\nA           pointer to type. Array on the GPU (the size depends on the value of strideA).\\n\nThe factors L_i and U_i of the factorization A_i = P_i*L_i*U_i returned by \\ref hipblasSgetrfStridedBatched \"getrfStridedBatched\".\n@param[in]\nlda         int. lda >= n.\\n\nThe leading dimension of matrices A_i.\n@param[in]\nstrideA     hipblasStride.\\n\nStride from the start of one matrix A_i to the next one A_(i+1).\nThere is no restriction for the value of strideA. Normal use case is strideA >= lda*n.\n@param[in]\nipiv        pointer to int. Array on the GPU (the size depends on the value of strideP).\\n\nContains the vectors ipiv_i of pivot indices returned by \\ref hipblasSgetrfStridedBatched \"getrfStridedBatched\".\n@param[in]\nstrideP     hipblasStride.\\n\nStride from the start of one vector ipiv_i to the next one ipiv_(i+1).\nThere is no restriction for the value of strideP. Normal use case is strideP >= n.\n@param[in,out]\nB           pointer to type. Array on the GPU (size depends on the value of strideB).\\n\nOn entry, the right hand side matrices B_i.\nOn exit, the solution matrix X_i of each system in the batch.\n@param[in]\nldb         int. ldb >= n.\\n\nThe leading dimension of matrices B_i.\n@param[in]\nstrideB     hipblasStride.\\n\nStride from the start of one matrix B_i to the next one B_(i+1).\nThere is no restriction for the value of strideB. Normal use case is strideB >= ldb*nrhs.\n@param[out]\ninfo      pointer to a int on the host.\\n\nIf info = 0, successful exit.\nIf info = j < 0, the argument at position -j is invalid.\n@param[in]\nbatchCount int. batchCount >= 0.\\n\nNumber of instances (systems) in the batch.\n"]
    pub fn hipblasSgetrsStridedBatched(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        n: ::std::os::raw::c_int,
        nrhs: ::std::os::raw::c_int,
        A: *mut f32,
        lda: ::std::os::raw::c_int,
        strideA: hipblasStride,
        ipiv: *const ::std::os::raw::c_int,
        strideP: hipblasStride,
        B: *mut f32,
        ldb: ::std::os::raw::c_int,
        strideB: hipblasStride,
        info: *mut ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDgetrsStridedBatched(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        n: ::std::os::raw::c_int,
        nrhs: ::std::os::raw::c_int,
        A: *mut f64,
        lda: ::std::os::raw::c_int,
        strideA: hipblasStride,
        ipiv: *const ::std::os::raw::c_int,
        strideP: hipblasStride,
        B: *mut f64,
        ldb: ::std::os::raw::c_int,
        strideB: hipblasStride,
        info: *mut ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgetrsStridedBatched(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        n: ::std::os::raw::c_int,
        nrhs: ::std::os::raw::c_int,
        A: *mut hipblasComplex,
        lda: ::std::os::raw::c_int,
        strideA: hipblasStride,
        ipiv: *const ::std::os::raw::c_int,
        strideP: hipblasStride,
        B: *mut hipblasComplex,
        ldb: ::std::os::raw::c_int,
        strideB: hipblasStride,
        info: *mut ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgetrsStridedBatched(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        n: ::std::os::raw::c_int,
        nrhs: ::std::os::raw::c_int,
        A: *mut hipblasDoubleComplex,
        lda: ::std::os::raw::c_int,
        strideA: hipblasStride,
        ipiv: *const ::std::os::raw::c_int,
        strideP: hipblasStride,
        B: *mut hipblasDoubleComplex,
        ldb: ::std::os::raw::c_int,
        strideB: hipblasStride,
        info: *mut ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgetrsStridedBatched_v2(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        n: ::std::os::raw::c_int,
        nrhs: ::std::os::raw::c_int,
        A: *mut hipComplex,
        lda: ::std::os::raw::c_int,
        strideA: hipblasStride,
        ipiv: *const ::std::os::raw::c_int,
        strideP: hipblasStride,
        B: *mut hipComplex,
        ldb: ::std::os::raw::c_int,
        strideB: hipblasStride,
        info: *mut ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgetrsStridedBatched_v2(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        n: ::std::os::raw::c_int,
        nrhs: ::std::os::raw::c_int,
        A: *mut hipDoubleComplex,
        lda: ::std::os::raw::c_int,
        strideA: hipblasStride,
        ipiv: *const ::std::os::raw::c_int,
        strideP: hipblasStride,
        B: *mut hipDoubleComplex,
        ldb: ::std::os::raw::c_int,
        strideB: hipblasStride,
        info: *mut ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief SOLVER API\n\n\\details\ngetriBatched computes the inverse \\f$C_i = A_i^{-1}\\f$ of a batch of general n-by-n matrices \\f$A_i\\f$.\n\nThe inverse is computed by solving the linear system\n\n\\f[\nA_i C_i = I\n\\f]\n\nwhere I is the identity matrix, and \\f$A_i\\f$ is factorized as \\f$A_i = P_i  L_i  U_i\\f$ as given by \\ref hipblasSgetrfBatched \"getrfBatched\".\n\n- Supported precisions in rocSOLVER : s,d,c,z\n- Supported precisions in cuBLAS    : s,d,c,z\n\n@param[in]\nhandle    hipblasHandle_t.\n@param[in]\nn         int. n >= 0.\\n\nThe number of rows and columns of all matrices A_i in the batch.\n@param[in]\nA         array of pointers to type. Each pointer points to an array on the GPU of dimension lda*n.\\n\nThe factors L_i and U_i of the factorization A_i = P_i*L_i*U_i returned by \\ref hipblasSgetrfBatched \"getrfBatched\".\n@param[in]\nlda       int. lda >= n.\\n\nSpecifies the leading dimension of matrices A_i.\n@param[in]\nipiv      pointer to int. Array on the GPU (the size depends on the value of strideP).\\n\nThe pivot indices returned by \\ref hipblasSgetrfBatched \"getrfBatched\".\nipiv can be passed in as a nullptr, this will assume that getrfBatched was called without partial pivoting.\n@param[out]\nC         array of pointers to type. Each pointer points to an array on the GPU of dimension ldc*n.\\n\nIf info[i] = 0, the inverse of matrices A_i. Otherwise, undefined.\n@param[in]\nldc       int. ldc >= n.\\n\nSpecifies the leading dimension of C_i.\n@param[out]\ninfo      pointer to int. Array of batchCount integers on the GPU.\\n\nIf info[i] = 0, successful exit for inversion of A_i.\nIf info[i] = j > 0, U_i is singular. U_i[j,j] is the first zero pivot.\n@param[in]\nbatchCount int. batchCount >= 0.\\n\nNumber of matrices in the batch.\n"]
    pub fn hipblasSgetriBatched(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        A: *const *mut f32,
        lda: ::std::os::raw::c_int,
        ipiv: *mut ::std::os::raw::c_int,
        C: *const *mut f32,
        ldc: ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDgetriBatched(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        A: *const *mut f64,
        lda: ::std::os::raw::c_int,
        ipiv: *mut ::std::os::raw::c_int,
        C: *const *mut f64,
        ldc: ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgetriBatched(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        A: *const *mut hipblasComplex,
        lda: ::std::os::raw::c_int,
        ipiv: *mut ::std::os::raw::c_int,
        C: *const *mut hipblasComplex,
        ldc: ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgetriBatched(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        A: *const *mut hipblasDoubleComplex,
        lda: ::std::os::raw::c_int,
        ipiv: *mut ::std::os::raw::c_int,
        C: *const *mut hipblasDoubleComplex,
        ldc: ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgetriBatched_v2(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        A: *const *mut hipComplex,
        lda: ::std::os::raw::c_int,
        ipiv: *mut ::std::os::raw::c_int,
        C: *const *mut hipComplex,
        ldc: ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgetriBatched_v2(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        A: *const *mut hipDoubleComplex,
        lda: ::std::os::raw::c_int,
        ipiv: *mut ::std::os::raw::c_int,
        C: *const *mut hipDoubleComplex,
        ldc: ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief GELS solves an overdetermined (or underdetermined) linear system defined by an m-by-n\nmatrix A, and a corresponding matrix B, using the QR factorization computed by \\ref hipblasSgeqrf \"GEQRF\" (or the LQ\nfactorization computed by \"GELQF\").\n\n\\details\nDepending on the value of trans, the problem solved by this function is either of the form\n\n\\f[\n\\begin{array}{cl}\nA X = B & \\: \\text{not transposed, or}\\\\\nA' X = B & \\: \\text{transposed if real, or conjugate transposed if complex}\n\\end{array}\n\\f]\n\nIf m >= n (or m < n in the case of transpose/conjugate transpose), the system is overdetermined\nand a least-squares solution approximating X is found by minimizing\n\n\\f[\n|| B - A  X || \\quad \\text{(or} \\: || B - A' X ||\\text{)}\n\\f]\n\nIf m < n (or m >= n in the case of transpose/conjugate transpose), the system is underdetermined\nand a unique solution for X is chosen such that \\f$|| X ||\\f$ is minimal.\n\n- Supported precisions in rocSOLVER : s,d,c,z\n- Supported precisions in cuBLAS    : currently unsupported\n\n@param[in]\nhandle      hipblasHandle_t.\n@param[in]\ntrans       hipblasOperation_t.\\n\nSpecifies the form of the system of equations.\n@param[in]\nm           int. m >= 0.\\n\nThe number of rows of matrix A.\n@param[in]\nn           int. n >= 0.\\n\nThe number of columns of matrix A.\n@param[in]\nnrhs        int. nrhs >= 0.\\n\nThe number of columns of matrices B and X;\ni.e., the columns on the right hand side.\n@param[inout]\nA           pointer to type. Array on the GPU of dimension lda*n.\\n\nOn entry, the matrix A.\nOn exit, the QR (or LQ) factorization of A as returned by \"GEQRF\" (or \"GELQF\").\n@param[in]\nlda         int. lda >= m.\\n\nSpecifies the leading dimension of matrix A.\n@param[inout]\nB           pointer to type. Array on the GPU of dimension ldb*nrhs.\\n\nOn entry, the matrix B.\nOn exit, when info = 0, B is overwritten by the solution vectors (and the residuals in\nthe overdetermined cases) stored as columns.\n@param[in]\nldb         int. ldb >= max(m,n).\\n\nSpecifies the leading dimension of matrix B.\n@param[out]\ninfo        pointer to an int on the host.\\n\nIf info = 0, successful exit.\nIf info = j < 0, the argument at position -j is invalid.\n@param[out]\ndeviceInfo  pointer to int on the GPU.\\n\nIf info = 0, successful exit.\nIf info = i > 0, the solution could not be computed because input matrix A is\nrank deficient; the i-th diagonal element of its triangular factor is zero."]
    pub fn hipblasSgels(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        nrhs: ::std::os::raw::c_int,
        A: *mut f32,
        lda: ::std::os::raw::c_int,
        B: *mut f32,
        ldb: ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
        deviceInfo: *mut ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDgels(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        nrhs: ::std::os::raw::c_int,
        A: *mut f64,
        lda: ::std::os::raw::c_int,
        B: *mut f64,
        ldb: ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
        deviceInfo: *mut ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgels(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        nrhs: ::std::os::raw::c_int,
        A: *mut hipblasComplex,
        lda: ::std::os::raw::c_int,
        B: *mut hipblasComplex,
        ldb: ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
        deviceInfo: *mut ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgels(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        nrhs: ::std::os::raw::c_int,
        A: *mut hipblasDoubleComplex,
        lda: ::std::os::raw::c_int,
        B: *mut hipblasDoubleComplex,
        ldb: ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
        deviceInfo: *mut ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgels_v2(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        nrhs: ::std::os::raw::c_int,
        A: *mut hipComplex,
        lda: ::std::os::raw::c_int,
        B: *mut hipComplex,
        ldb: ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
        deviceInfo: *mut ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgels_v2(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        nrhs: ::std::os::raw::c_int,
        A: *mut hipDoubleComplex,
        lda: ::std::os::raw::c_int,
        B: *mut hipDoubleComplex,
        ldb: ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
        deviceInfo: *mut ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief gelsBatched solves a batch of overdetermined (or underdetermined) linear systems\ndefined by a set of m-by-n matrices \\f$A_j\\f$, and corresponding matrices \\f$B_j\\f$, using the\nQR factorizations computed by \"GEQRF_BATCHED\" (or the LQ factorizations computed by \"GELQF_BATCHED\").\n\n\\details\nFor each instance in the batch, depending on the value of trans, the problem solved by this function is either of the form\n\n\\f[\n\\begin{array}{cl}\nA_j X_j = B_j & \\: \\text{not transposed, or}\\\\\nA_j' X_j = B_j & \\: \\text{transposed if real, or conjugate transposed if complex}\n\\end{array}\n\\f]\n\nIf m >= n (or m < n in the case of transpose/conjugate transpose), the system is overdetermined\nand a least-squares solution approximating X_j is found by minimizing\n\n\\f[\n|| B_j - A_j  X_j || \\quad \\text{(or} \\: || B_j - A_j' X_j ||\\text{)}\n\\f]\n\nIf m < n (or m >= n in the case of transpose/conjugate transpose), the system is underdetermined\nand a unique solution for X_j is chosen such that \\f$|| X_j ||\\f$ is minimal.\n\n- Supported precisions in rocSOLVER : s,d,c,z\n- Supported precisions in cuBLAS    : s,d,c,z\nNote that cuBLAS backend supports only the non-transpose operation and only solves over-determined systems (m >= n).\n\n@param[in]\nhandle      hipblasHandle_t.\n@param[in]\ntrans       hipblasOperation_t.\\n\nSpecifies the form of the system of equations.\n@param[in]\nm           int. m >= 0.\\n\nThe number of rows of all matrices A_j in the batch.\n@param[in]\nn           int. n >= 0.\\n\nThe number of columns of all matrices A_j in the batch.\n@param[in]\nnrhs        int. nrhs >= 0.\\n\nThe number of columns of all matrices B_j and X_j in the batch;\ni.e., the columns on the right hand side.\n@param[inout]\nA           array of pointer to type. Each pointer points to an array on the GPU of dimension lda*n.\\n\nOn entry, the matrices A_j.\nOn exit, the QR (or LQ) factorizations of A_j as returned by \"GEQRF_BATCHED\"\n(or \"GELQF_BATCHED\").\n@param[in]\nlda         int. lda >= m.\\n\nSpecifies the leading dimension of matrices A_j.\n@param[inout]\nB           array of pointer to type. Each pointer points to an array on the GPU of dimension ldb*nrhs.\\n\nOn entry, the matrices B_j.\nOn exit, when info[j] = 0, B_j is overwritten by the solution vectors (and the residuals in\nthe overdetermined cases) stored as columns.\n@param[in]\nldb         int. ldb >= max(m,n).\\n\nSpecifies the leading dimension of matrices B_j.\n@param[out]\ninfo        pointer to an int on the host.\\n\nIf info = 0, successful exit.\nIf info = j < 0, the argument at position -j is invalid.\n@param[out]\ndeviceInfo  pointer to int. Array of batchCount integers on the GPU.\\n\nIf deviceInfo[j] = 0, successful exit for solution of A_j.\nIf deviceInfo[j] = i > 0, the solution of A_j could not be computed because input\nmatrix A_j is rank deficient; the i-th diagonal element of its triangular factor is zero.\n@param[in]\nbatchCount  int. batchCount >= 0.\\n\nNumber of matrices in the batch."]
    pub fn hipblasSgelsBatched(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        nrhs: ::std::os::raw::c_int,
        A: *const *mut f32,
        lda: ::std::os::raw::c_int,
        B: *const *mut f32,
        ldb: ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
        deviceInfo: *mut ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDgelsBatched(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        nrhs: ::std::os::raw::c_int,
        A: *const *mut f64,
        lda: ::std::os::raw::c_int,
        B: *const *mut f64,
        ldb: ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
        deviceInfo: *mut ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgelsBatched(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        nrhs: ::std::os::raw::c_int,
        A: *const *mut hipblasComplex,
        lda: ::std::os::raw::c_int,
        B: *const *mut hipblasComplex,
        ldb: ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
        deviceInfo: *mut ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgelsBatched(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        nrhs: ::std::os::raw::c_int,
        A: *const *mut hipblasDoubleComplex,
        lda: ::std::os::raw::c_int,
        B: *const *mut hipblasDoubleComplex,
        ldb: ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
        deviceInfo: *mut ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgelsBatched_v2(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        nrhs: ::std::os::raw::c_int,
        A: *const *mut hipComplex,
        lda: ::std::os::raw::c_int,
        B: *const *mut hipComplex,
        ldb: ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
        deviceInfo: *mut ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgelsBatched_v2(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        nrhs: ::std::os::raw::c_int,
        A: *const *mut hipDoubleComplex,
        lda: ::std::os::raw::c_int,
        B: *const *mut hipDoubleComplex,
        ldb: ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
        deviceInfo: *mut ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief gelsStridedBatched solves a batch of overdetermined (or underdetermined) linear\nsystems defined by a set of m-by-n matrices \\f$A_j\\f$, and corresponding matrices \\f$B_j\\f$,\nusing the QR factorizations computed by \"GEQRF_STRIDED_BATCHED\"\n(or the LQ factorizations computed by \"GELQF_STRIDED_BATCHED\").\n\n\\details\nFor each instance in the batch, depending on the value of trans, the problem solved by this function is either of the form\n\n\\f[\n\\begin{array}{cl}\nA_j X_j = B_j & \\: \\text{not transposed, or}\\\\\nA_j' X_j = B_j & \\: \\text{transposed if real, or conjugate transposed if complex}\n\\end{array}\n\\f]\n\nIf m >= n (or m < n in the case of transpose/conjugate transpose), the system is overdetermined\nand a least-squares solution approximating X_j is found by minimizing\n\n\\f[\n|| B_j - A_j  X_j || \\quad \\text{(or} \\: || B_j - A_j' X_j ||\\text{)}\n\\f]\n\nIf m < n (or m >= n in the case of transpose/conjugate transpose), the system is underdetermined\nand a unique solution for X_j is chosen such that \\f$|| X_j ||\\f$ is minimal.\n\n- Supported precisions in rocSOLVER : s,d,c,z\n- Supported precisions in cuBLAS    : currently unsupported\n\n@param[in]\nhandle      hipblasHandle_t.\n@param[in]\ntrans       hipblasOperation_t.\\n\nSpecifies the form of the system of equations.\n@param[in]\nm           int. m >= 0.\\n\nThe number of rows of all matrices A_j in the batch.\n@param[in]\nn           int. n >= 0.\\n\nThe number of columns of all matrices A_j in the batch.\n@param[in]\nnrhs        int. nrhs >= 0.\\n\nThe number of columns of all matrices B_j and X_j in the batch;\ni.e., the columns on the right hand side.\n@param[inout]\nA           pointer to type. Array on the GPU (the size depends on the value of strideA).\\n\nOn entry, the matrices A_j.\nOn exit, the QR (or LQ) factorizations of A_j as returned by \"GEQRF_STRIDED_BATCHED\"\n(or \"GELQF_STRIDED_BATCHED\").\n@param[in]\nlda         int. lda >= m.\\n\nSpecifies the leading dimension of matrices A_j.\n@param[in]\nstrideA     hipblasStride.\\n\nStride from the start of one matrix A_j to the next one A_(j+1).\nThere is no restriction for the value of strideA. Normal use case is strideA >= lda*n\n@param[inout]\nB           pointer to type. Array on the GPU (the size depends on the value of strideB).\\n\nOn entry, the matrices B_j.\nOn exit, when info[j] = 0, each B_j is overwritten by the solution vectors (and the residuals in\nthe overdetermined cases) stored as columns.\n@param[in]\nldb         int. ldb >= max(m,n).\\n\nSpecifies the leading dimension of matrices B_j.\n@param[in]\nstrideB     hipblasStride.\\n\nStride from the start of one matrix B_j to the next one B_(j+1).\nThere is no restriction for the value of strideB. Normal use case is strideB >= ldb*nrhs\n@param[out]\ninfo        pointer to an int on the host.\\n\nIf info = 0, successful exit.\nIf info = j < 0, the argument at position -j is invalid.\n@param[out]\ndeviceInfo  pointer to int. Array of batchCount integers on the GPU.\\n\nIf deviceInfo[j] = 0, successful exit for solution of A_j.\nIf deviceInfo[j] = i > 0, the solution of A_j could not be computed because input\nmatrix A_j is rank deficient; the i-th diagonal element of its triangular factor is zero.\n@param[in]\nbatchCount  int. batchCount >= 0.\\n\nNumber of matrices in the batch."]
    pub fn hipblasSgelsStridedBatched(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        nrhs: ::std::os::raw::c_int,
        A: *mut f32,
        lda: ::std::os::raw::c_int,
        strideA: hipblasStride,
        B: *mut f32,
        ldb: ::std::os::raw::c_int,
        strideB: hipblasStride,
        info: *mut ::std::os::raw::c_int,
        deviceInfo: *mut ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDgelsStridedBatched(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        nrhs: ::std::os::raw::c_int,
        A: *mut f64,
        lda: ::std::os::raw::c_int,
        strideA: hipblasStride,
        B: *mut f64,
        ldb: ::std::os::raw::c_int,
        strideB: hipblasStride,
        info: *mut ::std::os::raw::c_int,
        deviceInfo: *mut ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgelsStridedBatched(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        nrhs: ::std::os::raw::c_int,
        A: *mut hipblasComplex,
        lda: ::std::os::raw::c_int,
        strideA: hipblasStride,
        B: *mut hipblasComplex,
        ldb: ::std::os::raw::c_int,
        strideB: hipblasStride,
        info: *mut ::std::os::raw::c_int,
        deviceInfo: *mut ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgelsStridedBatched(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        nrhs: ::std::os::raw::c_int,
        A: *mut hipblasDoubleComplex,
        lda: ::std::os::raw::c_int,
        strideA: hipblasStride,
        B: *mut hipblasDoubleComplex,
        ldb: ::std::os::raw::c_int,
        strideB: hipblasStride,
        info: *mut ::std::os::raw::c_int,
        deviceInfo: *mut ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgelsStridedBatched_v2(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        nrhs: ::std::os::raw::c_int,
        A: *mut hipComplex,
        lda: ::std::os::raw::c_int,
        strideA: hipblasStride,
        B: *mut hipComplex,
        ldb: ::std::os::raw::c_int,
        strideB: hipblasStride,
        info: *mut ::std::os::raw::c_int,
        deviceInfo: *mut ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgelsStridedBatched_v2(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        nrhs: ::std::os::raw::c_int,
        A: *mut hipDoubleComplex,
        lda: ::std::os::raw::c_int,
        strideA: hipblasStride,
        B: *mut hipDoubleComplex,
        ldb: ::std::os::raw::c_int,
        strideB: hipblasStride,
        info: *mut ::std::os::raw::c_int,
        deviceInfo: *mut ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief SOLVER API\n\n\\details\ngeqrf computes a QR factorization of a general m-by-n matrix A.\n\nThe factorization has the form\n\n\\f[\nA = Q\\left[\\begin{array}{c}\nR\\\\\n0\n\\end{array}\\right]\n\\f]\n\nwhere R is upper triangular (upper trapezoidal if m < n), and Q is\na m-by-m orthogonal/unitary matrix represented as the product of Householder matrices\n\n\\f[\nQ = H_1H_2\\cdots H_k, \\quad \\text{with} \\: k = \\text{min}(m,n)\n\\f]\n\nEach Householder matrix \\f$H_i\\f$ is given by\n\n\\f[\nH_i = I - \\text{ipiv}[i] \\cdot v_i v_i'\n\\f]\n\nwhere the first i-1 elements of the Householder vector \\f$v_i\\f$ are zero, and \\f$v_i[i] = 1\\f$.\n\n- Supported precisions in rocSOLVER : s,d,c,z\n- Supported precisions in cuBLAS    : s,d,c,z\n\n@param[in]\nhandle    hipblasHandle_t.\n@param[in]\nm         int. m >= 0.\\n\nThe number of rows of the matrix A.\n@param[in]\nn         int. n >= 0.\\n\nThe number of columns of the matrix A.\n@param[inout]\nA         pointer to type. Array on the GPU of dimension lda*n.\\n\nOn entry, the m-by-n matrix to be factored.\nOn exit, the elements on and above the diagonal contain the\nfactor R; the elements below the diagonal are the last m - i elements\nof Householder vector v_i.\n@param[in]\nlda       int. lda >= m.\\n\nSpecifies the leading dimension of A.\n@param[out]\nipiv      pointer to type. Array on the GPU of dimension min(m,n).\\n\nThe Householder scalars.\n@param[out]\ninfo      pointer to a int on the host.\\n\nIf info = 0, successful exit.\nIf info = j < 0, the argument at position -j is invalid.\n"]
    pub fn hipblasSgeqrf(
        handle: hipblasHandle_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        A: *mut f32,
        lda: ::std::os::raw::c_int,
        ipiv: *mut f32,
        info: *mut ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDgeqrf(
        handle: hipblasHandle_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        A: *mut f64,
        lda: ::std::os::raw::c_int,
        ipiv: *mut f64,
        info: *mut ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgeqrf(
        handle: hipblasHandle_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        A: *mut hipblasComplex,
        lda: ::std::os::raw::c_int,
        ipiv: *mut hipblasComplex,
        info: *mut ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgeqrf(
        handle: hipblasHandle_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        A: *mut hipblasDoubleComplex,
        lda: ::std::os::raw::c_int,
        ipiv: *mut hipblasDoubleComplex,
        info: *mut ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgeqrf_v2(
        handle: hipblasHandle_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        A: *mut hipComplex,
        lda: ::std::os::raw::c_int,
        ipiv: *mut hipComplex,
        info: *mut ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgeqrf_v2(
        handle: hipblasHandle_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        A: *mut hipDoubleComplex,
        lda: ::std::os::raw::c_int,
        ipiv: *mut hipDoubleComplex,
        info: *mut ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief SOLVER API\n\n\\details\ngeqrfBatched computes the QR factorization of a batch of general\nm-by-n matrices.\n\nThe factorization of matrix \\f$A_i\\f$ in the batch has the form\n\n\\f[\nA_i = Q_i\\left[\\begin{array}{c}\nR_i\\\\\n0\n\\end{array}\\right]\n\\f]\n\nwhere \\f$R_i\\f$ is upper triangular (upper trapezoidal if m < n), and \\f$Q_i\\f$ is\na m-by-m orthogonal/unitary matrix represented as the product of Householder matrices\n\n\\f[\nQ_i = H_{i_1}H_{i_2}\\cdots H_{i_k}, \\quad \\text{with} \\: k = \\text{min}(m,n)\n\\f]\n\nEach Householder matrix \\f$H_{i_j}\\f$ is given by\n\n\\f[\nH_{i_j} = I - \\text{ipiv}_i[j] \\cdot v_{i_j} v_{i_j}'\n\\f]\n\nwhere the first j-1 elements of Householder vector \\f$v_{i_j}\\f$ are zero, and \\f$v_{i_j}[j] = 1\\f$.\n\n- Supported precisions in rocSOLVER : s,d,c,z\n- Supported precisions in cuBLAS    : s,d,c,z\n\n@param[in]\nhandle    hipblasHandle_t.\n@param[in]\nm         int. m >= 0.\\n\nThe number of rows of all the matrices A_i in the batch.\n@param[in]\nn         int. n >= 0.\\n\nThe number of columns of all the matrices A_i in the batch.\n@param[inout]\nA         Array of pointers to type. Each pointer points to an array on the GPU of dimension lda*n.\\n\nOn entry, the m-by-n matrices A_i to be factored.\nOn exit, the elements on and above the diagonal contain the\nfactor R_i. The elements below the diagonal are the last m - j elements\nof Householder vector v_(i_j).\n@param[in]\nlda       int. lda >= m.\\n\nSpecifies the leading dimension of matrices A_i.\n@param[out]\nipiv      array of pointers to type. Each pointer points to an array on the GPU\nof dimension min(m, n).\\n\nContains the vectors ipiv_i of corresponding Householder scalars.\n@param[out]\ninfo      pointer to a int on the host.\\n\nIf info = 0, successful exit.\nIf info = j < 0, the argument at position -j is invalid.\n@param[in]\nbatchCount  int. batchCount >= 0.\\n\nNumber of matrices in the batch."]
    pub fn hipblasSgeqrfBatched(
        handle: hipblasHandle_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        A: *const *mut f32,
        lda: ::std::os::raw::c_int,
        ipiv: *const *mut f32,
        info: *mut ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDgeqrfBatched(
        handle: hipblasHandle_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        A: *const *mut f64,
        lda: ::std::os::raw::c_int,
        ipiv: *const *mut f64,
        info: *mut ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgeqrfBatched(
        handle: hipblasHandle_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        A: *const *mut hipblasComplex,
        lda: ::std::os::raw::c_int,
        ipiv: *const *mut hipblasComplex,
        info: *mut ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgeqrfBatched(
        handle: hipblasHandle_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        A: *const *mut hipblasDoubleComplex,
        lda: ::std::os::raw::c_int,
        ipiv: *const *mut hipblasDoubleComplex,
        info: *mut ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgeqrfBatched_v2(
        handle: hipblasHandle_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        A: *const *mut hipComplex,
        lda: ::std::os::raw::c_int,
        ipiv: *const *mut hipComplex,
        info: *mut ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgeqrfBatched_v2(
        handle: hipblasHandle_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        A: *const *mut hipDoubleComplex,
        lda: ::std::os::raw::c_int,
        ipiv: *const *mut hipDoubleComplex,
        info: *mut ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief SOLVER API\n\n\\details\ngeqrfStridedBatched computes the QR factorization of a batch of\ngeneral m-by-n matrices.\n\nThe factorization of matrix \\f$A_i\\f$ in the batch has the form\n\n\\f[\nA_i = Q_i\\left[\\begin{array}{c}\nR_i\\\\\n0\n\\end{array}\\right]\n\\f]\n\nwhere \\f$R_i\\f$ is upper triangular (upper trapezoidal if m < n), and \\f$Q_i\\f$ is\na m-by-m orthogonal/unitary matrix represented as the product of Householder matrices\n\n\\f[\nQ_i = H_{i_1}H_{i_2}\\cdots H_{i_k}, \\quad \\text{with} \\: k = \\text{min}(m,n)\n\\f]\n\nEach Householder matrix \\f$H_{i_j}\\f$ is given by\n\n\\f[\nH_{i_j} = I - \\text{ipiv}_j[j] \\cdot v_{i_j} v_{i_j}'\n\\f]\n\nwhere the first j-1 elements of Householder vector \\f$v_{i_j}\\f$ are zero, and \\f$v_{i_j}[j] = 1\\f$.\n\n- Supported precisions in rocSOLVER : s,d,c,z\n- Supported precisions in cuBLAS    : No support\n\n@param[in]\nhandle    hipblasHandle_t.\n@param[in]\nm         int. m >= 0.\\n\nThe number of rows of all the matrices A_i in the batch.\n@param[in]\nn         int. n >= 0.\\n\nThe number of columns of all the matrices A_i in the batch.\n@param[inout]\nA         pointer to type. Array on the GPU (the size depends on the value of strideA).\\n\nOn entry, the m-by-n matrices A_i to be factored.\nOn exit, the elements on and above the diagonal contain the\nfactor R_i. The elements below the diagonal are the last m - j elements\nof Householder vector v_(i_j).\n@param[in]\nlda       int. lda >= m.\\n\nSpecifies the leading dimension of matrices A_i.\n@param[in]\nstrideA   hipblasStride.\\n\nStride from the start of one matrix A_i to the next one A_(i+1).\nThere is no restriction for the value of strideA. Normal use case is strideA >= lda*n.\n@param[out]\nipiv      pointer to type. Array on the GPU (the size depends on the value of strideP).\\n\nContains the vectors ipiv_i of corresponding Householder scalars.\n@param[in]\nstrideP   hipblasStride.\\n\nStride from the start of one vector ipiv_i to the next one ipiv_(i+1).\nThere is no restriction for the value\nof strideP. Normal use is strideP >= min(m,n).\n@param[out]\ninfo      pointer to a int on the host.\\n\nIf info = 0, successful exit.\nIf info = j < 0, the argument at position -j is invalid.\n@param[in]\nbatchCount  int. batchCount >= 0.\\n\nNumber of matrices in the batch."]
    pub fn hipblasSgeqrfStridedBatched(
        handle: hipblasHandle_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        A: *mut f32,
        lda: ::std::os::raw::c_int,
        strideA: hipblasStride,
        ipiv: *mut f32,
        strideP: hipblasStride,
        info: *mut ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDgeqrfStridedBatched(
        handle: hipblasHandle_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        A: *mut f64,
        lda: ::std::os::raw::c_int,
        strideA: hipblasStride,
        ipiv: *mut f64,
        strideP: hipblasStride,
        info: *mut ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgeqrfStridedBatched(
        handle: hipblasHandle_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        A: *mut hipblasComplex,
        lda: ::std::os::raw::c_int,
        strideA: hipblasStride,
        ipiv: *mut hipblasComplex,
        strideP: hipblasStride,
        info: *mut ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgeqrfStridedBatched(
        handle: hipblasHandle_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        A: *mut hipblasDoubleComplex,
        lda: ::std::os::raw::c_int,
        strideA: hipblasStride,
        ipiv: *mut hipblasDoubleComplex,
        strideP: hipblasStride,
        info: *mut ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgeqrfStridedBatched_v2(
        handle: hipblasHandle_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        A: *mut hipComplex,
        lda: ::std::os::raw::c_int,
        strideA: hipblasStride,
        ipiv: *mut hipComplex,
        strideP: hipblasStride,
        info: *mut ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgeqrfStridedBatched_v2(
        handle: hipblasHandle_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        A: *mut hipDoubleComplex,
        lda: ::std::os::raw::c_int,
        strideA: hipblasStride,
        ipiv: *mut hipDoubleComplex,
        strideP: hipblasStride,
        info: *mut ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " \\brief BLAS EX API\n\n\\details\ngemmEx performs one of the matrix-matrix operations\n\nC = alpha*op( A )*op( B ) + beta*C,\n\nwhere op( X ) is one of\n\nop( X ) = X      or\nop( X ) = X**T   or\nop( X ) = X**H,\n\nalpha and beta are scalars, and A, B, and C are matrices, with\nop( A ) an m by k matrix, op( B ) a k by n matrix and C is a m by n matrix.\n\n- Supported types are determined by the backend. See cuBLAS documentation for cuBLAS backend.\nFor rocBLAS backend, conversion from hipblasComputeType_t to rocblas_datatype_t happens within hipBLAS.\nSupported types are as follows:\n\n|   aType    |   bType    |   cType    |     computeType     |\n| ---------- | ---------- | ---------- | ------------------- |\n| HIP_R_16F  | HIP_R_16F  | HIP_R_16F  | HIPBLAS_COMPUTE_16F |\n| HIP_R_16F  | HIP_R_16F  | HIP_R_16F  | HIPBLAS_COMPUTE_32F |\n| HIP_R_16F  | HIP_R_16F  | HIP_R_32F  | HIPBLAS_COMPUTE_32F |\n| HIP_R_16BF | HIP_R_16BF | HIP_R_16BF | HIPBLAS_COMPUTE_32F |\n| HIP_R_16BF | HIP_R_16BF | HIP_R_32F  | HIPBLAS_COMPUTE_32F |\n| HIP_R_32F  | HIP_R_32F  | HIP_R_32F  | HIPBLAS_COMPUTE_32F |\n| HIP_R_64F  | HIP_R_64F  | HIP_R_64F  | HIPBLAS_COMPUTE_64F |\n| HIP_R_8I   | HIP_R_8I   | HIP_R_32I  | HIPBLAS_COMPUTE_32I |\n| HIP_C_32F  | HIP_C_32F  | HIP_C_32F  | HIPBLAS_COMPUTE_32F |\n| HIP_C_64F  | HIP_C_64F  | HIP_C_64F  | HIPBLAS_COMPUTE_64F |\n\nhipblasGemmExWithFlags is also available which is identical to hipblasGemmEx\nwith the addition of a \"flags\" parameter which controls flags used in Tensile to control gemm algorithms with the\nrocBLAS backend. When using a cuBLAS backend this parameter is ignored.\n\nWith HIPBLAS_V2 define, hipblasGemmEx accepts hipDataType for aType, bType, and cType.\nIt also accepts hipblasComputeType_t for computeType. hipblasGemmEx will no\nlonger support hipblasDataType_t for these parameters in a future release. hipblasGemmEx follows\nthe same convention.\n\n#ifdef HIPBLAS_V2 // available in hipBLAS version 2.0.0 and later with -DHIPBLAS_V2\n\nhipblasStatus_t hipblasGemmEx(hipblasHandle_t      handle,\nhipblasOperation_t   transA,\nhipblasOperation_t   transB,\nint                  m,\nint                  n,\nint                  k,\nconst void*          alpha,\nconst void*          A,\nhipDataType          aType,\nint                  lda,\nconst void*          B,\nhipDataType          bType,\nint                  ldb,\nconst void*          beta,\nvoid*                C,\nhipDataType          cType,\nint                  ldc,\nhipblasComputeType_t computeType,\nhipblasGemmAlgo_t    algo)\n\nhipblasStatus_t hipblasGemmExWithFlags(hipblasHandle_t      handle,\nhipblasOperation_t   transA,\nhipblasOperation_t   transB,\nint                  m,\nint                  n,\nint                  k,\nconst void*          alpha,\nconst void*          A,\nhipDataType          aType,\nint                  lda,\nconst void*          B,\nhipDataType          bType,\nint                  ldb,\nconst void*          beta,\nvoid*                C,\nhipDataType          cType,\nint                  ldc,\nhipblasComputeType_t computeType,\nhipblasGemmAlgo_t    algo,\nhipblasGemmFlags_t   flags)\n\n#else // [DEPRECATED]\n\nhipblasStatus_t hipblasGemmEx(hipblasHandle_t    handle,\nhipblasOperation_t transA,\nhipblasOperation_t transB,\nint                m,\nint                n,\nint                k,\nconst void*        alpha,\nconst void*        A,\nhipblasDatatype_t  aType,\nint                lda,\nconst void*        B,\nhipblasDatatype_t  bType,\nint                ldb,\nconst void*        beta,\nvoid*              C,\nhipblasDatatype_t  cType,\nint                ldc,\nhipblasDatatype_t  computeType,\nhipblasGemmAlgo_t  algo)\n\nhipblasStatus_t hipblasGemmExWithFlags(hipblasHandle_t      handle,\nhipblasOperation_t   transA,\nhipblasOperation_t   transB,\nint                  m,\nint                  n,\nint                  k,\nconst void*          alpha,\nconst void*          A,\nhipblasDatatype_t    aType,\nint                  lda,\nconst void*          B,\nhipblasDatatype_t    bType,\nint                  ldb,\nconst void*          beta,\nvoid*                C,\nhipblasDatatype_t    cType,\nint                  ldc,\nhipblasDatatype_t    computeType,\nhipblasGemmAlgo_t    algo,\nhipblasGemmFlags_t   flags)\n\n#endif\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n@param[in]\ntransA    [hipblasOperation_t]\nspecifies the form of op( A ).\n@param[in]\ntransB    [hipblasOperation_t]\nspecifies the form of op( B ).\n@param[in]\nm         [int]\nmatrix dimension m.\n@param[in]\nn         [int]\nmatrix dimension n.\n@param[in]\nk         [int]\nmatrix dimension k.\n@param[in]\nalpha     [const void *]\ndevice pointer or host pointer specifying the scalar alpha. Same datatype as computeType.\n@param[in]\nA         [void *]\ndevice pointer storing matrix A.\n@param[in]\naType\n[hipblasDatatype_t] [DEPRECATED]\nspecifies the datatype of matrix A.\\n\n[hipDataType]\nspecifies the datatype of matrix A.\n@param[in]\nlda       [int]\nspecifies the leading dimension of A.\n@param[in]\nB         [void *]\ndevice pointer storing matrix B.\n@param[in]\nbType\n[hipblasDatatype_t] [DEPRECATED]\nspecifies the datatype of matrix B.\\n\n[hipDataType]\nspecifies the datatype of matrix B.\n@param[in]\nldb       [int]\nspecifies the leading dimension of B.\n@param[in]\nbeta      [const void *]\ndevice pointer or host pointer specifying the scalar beta. Same datatype as computeType.\n@param[in]\nC         [void *]\ndevice pointer storing matrix C.\n@param[in]\ncType\n[hipblasDatatype_t] [DEPRECATED]\nspecifies the datatype of matrix C.\\n\n[hipDataType]\nspecifies the datatype of matrix C.\n@param[in]\nldc       [int]\nspecifies the leading dimension of C.\n@param[in]\ncomputeType\n[hipblasDatatype_t] [DEPRECATED]\nspecifies the datatype of computation.\\n\n[hipblasComputeType_t]\nspecifies the datatype of computation.\n@param[in]\nalgo      [hipblasGemmAlgo_t]\nenumerant specifying the algorithm type.\n"]
    pub fn hipblasGemmEx(
        handle: hipblasHandle_t,
        transA: hipblasOperation_t,
        transB: hipblasOperation_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        alpha: *const ::std::os::raw::c_void,
        A: *const ::std::os::raw::c_void,
        aType: hipblasDatatype_t,
        lda: ::std::os::raw::c_int,
        B: *const ::std::os::raw::c_void,
        bType: hipblasDatatype_t,
        ldb: ::std::os::raw::c_int,
        beta: *const ::std::os::raw::c_void,
        C: *mut ::std::os::raw::c_void,
        cType: hipblasDatatype_t,
        ldc: ::std::os::raw::c_int,
        computeType: hipblasDatatype_t,
        algo: hipblasGemmAlgo_t,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasGemmEx_v2(
        handle: hipblasHandle_t,
        transA: hipblasOperation_t,
        transB: hipblasOperation_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        alpha: *const ::std::os::raw::c_void,
        A: *const ::std::os::raw::c_void,
        aType: hipDataType,
        lda: ::std::os::raw::c_int,
        B: *const ::std::os::raw::c_void,
        bType: hipDataType,
        ldb: ::std::os::raw::c_int,
        beta: *const ::std::os::raw::c_void,
        C: *mut ::std::os::raw::c_void,
        cType: hipDataType,
        ldc: ::std::os::raw::c_int,
        computeType: hipblasComputeType_t,
        algo: hipblasGemmAlgo_t,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasGemmExWithFlags(
        handle: hipblasHandle_t,
        transA: hipblasOperation_t,
        transB: hipblasOperation_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        alpha: *const ::std::os::raw::c_void,
        A: *const ::std::os::raw::c_void,
        aType: hipblasDatatype_t,
        lda: ::std::os::raw::c_int,
        B: *const ::std::os::raw::c_void,
        bType: hipblasDatatype_t,
        ldb: ::std::os::raw::c_int,
        beta: *const ::std::os::raw::c_void,
        C: *mut ::std::os::raw::c_void,
        cType: hipblasDatatype_t,
        ldc: ::std::os::raw::c_int,
        computeType: hipblasDatatype_t,
        algo: hipblasGemmAlgo_t,
        flags: hipblasGemmFlags_t,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasGemmExWithFlags_v2(
        handle: hipblasHandle_t,
        transA: hipblasOperation_t,
        transB: hipblasOperation_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        alpha: *const ::std::os::raw::c_void,
        A: *const ::std::os::raw::c_void,
        aType: hipDataType,
        lda: ::std::os::raw::c_int,
        B: *const ::std::os::raw::c_void,
        bType: hipDataType,
        ldb: ::std::os::raw::c_int,
        beta: *const ::std::os::raw::c_void,
        C: *mut ::std::os::raw::c_void,
        cType: hipDataType,
        ldc: ::std::os::raw::c_int,
        computeType: hipblasComputeType_t,
        algo: hipblasGemmAlgo_t,
        flags: hipblasGemmFlags_t,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " \\brief BLAS EX API\n\\details\ngemmBatchedEx performs one of the batched matrix-matrix operations\nC_i = alpha*op(A_i)*op(B_i) + beta*C_i, for i = 1, ..., batchCount.\nwhere op( X ) is one of\nop( X ) = X      or\nop( X ) = X**T   or\nop( X ) = X**H,\nalpha and beta are scalars, and A, B, and C are batched pointers to matrices, with\nop( A ) an m by k by batchCount batched matrix,\nop( B ) a k by n by batchCount batched matrix and\nC a m by n by batchCount batched matrix.\nThe batched matrices are an array of pointers to matrices.\nThe number of pointers to matrices is batchCount.\n\n- Supported types are determined by the backend. See rocBLAS/cuBLAS documentation.\n\nhipblasGemmBatchedExWithFlags is also available which is identical to hipblasGemmBatchedEx\nwith the addition of a \"flags\" parameter which controls flags used in Tensile to control gemm algorithms with the\nrocBLAS backend. When using a cuBLAS backend this parameter is ignored.\n\nWith HIPBLAS_V2 define, hipblasGemmBatchedEx accepts hipDataType for aType, bType, and cType.\nIt also accepts hipblasComputeType_t for computeType. hipblasGemmBatchedEx will no\nlonger support hipblasDataType_t for these parameters in a future release. hipblasGemmBatchedExWithFlags\nfollows the same convention.\n\n#ifdef HIPBLAS_V2 // available in hipBLAS version 2.0.0 and later with -DHIPBLAS_V2\n\nhipblasStatus_t hipblasGemmBatchedEx(hipblasHandle_t      handle,\nhipblasOperation_t   transA,\nhipblasOperation_t   transB,\nint                  m,\nint                  n,\nint                  k,\nconst void*          alpha,\nconst void*          A[],\nhipDataType          aType,\nint                  lda,\nconst void*          B[],\nhipDataType          bType,\nint                  ldb,\nconst void*          beta,\nvoid*                C[],\nhipDataType          cType,\nint                  ldc,\nint                  batchCount,\nhipblasComputeType_t computeType,\nhipblasGemmAlgo_t    algo)\n\nhipblasStatus_t hipblasGemmBatchedExWithFlags(hipblasHandle_t      handle,\nhipblasOperation_t   transA,\nhipblasOperation_t   transB,\nint                  m,\nint                  n,\nint                  k,\nconst void*          alpha,\nconst void*          A[],\nhipDataType          aType,\nint                  lda,\nconst void*          B[],\nhipDataType          bType,\nint                  ldb,\nconst void*          beta,\nvoid*                C[],\nhipDataType          cType,\nint                  ldc,\nint                  batchCount,\nhipblasComputeType_t computeType,\nhipblasGemmAlgo_t    algo,\nhipblasGemmFlags_t   flags)\n\n#else // [DEPRECATED]\n\nhipblasStatus_t hipblasGemmBatchedEx(hipblasHandle_t    handle,\nhipblasOperation_t transA,\nhipblasOperation_t transB,\nint                m,\nint                n,\nint                k,\nconst void*        alpha,\nconst void*        A[],\nhipblasDatatype_t  aType,\nint                lda,\nconst void*        B[],\nhipblasDatatype_t  bType,\nint                ldb,\nconst void*        beta,\nvoid*              C[],\nhipblasDatatype_t  cType,\nint                ldc,\nint                batchCount,\nhipblasDatatype_t  computeType,\nhipblasGemmAlgo_t  algo)\n\nhipblasStatus_t hipblasGemmBatchedExWithFlags(hipblasHandle_t      handle,\nhipblasOperation_t   transA,\nhipblasOperation_t   transB,\nint                  m,\nint                  n,\nint                  k,\nconst void*          alpha,\nconst void*          A[],\nhipblasDatatype_t    aType,\nint                  lda,\nconst void*          B[],\nhipblasDatatype_t    bType,\nint                  ldb,\nconst void*          beta,\nvoid*                C[],\nhipblasDatatype_t    cType,\nint                  ldc,\nint                  batchCount,\nhipblasDatatype_t    computeType,\nhipblasGemmAlgo_t    algo,\nhipblasGemmFlags_t   flags)\n\n#endif\n\n\n\n\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n@param[in]\ntransA    [hipblasOperation_t]\nspecifies the form of op( A ).\n@param[in]\ntransB    [hipblasOperation_t]\nspecifies the form of op( B ).\n@param[in]\nm         [int]\nmatrix dimension m.\n@param[in]\nn         [int]\nmatrix dimension n.\n@param[in]\nk         [int]\nmatrix dimension k.\n@param[in]\nalpha     [const void *]\ndevice pointer or host pointer specifying the scalar alpha. Same datatype as computeType.\n@param[in]\nA         [void *]\ndevice pointer storing array of pointers to each matrix A_i.\n@param[in]\naType\n[hipblasDatatype_t] [DEPRECATED]\nspecifies the datatype of each matrix A_i.\\n\n[hipDataType]\nspecifies the datatype of each matrix A_i.\n@param[in]\nlda       [int]\nspecifies the leading dimension of each A_i.\n@param[in]\nB         [void *]\ndevice pointer storing array of pointers to each matrix B_i.\n@param[in]\nbType\n[hipblasDatatype_t] [DEPRECATED]\nspecifies the datatype of each matrix B_i.\\n\n[hipDataType]\nspecifies the datatype of each matrix B_i.\n@param[in]\nldb       [int]\nspecifies the leading dimension of each B_i.\n@param[in]\nbeta      [const void *]\ndevice pointer or host pointer specifying the scalar beta. Same datatype as computeType.\n@param[in]\nC         [void *]\ndevice array of device pointers to each matrix C_i.\n@param[in]\ncType\n[hipblasDatatype_t] [DEPRECATED]\nspecifies the datatype of each matrix C_i.\\n\n[hipDataType]\nspecifies the datatype of each matrix C_i.\n@param[in]\nldc       [int]\nspecifies the leading dimension of each C_i.\n@param[in]\nbatchCount\n[int]\nnumber of gemm operations in the batch.\n@param[in]\ncomputeType\n[hipblasDatatype_t] [DEPRECATED]\nspecifies the datatype of computation.\\n\n[hipblasComputeType_t]\nspecifies the datatype of computation.\n@param[in]\nalgo      [hipblasGemmAlgo_t]\nenumerant specifying the algorithm type.\n"]
    pub fn hipblasGemmBatchedEx(
        handle: hipblasHandle_t,
        transA: hipblasOperation_t,
        transB: hipblasOperation_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        alpha: *const ::std::os::raw::c_void,
        A: *mut *const ::std::os::raw::c_void,
        aType: hipblasDatatype_t,
        lda: ::std::os::raw::c_int,
        B: *mut *const ::std::os::raw::c_void,
        bType: hipblasDatatype_t,
        ldb: ::std::os::raw::c_int,
        beta: *const ::std::os::raw::c_void,
        C: *mut *mut ::std::os::raw::c_void,
        cType: hipblasDatatype_t,
        ldc: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
        computeType: hipblasDatatype_t,
        algo: hipblasGemmAlgo_t,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasGemmBatchedEx_v2(
        handle: hipblasHandle_t,
        transA: hipblasOperation_t,
        transB: hipblasOperation_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        alpha: *const ::std::os::raw::c_void,
        A: *mut *const ::std::os::raw::c_void,
        aType: hipDataType,
        lda: ::std::os::raw::c_int,
        B: *mut *const ::std::os::raw::c_void,
        bType: hipDataType,
        ldb: ::std::os::raw::c_int,
        beta: *const ::std::os::raw::c_void,
        C: *mut *mut ::std::os::raw::c_void,
        cType: hipDataType,
        ldc: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
        computeType: hipblasComputeType_t,
        algo: hipblasGemmAlgo_t,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasGemmBatchedExWithFlags(
        handle: hipblasHandle_t,
        transA: hipblasOperation_t,
        transB: hipblasOperation_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        alpha: *const ::std::os::raw::c_void,
        A: *mut *const ::std::os::raw::c_void,
        aType: hipblasDatatype_t,
        lda: ::std::os::raw::c_int,
        B: *mut *const ::std::os::raw::c_void,
        bType: hipblasDatatype_t,
        ldb: ::std::os::raw::c_int,
        beta: *const ::std::os::raw::c_void,
        C: *mut *mut ::std::os::raw::c_void,
        cType: hipblasDatatype_t,
        ldc: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
        computeType: hipblasDatatype_t,
        algo: hipblasGemmAlgo_t,
        flags: hipblasGemmFlags_t,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasGemmBatchedExWithFlags_v2(
        handle: hipblasHandle_t,
        transA: hipblasOperation_t,
        transB: hipblasOperation_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        alpha: *const ::std::os::raw::c_void,
        A: *mut *const ::std::os::raw::c_void,
        aType: hipDataType,
        lda: ::std::os::raw::c_int,
        B: *mut *const ::std::os::raw::c_void,
        bType: hipDataType,
        ldb: ::std::os::raw::c_int,
        beta: *const ::std::os::raw::c_void,
        C: *mut *mut ::std::os::raw::c_void,
        cType: hipDataType,
        ldc: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
        computeType: hipblasComputeType_t,
        algo: hipblasGemmAlgo_t,
        flags: hipblasGemmFlags_t,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " \\brief BLAS EX API\n\n\\details\ngemmStridedBatchedEx performs one of the strided_batched matrix-matrix operations\n\nC_i = alpha*op(A_i)*op(B_i) + beta*C_i, for i = 1, ..., batchCount\n\nwhere op( X ) is one of\n\nop( X ) = X      or\nop( X ) = X**T   or\nop( X ) = X**H,\n\nalpha and beta are scalars, and A, B, and C are strided_batched matrices, with\nop( A ) an m by k by batchCount strided_batched matrix,\nop( B ) a k by n by batchCount strided_batched matrix and\nC a m by n by batchCount strided_batched matrix.\n\nThe strided_batched matrices are multiple matrices separated by a constant stride.\nThe number of matrices is batchCount.\n\n- Supported types are determined by the backend. See rocBLAS/cuBLAS documentation.\n\nhipblasGemmStridedBatchedExWithFlags is also available which is identical to hipblasStridedBatchedGemmEx\nwith the addition of a \"flags\" parameter which controls flags used in Tensile to control gemm algorithms with the\nrocBLAS backend. When using a cuBLAS backend this parameter is ignored.\n\nWith HIPBLAS_V2 define, hipblasGemmStridedBatchedEx accepts hipDataType for aType, bType, and cType.\nIt also accepts hipblasComputeType_t for computeType. hipblasGemmStridedBatchedEx will no\nlonger support hipblasDataType_t for these parameters in a future release. hipblasGemmStridedBatchedExWithFlags\nfollows the same convention.\n\n#ifdef HIPBLAS_V2 // available in hipBLAS version 2.0.0 and later with -DHIPBLAS_V2\n\nhipblasStatus_t hipblasGemmStridedBatchedEx(hipblasHandle_t      handle,\nhipblasOperation_t   transA,\nhipblasOperation_t   transB,\nint                  m,\nint                  n,\nint                  k,\nconst void*          alpha,\nconst void*          A,\nhipDataType          aType,\nint                  lda,\nhipblasStride        strideA,\nconst void*          B,\nhipDataType          bType,\nint                  ldb,\nhipblasStride        strideB,\nconst void*          beta,\nvoid*                C,\nhipDataType          cType,\nint                  ldc,\nhipblasStride        strideC,\nint                  batchCount,\nhipblasComputeType_t computeType,\nhipblasGemmAlgo_t    algo)\n\nhipblasStatus_t hipblasGemmStridedBatchedExWithFlags(hipblasHandle_t      handle,\nhipblasOperation_t   transA,\nhipblasOperation_t   transB,\nint                  m,\nint                  n,\nint                  k,\nconst void*          alpha,\nconst void*          A,\nhipDataType          aType,\nint                  lda,\nhipblasStride        strideA,\nconst void*          B,\nhipDataType          bType,\nint                  ldb,\nhipblasStride        strideB,\nconst void*          beta,\nvoid*                C,\nhipDataType          cType,\nint                  ldc,\nhipblasStride        strideC,\nint                  batchCount,\nhipblasComputeType_t computeType,\nhipblasGemmAlgo_t    algo,\nhipblasGemmFlags_t   flags)\n\n#else // [DEPRECATED]\n\nhipblasStatus_t hipblasGemmStridedBatchedEx(hipblasHandle_t    handle,\nhipblasOperation_t transA,\nhipblasOperation_t transB,\nint                m,\nint                n,\nint                k,\nconst void*        alpha,\nconst void*        A,\nhipblasDatatype_t  aType,\nint                lda,\nhipblasStride      strideA,\nconst void*        B,\nhipblasDatatype_t  bType,\nint                ldb,\nhipblasStride      strideB,\nconst void*        beta,\nvoid*              C,\nhipblasDatatype_t  cType,\nint                ldc,\nhipblasStride      strideC,\nint                batchCount,\nhipblasDatatype_t  computeType,\nhipblasGemmAlgo_t  algo)\n\nhipblasStatus_t hipblasGemmStridedBatchedExWithFlags(hipblasHandle_t      handle,\nhipblasOperation_t   transA,\nhipblasOperation_t   transB,\nint                  m,\nint                  n,\nint                  k,\nconst void*          alpha,\nconst void*          A,\nhipblasDatatype_t    aType,\nint                  lda,\nhipblasStride        strideA,\nconst void*          B,\nhipblasDatatype_t    bType,\nint                  ldb,\nhipblasStride        strideB,\nconst void*          beta,\nvoid*                C,\nhipblasDatatype_t    cType,\nint                  ldc,\nhipblasStride        strideC,\nint                  batchCount,\nhipblasDatatype_t    computeType,\nhipblasGemmAlgo_t    algo,\nhipblasGemmFlags_t   flags)\n\n#endif\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n@param[in]\ntransA    [hipblasOperation_t]\nspecifies the form of op( A ).\n@param[in]\ntransB    [hipblasOperation_t]\nspecifies the form of op( B ).\n@param[in]\nm         [int]\nmatrix dimension m.\n@param[in]\nn         [int]\nmatrix dimension n.\n@param[in]\nk         [int]\nmatrix dimension k.\n@param[in]\nalpha     [const void *]\ndevice pointer or host pointer specifying the scalar alpha. Same datatype as computeType.\n@param[in]\nA         [void *]\ndevice pointer pointing to first matrix A_1.\n@param[in]\naType\n[hipblasDatatype_t] [DEPRECATED]\nspecifies the datatype of each matrix A_i.\\n\n[hipDataType]\nspecifies the datatype of each matrix A_i.\n@param[in]\nlda       [int]\nspecifies the leading dimension of each A_i.\n@param[in]\nstrideA  [hipblasStride]\nspecifies stride from start of one A_i matrix to the next A_(i + 1).\n@param[in]\nB         [void *]\ndevice pointer pointing to first matrix B_1.\n@param[in]\nbType\n[hipblasDatatype_t] [DEPRECATED]\nspecifies the datatype of each matrix B_i.\\n\n[hipDataType]\nspecifies the datatype of each matrix B_i.\n@param[in]\nldb       [int]\nspecifies the leading dimension of each B_i.\n@param[in]\nstrideB  [hipblasStride]\nspecifies stride from start of one B_i matrix to the next B_(i + 1).\n@param[in]\nbeta      [const void *]\ndevice pointer or host pointer specifying the scalar beta. Same datatype as computeType.\n@param[in]\nC         [void *]\ndevice pointer pointing to first matrix C_1.\n@param[in]\ncType\n[hipblasDatatype_t] [DEPRECATED]\nspecifies the datatype of each matrix C_i.\\n\n[hipDataType]\nspecifies the datatype of each matrix C_i.\n@param[in]\nldc       [int]\nspecifies the leading dimension of each C_i.\n@param[in]\nstrideC  [hipblasStride]\nspecifies stride from start of one C_i matrix to the next C_(i + 1).\n@param[in]\nbatchCount\n[int]\nnumber of gemm operations in the batch.\n@param[in]\ncomputeType\n[hipblasDatatype_t] [DEPRECATED]\nspecifies the datatype of computation.\\n\n[hipblasComputeType_t]\nspecifies the datatype of computation.\n@param[in]\nalgo      [hipblasGemmAlgo_t]\nenumerant specifying the algorithm type.\n"]
    pub fn hipblasGemmStridedBatchedEx(
        handle: hipblasHandle_t,
        transA: hipblasOperation_t,
        transB: hipblasOperation_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        alpha: *const ::std::os::raw::c_void,
        A: *const ::std::os::raw::c_void,
        aType: hipblasDatatype_t,
        lda: ::std::os::raw::c_int,
        strideA: hipblasStride,
        B: *const ::std::os::raw::c_void,
        bType: hipblasDatatype_t,
        ldb: ::std::os::raw::c_int,
        strideB: hipblasStride,
        beta: *const ::std::os::raw::c_void,
        C: *mut ::std::os::raw::c_void,
        cType: hipblasDatatype_t,
        ldc: ::std::os::raw::c_int,
        strideC: hipblasStride,
        batchCount: ::std::os::raw::c_int,
        computeType: hipblasDatatype_t,
        algo: hipblasGemmAlgo_t,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasGemmStridedBatchedEx_v2(
        handle: hipblasHandle_t,
        transA: hipblasOperation_t,
        transB: hipblasOperation_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        alpha: *const ::std::os::raw::c_void,
        A: *const ::std::os::raw::c_void,
        aType: hipDataType,
        lda: ::std::os::raw::c_int,
        strideA: hipblasStride,
        B: *const ::std::os::raw::c_void,
        bType: hipDataType,
        ldb: ::std::os::raw::c_int,
        strideB: hipblasStride,
        beta: *const ::std::os::raw::c_void,
        C: *mut ::std::os::raw::c_void,
        cType: hipDataType,
        ldc: ::std::os::raw::c_int,
        strideC: hipblasStride,
        batchCount: ::std::os::raw::c_int,
        computeType: hipblasComputeType_t,
        algo: hipblasGemmAlgo_t,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasGemmStridedBatchedExWithFlags(
        handle: hipblasHandle_t,
        transA: hipblasOperation_t,
        transB: hipblasOperation_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        alpha: *const ::std::os::raw::c_void,
        A: *const ::std::os::raw::c_void,
        aType: hipblasDatatype_t,
        lda: ::std::os::raw::c_int,
        strideA: hipblasStride,
        B: *const ::std::os::raw::c_void,
        bType: hipblasDatatype_t,
        ldb: ::std::os::raw::c_int,
        strideB: hipblasStride,
        beta: *const ::std::os::raw::c_void,
        C: *mut ::std::os::raw::c_void,
        cType: hipblasDatatype_t,
        ldc: ::std::os::raw::c_int,
        strideC: hipblasStride,
        batchCount: ::std::os::raw::c_int,
        computeType: hipblasDatatype_t,
        algo: hipblasGemmAlgo_t,
        flags: hipblasGemmFlags_t,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasGemmStridedBatchedExWithFlags_v2(
        handle: hipblasHandle_t,
        transA: hipblasOperation_t,
        transB: hipblasOperation_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        alpha: *const ::std::os::raw::c_void,
        A: *const ::std::os::raw::c_void,
        aType: hipDataType,
        lda: ::std::os::raw::c_int,
        strideA: hipblasStride,
        B: *const ::std::os::raw::c_void,
        bType: hipDataType,
        ldb: ::std::os::raw::c_int,
        strideB: hipblasStride,
        beta: *const ::std::os::raw::c_void,
        C: *mut ::std::os::raw::c_void,
        cType: hipDataType,
        ldc: ::std::os::raw::c_int,
        strideC: hipblasStride,
        batchCount: ::std::os::raw::c_int,
        computeType: hipblasComputeType_t,
        algo: hipblasGemmAlgo_t,
        flags: hipblasGemmFlags_t,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " BLAS EX API\n\n\\details\ntrsmEx solves\n\nop(A)*X = alpha*B or X*op(A) = alpha*B,\n\nwhere alpha is a scalar, X and B are m by n matrices,\nA is triangular matrix and op(A) is one of\n\nop( A ) = A   or   op( A ) = A^T   or   op( A ) = A^H.\n\nThe matrix X is overwritten on B.\n\nThis function gives the user the ability to reuse the invA matrix between runs.\nIf invA == NULL, hipblasTrsmEx will automatically calculate invA on every run.\n\nSetting up invA:\nThe accepted invA matrix consists of the packed 128x128 inverses of the diagonal blocks of\nmatrix A, followed by any smaller diagonal block that remains.\nTo set up invA it is recommended that hipblasTrtriBatched be used with matrix A as the input.\n\nDevice memory of size 128 x k should be allocated for invA ahead of time, where k is m when\nHIPBLAS_SIDE_LEFT and is n when HIPBLAS_SIDE_RIGHT. The actual number of elements in invA\nshould be passed as invAsize.\n\nTo begin, hipblasTrtriBatched must be called on the full 128x128 sized diagonal blocks of\nmatrix A. Below are the restricted parameters:\n- n = 128\n- ldinvA = 128\n- stride_invA = 128x128\n- batchCount = k / 128,\n\nThen any remaining block may be added:\n- n = k % 128\n- invA = invA + stride_invA * previousBatchCount\n- ldinvA = 128\n- batchCount = 1\n\nWith HIPBLAS_V2 define, hipblasTrsmEx accepts hipDataType for computeType rather than\nhipblasDatatype_t. hipblasTrsmEx will only accept hipDataType in a future release.\n\n#ifdef HIPBLAS_V2 // available in hipBLAS version 2.0.0 and later with -DHIPBLAS_V2\n\nhipblasStatus_t hipblasTrsmEx(hipblasHandle_t    handle,\nhipblasSideMode_t  side,\nhipblasFillMode_t  uplo,\nhipblasOperation_t transA,\nhipblasDiagType_t  diag,\nint                m,\nint                n,\nconst void*        alpha,\nvoid*              A,\nint                lda,\nvoid*              B,\nint                ldb,\nconst void*        invA,\nint                invAsize,\nhipDataType        computeType)\n\n#else // [DEPRECATED]\n\nhipblasStatus_t hipblasTrsmEx(hipblasHandle_t    handle,\nhipblasSideMode_t  side,\nhipblasFillMode_t  uplo,\nhipblasOperation_t transA,\nhipblasDiagType_t  diag,\nint                m,\nint                n,\nconst void*        alpha,\nvoid*              A,\nint                lda,\nvoid*              B,\nint                ldb,\nconst void*        invA,\nint                invAsize,\nhipblasDatatype_t  computeType)\n\n#endif\n\n@param[in]\nhandle  [hipblasHandle_t]\nhandle to the hipblas library context queue.\n\n@param[in]\nside    [hipblasSideMode_t]\nHIPBLAS_SIDE_LEFT:       op(A)*X = alpha*B.\nHIPBLAS_SIDE_RIGHT:      X*op(A) = alpha*B.\n\n@param[in]\nuplo    [hipblasFillMode_t]\nHIPBLAS_FILL_MODE_UPPER:  A is an upper triangular matrix.\nHIPBLAS_FILL_MODE_LOWER:  A is a lower triangular matrix.\n\n@param[in]\ntransA  [hipblasOperation_t]\nHIPBLAS_OP_N: op(A) = A.\nHIPBLAS_OP_T: op(A) = A^T.\nHIPBLAS_ON_C: op(A) = A^H.\n\n@param[in]\ndiag    [hipblasDiagType_t]\nHIPBLAS_DIAG_UNIT:     A is assumed to be unit triangular.\nHIPBLAS_DIAG_NON_UNIT:  A is not assumed to be unit triangular.\n\n@param[in]\nm       [int]\nm specifies the number of rows of B. m >= 0.\n\n@param[in]\nn       [int]\nn specifies the number of columns of B. n >= 0.\n\n@param[in]\nalpha   [void *]\ndevice pointer or host pointer specifying the scalar alpha. When alpha is\n&zero then A is not referenced, and B need not be set before\nentry.\n\n@param[in]\nA       [void *]\ndevice pointer storing matrix A.\nof dimension ( lda, k ), where k is m\nwhen HIPBLAS_SIDE_LEFT and\nis n when HIPBLAS_SIDE_RIGHT\nonly the upper/lower triangular part is accessed.\n\n@param[in]\nlda     [int]\nlda specifies the first dimension of A.\nif side = HIPBLAS_SIDE_LEFT,  lda >= max( 1, m ),\nif side = HIPBLAS_SIDE_RIGHT, lda >= max( 1, n ).\n\n@param[in, out]\nB       [void *]\ndevice pointer storing matrix B.\nB is of dimension ( ldb, n ).\nBefore entry, the leading m by n part of the array B must\ncontain the right-hand side matrix B, and on exit is\noverwritten by the solution matrix X.\n\n@param[in]\nldb    [int]\nldb specifies the first dimension of B. ldb >= max( 1, m ).\n\n@param[in]\ninvA    [void *]\ndevice pointer storing the inverse diagonal blocks of A.\ninvA is of dimension ( ld_invA, k ), where k is m\nwhen HIPBLAS_SIDE_LEFT and\nis n when HIPBLAS_SIDE_RIGHT.\nld_invA must be equal to 128.\n\n@param[in]\ninvAsize [int]\ninvAsize specifies the number of elements of device memory in invA.\n\n@param[in]\ncomputeType\n[hipblasDatatype_t] [DEPRECATED]\nspecifies the datatype of computation.\\n\n[hipDataType]\nspecifies the datatype of computation.\n"]
    pub fn hipblasTrsmEx(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        alpha: *const ::std::os::raw::c_void,
        A: *mut ::std::os::raw::c_void,
        lda: ::std::os::raw::c_int,
        B: *mut ::std::os::raw::c_void,
        ldb: ::std::os::raw::c_int,
        invA: *const ::std::os::raw::c_void,
        invAsize: ::std::os::raw::c_int,
        computeType: hipblasDatatype_t,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasTrsmEx_v2(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        alpha: *const ::std::os::raw::c_void,
        A: *mut ::std::os::raw::c_void,
        lda: ::std::os::raw::c_int,
        B: *mut ::std::os::raw::c_void,
        ldb: ::std::os::raw::c_int,
        invA: *const ::std::os::raw::c_void,
        invAsize: ::std::os::raw::c_int,
        computeType: hipDataType,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " BLAS EX API\n\n\\details\ntrsmBatchedEx solves\n\nop(A_i)*X_i = alpha*B_i or X_i*op(A_i) = alpha*B_i,\n\nfor i = 1, ..., batchCount; and where alpha is a scalar, X and B are arrays of m by n matrices,\nA is an array of triangular matrix and each op(A_i) is one of\n\nop( A_i ) = A_i   or   op( A_i ) = A_i^T   or   op( A_i ) = A_i^H.\n\nEach matrix X_i is overwritten on B_i.\n\nThis function gives the user the ability to reuse the invA matrix between runs.\nIf invA == NULL, hipblasTrsmBatchedEx will automatically calculate each invA_i on every run.\n\nSetting up invA:\nEach accepted invA_i matrix consists of the packed 128x128 inverses of the diagonal blocks of\nmatrix A_i, followed by any smaller diagonal block that remains.\nTo set up each invA_i it is recommended that hipblasTrtriBatched be used with matrix A_i as the input.\ninvA is an array of pointers of batchCount length holding each invA_i.\n\nDevice memory of size 128 x k should be allocated for each invA_i ahead of time, where k is m when\nHIPBLAS_SIDE_LEFT and is n when HIPBLAS_SIDE_RIGHT. The actual number of elements in each invA_i\nshould be passed as invAsize.\n\nTo begin, hipblasTrtriBatched must be called on the full 128x128 sized diagonal blocks of each\nmatrix A_i. Below are the restricted parameters:\n- n = 128\n- ldinvA = 128\n- stride_invA = 128x128\n- batchCount = k / 128,\n\nThen any remaining block may be added:\n- n = k % 128\n- invA = invA + stride_invA * previousBatchCount\n- ldinvA = 128\n- batchCount = 1\n\nWith HIPBLAS_V2 define, hipblasTrsmBatchedEx accepts hipDataType for computeType rather than\nhipblasDatatype_t. hipblasTrsmBatchedEx will only accept hipDataType in a future release.\n\n#ifdef HIPBLAS_V2 // available in hipBLAS version 2.0.0 and later with -DHIPBLAS_V2\n\nhipblasStatus_t hipblasTrsmBatchedEx(hipblasHandle_t    handle,\nhipblasSideMode_t  side,\nhipblasFillMode_t  uplo,\nhipblasOperation_t transA,\nhipblasDiagType_t  diag,\nint                m,\nint                n,\nconst void*        alpha,\nvoid*              A,\nint                lda,\nvoid*              B,\nint                ldb,\nint                batchCount,\nconst void*        invA,\nint                invAsize,\nhipDataType        computeType)\n\n#else // [DEPRECATED]\n\nhipblasStatus_t hipblasTrsmBatchedEx(hipblasHandle_t    handle,\nhipblasSideMode_t  side,\nhipblasFillMode_t  uplo,\nhipblasOperation_t transA,\nhipblasDiagType_t  diag,\nint                m,\nint                n,\nconst void*        alpha,\nvoid*              A,\nint                lda,\nvoid*              B,\nint                ldb,\nint                batchCount,\nconst void*        invA,\nint                invAsize,\nhipblasDatatype_t  computeType)\n\n#endif\n\n@param[in]\nhandle  [hipblasHandle_t]\nhandle to the hipblas library context queue.\n\n@param[in]\nside    [hipblasSideMode_t]\nHIPBLAS_SIDE_LEFT:       op(A)*X = alpha*B.\nHIPBLAS_SIDE_RIGHT:      X*op(A) = alpha*B.\n\n@param[in]\nuplo    [hipblasFillMode_t]\nHIPBLAS_FILL_MODE_UPPER:  each A_i is an upper triangular matrix.\nHIPBLAS_FILL_MODE_LOWER:  each A_i is a lower triangular matrix.\n\n@param[in]\ntransA  [hipblasOperation_t]\nHIPBLAS_OP_N: op(A) = A.\nHIPBLAS_OP_T: op(A) = A^T.\nHIPBLAS_OP_C: op(A) = A^H.\n\n@param[in]\ndiag    [hipblasDiagType_t]\nHIPBLAS_DIAG_UNIT:     each A_i is assumed to be unit triangular.\nHIPBLAS_DIAG_NON_UNIT:  each A_i is not assumed to be unit triangular.\n\n@param[in]\nm       [int]\nm specifies the number of rows of each B_i. m >= 0.\n\n@param[in]\nn       [int]\nn specifies the number of columns of each B_i. n >= 0.\n\n@param[in]\nalpha   [void *]\ndevice pointer or host pointer alpha specifying the scalar alpha. When alpha is\n&zero then A is not referenced, and B need not be set before\nentry.\n\n@param[in]\nA       [void *]\ndevice array of device pointers storing each matrix A_i.\neach A_i is of dimension ( lda, k ), where k is m\nwhen HIPBLAS_SIDE_LEFT and\nis n when HIPBLAS_SIDE_RIGHT\nonly the upper/lower triangular part is accessed.\n\n@param[in]\nlda     [int]\nlda specifies the first dimension of each A_i.\nif side = HIPBLAS_SIDE_LEFT,  lda >= max( 1, m ),\nif side = HIPBLAS_SIDE_RIGHT, lda >= max( 1, n ).\n\n@param[in, out]\nB       [void *]\ndevice array of device pointers storing each matrix B_i.\neach B_i is of dimension ( ldb, n ).\nBefore entry, the leading m by n part of the array B_i must\ncontain the right-hand side matrix B_i, and on exit is\noverwritten by the solution matrix X_i\n\n@param[in]\nldb    [int]\nldb specifies the first dimension of each B_i. ldb >= max( 1, m ).\n\n@param[in]\nbatchCount [int]\nspecifies how many batches.\n\n@param[in]\ninvA    [void *]\ndevice array of device pointers storing the inverse diagonal blocks of each A_i.\neach invA_i is of dimension ( ld_invA, k ), where k is m\nwhen HIPBLAS_SIDE_LEFT and\nis n when HIPBLAS_SIDE_RIGHT.\nld_invA must be equal to 128.\n\n@param[in]\ninvAsize [int]\ninvAsize specifies the number of elements of device memory in each invA_i.\n\n@param[in]\ncomputeType\n[hipblasDatatype_t] [DEPRECATED]\nspecifies the datatype of computation.\\n\n[hipDataType]\nspecifies the datatype of computation.\n"]
    pub fn hipblasTrsmBatchedEx(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        alpha: *const ::std::os::raw::c_void,
        A: *mut ::std::os::raw::c_void,
        lda: ::std::os::raw::c_int,
        B: *mut ::std::os::raw::c_void,
        ldb: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
        invA: *const ::std::os::raw::c_void,
        invAsize: ::std::os::raw::c_int,
        computeType: hipblasDatatype_t,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasTrsmBatchedEx_v2(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        alpha: *const ::std::os::raw::c_void,
        A: *mut ::std::os::raw::c_void,
        lda: ::std::os::raw::c_int,
        B: *mut ::std::os::raw::c_void,
        ldb: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
        invA: *const ::std::os::raw::c_void,
        invAsize: ::std::os::raw::c_int,
        computeType: hipDataType,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " BLAS EX API\n\n\\details\ntrsmStridedBatchedEx solves\n\nop(A_i)*X_i = alpha*B_i or X_i*op(A_i) = alpha*B_i,\n\nfor i = 1, ..., batchCount; and where alpha is a scalar, X and B are strided batched m by n matrices,\nA is a strided batched triangular matrix and op(A_i) is one of\n\nop( A_i ) = A_i   or   op( A_i ) = A_i^T   or   op( A_i ) = A_i^H.\n\nEach matrix X_i is overwritten on B_i.\n\nThis function gives the user the ability to reuse each invA_i matrix between runs.\nIf invA == NULL, hipblasTrsmStridedBatchedEx will automatically calculate each invA_i on every run.\n\nSetting up invA:\nEach accepted invA_i matrix consists of the packed 128x128 inverses of the diagonal blocks of\nmatrix A_i, followed by any smaller diagonal block that remains.\nTo set up invA_i it is recommended that hipblasTrtriBatched be used with matrix A_i as the input.\ninvA is a contiguous piece of memory holding each invA_i.\n\nDevice memory of size 128 x k should be allocated for each invA_i ahead of time, where k is m when\nHIPBLAS_SIDE_LEFT and is n when HIPBLAS_SIDE_RIGHT. The actual number of elements in each invA_i\nshould be passed as invAsize.\n\nTo begin, hipblasTrtriBatched must be called on the full 128x128 sized diagonal blocks of each\nmatrix A_i. Below are the restricted parameters:\n- n = 128\n- ldinvA = 128\n- stride_invA = 128x128\n- batchCount = k / 128,\n\nThen any remaining block may be added:\n- n = k % 128\n- invA = invA + stride_invA * previousBatchCount\n- ldinvA = 128\n- batchCount = 1\n\nWith HIPBLAS_V2 define, hipblasStridedBatchedTrsmEx accepts hipDataType for computeType rather than\nhipblasDatatype_t. hipblasTrsmStridedBatchedEx will only accept hipDataType in a future release.\n\n#ifdef HIPBLAS_V2 // available in hipBLAS version 2.0.0 and later with -DHIPBLAS_V2\n\nhipblasStatus_t hipblasTrsmStridedBatchedEx(hipblasHandle_t    handle,\nhipblasSideMode_t  side,\nhipblasFillMode_t  uplo,\nhipblasOperation_t transA,\nhipblasDiagType_t  diag,\nint                m,\nint                n,\nconst void*        alpha,\nvoid*              A,\nint                lda,\nhipblasStride      strideA,\nvoid*              B,\nint                ldb,\nhipblasStride      strideB,\nint                batchCount,\nconst void*        invA,\nint                invAsize,\nhipblasStride      strideInvA,\nhipDataType        computeType);\n\n#else // [DEPRECATED]\n\nhipblasStatus_t hipblasTrsmStridedBatchedEx(hipblasHandle_t    handle,\nhipblasSideMode_t  side,\nhipblasFillMode_t  uplo,\nhipblasOperation_t transA,\nhipblasDiagType_t  diag,\nint                m,\nint                n,\nconst void*        alpha,\nvoid*              A,\nint                lda,\nhipblasStride      strideA,\nvoid*              B,\nint                ldb,\nhipblasStride      strideB,\nint                batchCount,\nconst void*        invA,\nint                invAsize,\nhipblasStride      strideInvA,\nhipblasDatatype_t  computeType)\n\n#endif\n\n@param[in]\nhandle  [hipblasHandle_t]\nhandle to the hipblas library context queue.\n\n@param[in]\nside    [hipblasSideMode_t]\nHIPBLAS_SIDE_LEFT:       op(A)*X = alpha*B.\nHIPBLAS_SIDE_RIGHT:      X*op(A) = alpha*B.\n\n@param[in]\nuplo    [hipblasFillMode_t]\nHIPBLAS_FILL_MODE_UPPER:  each A_i is an upper triangular matrix.\nHIPBLAS_FILL_MODE_LOWER:  each A_i is a lower triangular matrix.\n\n@param[in]\ntransA  [hipblasOperation_t]\nHIPBLAS_OP_N: op(A) = A.\nHIPBLAS_OP_T: op(A) = A^T.\nHIPBLAS_OP_C: op(A) = A^H.\n\n@param[in]\ndiag    [hipblasDiagType_t]\nHIPBLAS_DIAG_UNIT:     each A_i is assumed to be unit triangular.\nHIPBLAS_DIAG_NON_UNIT:  each A_i is not assumed to be unit triangular.\n\n@param[in]\nm       [int]\nm specifies the number of rows of each B_i. m >= 0.\n\n@param[in]\nn       [int]\nn specifies the number of columns of each B_i. n >= 0.\n\n@param[in]\nalpha   [void *]\ndevice pointer or host pointer specifying the scalar alpha. When alpha is\n&zero then A is not referenced, and B need not be set before\nentry.\n\n@param[in]\nA       [void *]\ndevice pointer storing matrix A.\nof dimension ( lda, k ), where k is m\nwhen HIPBLAS_SIDE_LEFT and\nis n when HIPBLAS_SIDE_RIGHT\nonly the upper/lower triangular part is accessed.\n\n@param[in]\nlda     [int]\nlda specifies the first dimension of A.\nif side = HIPBLAS_SIDE_LEFT,  lda >= max( 1, m ),\nif side = HIPBLAS_SIDE_RIGHT, lda >= max( 1, n ).\n\n@param[in]\nstrideA [hipblasStride]\nThe stride between each A matrix.\n\n@param[in, out]\nB       [void *]\ndevice pointer pointing to first matrix B_i.\neach B_i is of dimension ( ldb, n ).\nBefore entry, the leading m by n part of each array B_i must\ncontain the right-hand side of matrix B_i, and on exit is\noverwritten by the solution matrix X_i.\n\n@param[in]\nldb    [int]\nldb specifies the first dimension of each B_i. ldb >= max( 1, m ).\n\n@param[in]\nstrideB [hipblasStride]\nThe stride between each B_i matrix.\n\n@param[in]\nbatchCount [int]\nspecifies how many batches.\n\n@param[in]\ninvA    [void *]\ndevice pointer storing the inverse diagonal blocks of each A_i.\ninvA points to the first invA_1.\neach invA_i is of dimension ( ld_invA, k ), where k is m\nwhen HIPBLAS_SIDE_LEFT and\nis n when HIPBLAS_SIDE_RIGHT.\nld_invA must be equal to 128.\n\n@param[in]\ninvAsize [int]\ninvAsize specifies the number of elements of device memory in each invA_i.\n\n@param[in]\nstrideInvA [hipblasStride]\nThe stride between each invA matrix.\n\n@param[in]\ncomputeType\n[hipblasDatatype_t] [DEPRECATED]\nspecifies the datatype of computation.\\n\n[hipDataType]\nspecifies the datatype of computation.\n"]
    pub fn hipblasTrsmStridedBatchedEx(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        alpha: *const ::std::os::raw::c_void,
        A: *mut ::std::os::raw::c_void,
        lda: ::std::os::raw::c_int,
        strideA: hipblasStride,
        B: *mut ::std::os::raw::c_void,
        ldb: ::std::os::raw::c_int,
        strideB: hipblasStride,
        batchCount: ::std::os::raw::c_int,
        invA: *const ::std::os::raw::c_void,
        invAsize: ::std::os::raw::c_int,
        strideInvA: hipblasStride,
        computeType: hipblasDatatype_t,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasTrsmStridedBatchedEx_v2(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        alpha: *const ::std::os::raw::c_void,
        A: *mut ::std::os::raw::c_void,
        lda: ::std::os::raw::c_int,
        strideA: hipblasStride,
        B: *mut ::std::os::raw::c_void,
        ldb: ::std::os::raw::c_int,
        strideB: hipblasStride,
        batchCount: ::std::os::raw::c_int,
        invA: *const ::std::os::raw::c_void,
        invAsize: ::std::os::raw::c_int,
        strideInvA: hipblasStride,
        computeType: hipDataType,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " \\brief BLAS EX API\n\n\\details\naxpyEx computes constant alpha multiplied by vector x, plus vector y\n\ny := alpha * x + y\n\n- Supported types are determined by the backend. See rocBLAS/cuBLAS documentation.\n\nWith HIPBLAS_V2 define, hipblasAxpyEx accepts hipDataType for alphaType, xType, yType,\nand executionType rather than hipblasDatatype_t. hipblasAxpyEx will only accept hipDataType\nin a future release.\n\n#ifdef HIPBLAS_V2 // available in hipBLAS version 2.0.0 and later with -DHIPBLAS_V2\n\nhipblasStatus_t hipblasAxpyEx(hipblasHandle_t handle,\nint             n,\nconst void*     alpha,\nhipDataType     alphaType,\nconst void*     x,\nhipDataType     xType,\nint             incx,\nvoid*           y,\nhipDataType     yType,\nint             incy,\nhipDataType     executionType)\n\n#else // [DEPRECATED]\n\nhipblasStatus_t hipblasAxpyEx(hipblasHandle_t   handle,\nint               n,\nconst void*       alpha,\nhipblasDatatype_t alphaType,\nconst void*       x,\nhipblasDatatype_t xType,\nint               incx,\nvoid*             y,\nhipblasDatatype_t yType,\nint               incy,\nhipblasDatatype_t executionType)\n\n#endif\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n@param[in]\nn         [int]\nthe number of elements in x and y.\n@param[in]\nalpha     device pointer or host pointer to specify the scalar alpha.\n@param[in]\nalphaType\n[hipblasDatatype_t] [DEPRECATED]\nspecifies the datatype of alpha.\\n\n[hipDataType]\nspecifies the datatype of alpha.\n@param[in]\nx         device pointer storing vector x.\n@param[in]\nxType\n[hipblasDatatype_t] [DEPRECATED]\nspecifies the datatype of vector x.\\n\n[hipDataType]\nspecifies the datatype of vector x.\n@param[in]\nincx      [int]\nspecifies the increment for the elements of x.\n@param[inout]\ny         device pointer storing vector y.\n@param[in]\nyType\n[hipblasDatatype_t] [DEPRECATED]\nspecifies the datatype of vector y.\\n\n[hipDataType]\nspecifies the datatype of vector y.\n@param[in]\nincy      [int]\nspecifies the increment for the elements of y.\n@param[in]\nexecutionType\n[hipblasDatatype_t] [DEPRECATED]\nspecifies the datatype of computation.\\n\n[hipDataType]\nspecifies the datatype of computation.\n"]
    pub fn hipblasAxpyEx(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        alpha: *const ::std::os::raw::c_void,
        alphaType: hipblasDatatype_t,
        x: *const ::std::os::raw::c_void,
        xType: hipblasDatatype_t,
        incx: ::std::os::raw::c_int,
        y: *mut ::std::os::raw::c_void,
        yType: hipblasDatatype_t,
        incy: ::std::os::raw::c_int,
        executionType: hipblasDatatype_t,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasAxpyEx_v2(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        alpha: *const ::std::os::raw::c_void,
        alphaType: hipDataType,
        x: *const ::std::os::raw::c_void,
        xType: hipDataType,
        incx: ::std::os::raw::c_int,
        y: *mut ::std::os::raw::c_void,
        yType: hipDataType,
        incy: ::std::os::raw::c_int,
        executionType: hipDataType,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " \\brief BLAS EX API\n\n\\details\naxpyBatchedEx computes constant alpha multiplied by vector x, plus vector y over\na set of batched vectors.\n\ny := alpha * x + y\n\n- Supported types are determined by the backend. See rocBLAS/cuBLAS documentation.\n\nWith HIPBLAS_V2 define, hipblasAxpyBatchedEx accepts hipDataType for alphaType, xType, yType,\nand executionType rather than hipblasDatatype_t. hipblasAxpyBatchedEx will only accept hipDataType\nin a future release.\n\n#ifdef HIPBLAS_V2 // available in hipBLAS version 2.0.0 and later with -DHIPBLAS_V2\n\nhipblasStatus_t hipblasAxpyBatchedEx(hipblasHandle_t handle,\nint             n,\nconst void*     alpha,\nhipDataType     alphaType,\nconst void*     x,\nhipDataType     xType,\nint             incx,\nvoid*           y,\nhipDataType     yType,\nint             incy,\nint             batchCount,\nhipDataType     executionType)\n\n#else // [DEPRECATED]\n\nhipblasStatus_t hipblasAxpyBatchedEx(hipblasHandle_t   handle,\nint               n,\nconst void*       alpha,\nhipblasDatatype_t alphaType,\nconst void*       x,\nhipblasDatatype_t xType,\nint               incx,\nvoid*             y,\nhipblasDatatype_t yType,\nint               incy,\nint               batchCount,\nhipblasDatatype_t executionType)\n\n#endif\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n@param[in]\nn         [int]\nthe number of elements in each x_i and y_i.\n@param[in]\nalpha     device pointer or host pointer to specify the scalar alpha.\n@param[in]\nalphaType\n[hipblasDatatype_t] [DEPRECATED]\nspecifies the datatype of alpha.\\n\n[hipDataType]\nspecifies the datatype of alpha.\n@param[in]\nx         device array of device pointers storing each vector x_i.\n@param[in]\nxType\n[hipblasDatatype_t] [DEPRECATED]\nspecifies the datatype of each vector x_i.\\n\n[hipDataType]\nspecifies the datatype of each vector x_i.\n@param[in]\nincx      [int]\nspecifies the increment for the elements of each x_i.\n@param[inout]\ny         device array of device pointers storing each vector y_i.\n@param[in]\nyType\n[hipblasDatatype_t] [DEPRECATED]\nspecifies the datatype of each vector y_i.\\n\n[hipDataType]\nspecifies the datatype of each vector y_i.\n@param[in]\nincy      [int]\nspecifies the increment for the elements of each y_i.\n@param[in]\nbatchCount [int]\nnumber of instances in the batch.\n@param[in]\nexecutionType\n[hipblasDatatype_t] [DEPRECATED]\nspecifies the datatype of computation.\\n\n[hipDataType]\nspecifies the datatype of computation.\n"]
    pub fn hipblasAxpyBatchedEx(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        alpha: *const ::std::os::raw::c_void,
        alphaType: hipblasDatatype_t,
        x: *const ::std::os::raw::c_void,
        xType: hipblasDatatype_t,
        incx: ::std::os::raw::c_int,
        y: *mut ::std::os::raw::c_void,
        yType: hipblasDatatype_t,
        incy: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
        executionType: hipblasDatatype_t,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasAxpyBatchedEx_v2(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        alpha: *const ::std::os::raw::c_void,
        alphaType: hipDataType,
        x: *const ::std::os::raw::c_void,
        xType: hipDataType,
        incx: ::std::os::raw::c_int,
        y: *mut ::std::os::raw::c_void,
        yType: hipDataType,
        incy: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
        executionType: hipDataType,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " \\brief BLAS EX API\n\n\\details\naxpyStridedBatchedEx computes constant alpha multiplied by vector x, plus vector y over\na set of strided batched vectors.\n\ny := alpha * x + y\n\n- Supported types are determined by the backend. See rocBLAS/cuBLAS documentation.\n\nWith HIPBLAS_V2 define, hipblasAxpyStridedBatchedEx accepts hipDataType for alphaType, xType, yType,\nand executionType rather than hipblasDatatype_t. hipblasAxpyStridedBatchedEx will only accept hipDataType\nin a future release.\n\n#ifdef HIPBLAS_V2 // available in hipBLAS version 2.0.0 and later with -DHIPBLAS_V2\n\nhipblasStatus_t hipblasAxpyStridedBatchedEx(hipblasHandle_t handle,\nint             n,\nconst void*     alpha,\nhipDataType     alphaType,\nconst void*     x,\nhipDataType     xType,\nint             incx,\nhipblasStride   stridex,\nvoid*           y,\nhipDataType     yType,\nint             incy,\nhipblasStride   stridey,\nint             batchCount,\nhipDataType     executionType)\n\n#else // [DEPRECATED]\n\nhipblasStatus_t hipblasAxpyStridedBatchedEx(hipblasHandle_t   handle,\nint               n,\nconst void*       alpha,\nhipblasDatatype_t alphaType,\nconst void*       x,\nhipblasDatatype_t xType,\nint               incx,\nhipblasStride     stridex,\nvoid*             y,\nhipblasDatatype_t yType,\nint               incy,\nhipblasStride     stridey,\nint               batchCount,\nhipblasDatatype_t executionType)\n\n#endif\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n@param[in]\nn         [int]\nthe number of elements in each x_i and y_i.\n@param[in]\nalpha     device pointer or host pointer to specify the scalar alpha.\n@param[in]\nalphaType\n[hipblasDatatype_t] [DEPRECATED]\nspecifies the datatype of alpha.\\n\n[hipDataType]\nspecifies the datatype of alpha.\n@param[in]\nx         device pointer to the first vector x_1.\n@param[in]\nxType\n[hipblasDatatype_t] [DEPRECATED]\nspecifies the datatype of each vector x_i.\\n\n[hipDataType]\nspecifies the datatype of each vector x_i.\n@param[in]\nincx      [int]\nspecifies the increment for the elements of each x_i.\n@param[in]\nstridex   [hipblasStride]\nstride from the start of one vector (x_i) to the next one (x_i+1).\nThere are no restrictions placed on stridex, however the user should\ntake care to ensure that stridex is of appropriate size, for a typical\ncase this means stridex >= n * incx.\n@param[inout]\ny         device pointer to the first vector y_1.\n@param[in]\nyType\n[hipblasDatatype_t] [DEPRECATED]\nspecifies the datatype of each vector y_i.\\n\n[hipDataType]\nspecifies the datatype of each vector y_i.\n@param[in]\nincy      [int]\nspecifies the increment for the elements of each y_i.\n@param[in]\nstridey   [hipblasStride]\nstride from the start of one vector (y_i) to the next one (y_i+1).\nThere are no restrictions placed on stridey, however the user should\ntake care to ensure that stridey is of appropriate size, for a typical\ncase this means stridey >= n * incy.\n@param[in]\nbatchCount [int]\nnumber of instances in the batch.\n@param[in]\nexecutionType\n[hipblasDatatype_t] [DEPRECATED]\nspecifies the datatype of computation.\\n\n[hipDataType]\nspecifies the datatype of computation.\n"]
    pub fn hipblasAxpyStridedBatchedEx(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        alpha: *const ::std::os::raw::c_void,
        alphaType: hipblasDatatype_t,
        x: *const ::std::os::raw::c_void,
        xType: hipblasDatatype_t,
        incx: ::std::os::raw::c_int,
        stridex: hipblasStride,
        y: *mut ::std::os::raw::c_void,
        yType: hipblasDatatype_t,
        incy: ::std::os::raw::c_int,
        stridey: hipblasStride,
        batchCount: ::std::os::raw::c_int,
        executionType: hipblasDatatype_t,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasAxpyStridedBatchedEx_v2(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        alpha: *const ::std::os::raw::c_void,
        alphaType: hipDataType,
        x: *const ::std::os::raw::c_void,
        xType: hipDataType,
        incx: ::std::os::raw::c_int,
        stridex: hipblasStride,
        y: *mut ::std::os::raw::c_void,
        yType: hipDataType,
        incy: ::std::os::raw::c_int,
        stridey: hipblasStride,
        batchCount: ::std::os::raw::c_int,
        executionType: hipDataType,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS EX API\n\n\\details\ndotEx  performs the dot product of vectors x and y\n\nresult = x * y;\n\ndotcEx  performs the dot product of the conjugate of complex vector x and complex vector y\n\nresult = conjugate (x) * y;\n\n- Supported types are determined by the backend. See rocBLAS/cuBLAS documentation.\n\nWith HIPBLAS_V2 define, hipblasDot(c)Ex accepts hipDataType for xType, yType,\nresultType, and executionType rather than hipblasDatatype_t. hipblasDot(c)Ex will only\naccept hipDataType in a future release.\n\n#ifdef HIPBLAS_V2 // available in hipBLAS version 2.0.0 and later with -DHIPBLAS_V2\n\nhipblasStatus_t hipblasDotEx(hipblasHandle_t handle,\nint             n,\nconst void*     x,\nhipDataType     xType,\nint             incx,\nconst void*     y,\nhipDataType     yType,\nint             incy,\nvoid*           result,\nhipDataType     resultType,\nhipDataType     executionType)\n\n#else // [DEPRECATED]\n\nhipblasStatus_t hipblasDotEx(hipblasHandle_t   handle,\nint               n,\nconst void*       x,\nhipblasDatatype_t xType,\nint               incx,\nconst void*       y,\nhipblasDatatype_t yType,\nint               incy,\nvoid*             result,\nhipblasDatatype_t resultType,\nhipblasDatatype_t executionType)\n\n#endif\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n@param[in]\nn         [int]\nthe number of elements in x and y.\n@param[in]\nx         device pointer storing vector x.\n@param[in]\nxType\n[hipblasDatatype_t] [DEPRECATED]\nspecifies the datatype of vector x.\\n\n[hipDataType]\nspecifies the datatype of vector x.\n@param[in]\nincx      [int]\nspecifies the increment for the elements of y.\n@param[in]\ny         device pointer storing vector y.\n@param[in]\nyType\n[hipblasDatatype_t] [DEPRECATED]\nspecifies the datatype of vector y.\\n\n[hipDataType]\nspecifies the datatype of vector y.\n@param[in]\nincy      [int]\nspecifies the increment for the elements of y.\n@param[inout]\nresult\ndevice pointer or host pointer to store the dot product.\nreturn is 0.0 if n <= 0.\n@param[in]\nresultType\n[hipblasDatatype_t] [DEPRECATED]\nspecifies the datatype of the result.\\n\n[hipDataType]\nspecifies the datatype of the result.\n@param[in]\nexecutionType\n[hipblasDatatype_t] [DEPRECATED]\nspecifies the datatype of computation.\\n\n[hipDataType]\nspecifies the datatype of computation.\n"]
    pub fn hipblasDotEx(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        x: *const ::std::os::raw::c_void,
        xType: hipblasDatatype_t,
        incx: ::std::os::raw::c_int,
        y: *const ::std::os::raw::c_void,
        yType: hipblasDatatype_t,
        incy: ::std::os::raw::c_int,
        result: *mut ::std::os::raw::c_void,
        resultType: hipblasDatatype_t,
        executionType: hipblasDatatype_t,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDotcEx(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        x: *const ::std::os::raw::c_void,
        xType: hipblasDatatype_t,
        incx: ::std::os::raw::c_int,
        y: *const ::std::os::raw::c_void,
        yType: hipblasDatatype_t,
        incy: ::std::os::raw::c_int,
        result: *mut ::std::os::raw::c_void,
        resultType: hipblasDatatype_t,
        executionType: hipblasDatatype_t,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = "! @}"]
    pub fn hipblasDotEx_v2(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        x: *const ::std::os::raw::c_void,
        xType: hipDataType,
        incx: ::std::os::raw::c_int,
        y: *const ::std::os::raw::c_void,
        yType: hipDataType,
        incy: ::std::os::raw::c_int,
        result: *mut ::std::os::raw::c_void,
        resultType: hipDataType,
        executionType: hipDataType,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDotcEx_v2(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        x: *const ::std::os::raw::c_void,
        xType: hipDataType,
        incx: ::std::os::raw::c_int,
        y: *const ::std::os::raw::c_void,
        yType: hipDataType,
        incy: ::std::os::raw::c_int,
        result: *mut ::std::os::raw::c_void,
        resultType: hipDataType,
        executionType: hipDataType,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS EX API\n\n\\details\ndotBatchedEx performs a batch of dot products of vectors x and y\n\nresult_i = x_i * y_i;\n\ndotcBatchedEx  performs a batch of dot products of the conjugate of complex vector x and complex vector y\n\nresult_i = conjugate (x_i) * y_i;\n\nwhere (x_i, y_i) is the i-th instance of the batch.\nx_i and y_i are vectors, for i = 1, ..., batchCount\n\n- Supported types are determined by the backend. See rocBLAS/cuBLAS documentation.\n\nWith HIPBLAS_V2 define, hipblasDot(c)BatchedEx accepts hipDataType for xType, yType,\nresultType, and executionType rather than hipblasDatatype_t. hipblasDot(c)BatchedEx will only\naccept hipDataType in a future release.\n\n#ifdef HIPBLAS_V2 // available in hipBLAS version 2.0.0 and later with -DHIPBLAS_V2\n\nhipblasStatus_t hipblasDotBatchedEx(hipblasHandle_t handle,\nint             n,\nconst void*     x,\nhipDataType     xType,\nint             incx,\nconst void*     y,\nhipDataType     yType,\nint             incy,\nint             batchCount,\nvoid*           result,\nhipDataType     resultType,\nhipDataType     executionType)\n\n#else // [DEPRECATED]\n\nhipblasStatus_t hipblasDotBatchedEx(hipblasHandle_t   handle,\nint               n,\nconst void*       x,\nhipblasDatatype_t xType,\nint               incx,\nconst void*       y,\nhipblasDatatype_t yType,\nint               incy,\nint               batchCount,\nvoid*             result,\nhipblasDatatype_t resultType,\nhipblasDatatype_t executionType)\n\n#endif\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n@param[in]\nn         [int]\nthe number of elements in each x_i and y_i.\n@param[in]\nx         device array of device pointers storing each vector x_i.\n@param[in]\nxType\n[hipblasDatatype_t] [DEPRECATED]\nspecifies the datatype of each vector x_i.\\n\n[hipDataType]\nspecifies the datatype of each vector x_i.\n@param[in]\nincx      [int]\nspecifies the increment for the elements of each x_i.\n@param[in]\ny         device array of device pointers storing each vector y_i.\n@param[in]\nyType\n[hipblasDatatype_t] [DEPRECATED]\nspecifies the datatype of each vector y_i.\\n\n[hipDataType]\nspecifies the datatype of each vector y_i.\n@param[in]\nincy      [int]\nspecifies the increment for the elements of each y_i.\n@param[in]\nbatchCount [int]\nnumber of instances in the batch\n@param[inout]\nresult\ndevice array or host array of batchCount size to store the dot products of each batch.\nreturn 0.0 for each element if n <= 0.\n@param[in]\nresultType\n[hipblasDatatype_t] [DEPRECATED]\nspecifies the datatype of the result.\\n\n[hipDataType]\nspecifies the datatype of the result.\n@param[in]\nexecutionType\n[hipblasDatatype_t] [DEPRECATED]\nspecifies the datatype of computation.\\n\n[hipDataType]\nspecifies the datatype of computation.\n"]
    pub fn hipblasDotBatchedEx(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        x: *const ::std::os::raw::c_void,
        xType: hipblasDatatype_t,
        incx: ::std::os::raw::c_int,
        y: *const ::std::os::raw::c_void,
        yType: hipblasDatatype_t,
        incy: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
        result: *mut ::std::os::raw::c_void,
        resultType: hipblasDatatype_t,
        executionType: hipblasDatatype_t,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDotcBatchedEx(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        x: *const ::std::os::raw::c_void,
        xType: hipblasDatatype_t,
        incx: ::std::os::raw::c_int,
        y: *const ::std::os::raw::c_void,
        yType: hipblasDatatype_t,
        incy: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
        result: *mut ::std::os::raw::c_void,
        resultType: hipblasDatatype_t,
        executionType: hipblasDatatype_t,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = "! @}"]
    pub fn hipblasDotBatchedEx_v2(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        x: *const ::std::os::raw::c_void,
        xType: hipDataType,
        incx: ::std::os::raw::c_int,
        y: *const ::std::os::raw::c_void,
        yType: hipDataType,
        incy: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
        result: *mut ::std::os::raw::c_void,
        resultType: hipDataType,
        executionType: hipDataType,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDotcBatchedEx_v2(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        x: *const ::std::os::raw::c_void,
        xType: hipDataType,
        incx: ::std::os::raw::c_int,
        y: *const ::std::os::raw::c_void,
        yType: hipDataType,
        incy: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
        result: *mut ::std::os::raw::c_void,
        resultType: hipDataType,
        executionType: hipDataType,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS EX API\n\n\\details\ndotStridedBatchedEx  performs a batch of dot products of vectors x and y\n\nresult_i = x_i * y_i;\n\ndotc_strided_batched_ex  performs a batch of dot products of the conjugate of complex vector x and complex vector y\n\nresult_i = conjugate (x_i) * y_i;\n\nwhere (x_i, y_i) is the i-th instance of the batch.\nx_i and y_i are vectors, for i = 1, ..., batchCount\n\n- Supported types are determined by the backend. See rocBLAS/cuBLAS documentation.\n\nWith HIPBLAS_V2 define, hipblasDot(c)StridedBatchedEx accepts hipDataType for xType, yType,\nresultType, and executionType rather than hipblasDatatype_t. hipblasDot(c)StridedBatchedEx will only\naccept hipDataType in a future release.\n\n#ifdef HIPBLAS_V2 // available in hipBLAS version 2.0.0 and later with -DHIPBLAS_V2\n\nhipblasStatus_t hipblasDotStridedBatchedEx(hipblasHandle_t handle,\nint             n,\nconst void*     x,\nhipDataType     xType,\nint             incx,\nhipblasStride   stridex,\nconst void*     y,\nhipDataType     yType,\nint             incy,\nhipblasStride   stridey,\nint             batchCount,\nvoid*           result,\nhipDataType     resultType,\nhipDataType     executionType)\n\n#else // [DEPRECATED]\n\nhipblasStatus_t hipblasDotStridedBatchedEx(hipblasHandle_t   handle,\nint               n,\nconst void*       x,\nhipblasDatatype_t xType,\nint               incx,\nhipblasStride     stridex,\nconst void*       y,\nhipblasDatatype_t yType,\nint               incy,\nhipblasStride     stridey,\nint               batchCount,\nvoid*             result,\nhipblasDatatype_t resultType,\nhipblasDatatype_t executionType)\n\n#endif\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n@param[in]\nn         [int]\nthe number of elements in each x_i and y_i.\n@param[in]\nx         device pointer to the first vector (x_1) in the batch.\n@param[in]\nxType\n[hipblasDatatype_t] [DEPRECATED]\nspecifies the datatype of each vector x_i.\\n\n[hipDataType]\nspecifies the datatype of each vector x_i.\n@param[in]\nincx      [int]\nspecifies the increment for the elements of each x_i.\n@param[in]\nstridex   [hipblasStride]\nstride from the start of one vector (x_i) and the next one (x_i+1)\n@param[in]\ny         device pointer to the first vector (y_1) in the batch.\n@param[in]\nyType\n[hipblasDatatype_t] [DEPRECATED]\nspecifies the datatype of each vector y_i.\\n\n[hipDataType]\nspecifies the datatype of each vector y_i.\n@param[in]\nincy      [int]\nspecifies the increment for the elements of each y_i.\n@param[in]\nstridey   [hipblasStride]\nstride from the start of one vector (y_i) and the next one (y_i+1)\n@param[in]\nbatchCount [int]\nnumber of instances in the batch\n@param[inout]\nresult\ndevice array or host array of batchCount size to store the dot products of each batch.\nreturn 0.0 for each element if n <= 0.\n@param[in]\nresultType\n[hipblasDatatype_t] [DEPRECATED]\nspecifies the datatype of the result.\\n\n[hipDataType]\nspecifies the datatype of the result.\n@param[in]\nexecutionType\n[hipblasDatatype_t] [DEPRECATED]\nspecifies the datatype of computation.\\n\n[hipDataType]\nspecifies the datatype of computation.\n"]
    pub fn hipblasDotStridedBatchedEx(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        x: *const ::std::os::raw::c_void,
        xType: hipblasDatatype_t,
        incx: ::std::os::raw::c_int,
        stridex: hipblasStride,
        y: *const ::std::os::raw::c_void,
        yType: hipblasDatatype_t,
        incy: ::std::os::raw::c_int,
        stridey: hipblasStride,
        batchCount: ::std::os::raw::c_int,
        result: *mut ::std::os::raw::c_void,
        resultType: hipblasDatatype_t,
        executionType: hipblasDatatype_t,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDotcStridedBatchedEx(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        x: *const ::std::os::raw::c_void,
        xType: hipblasDatatype_t,
        incx: ::std::os::raw::c_int,
        stridex: hipblasStride,
        y: *const ::std::os::raw::c_void,
        yType: hipblasDatatype_t,
        incy: ::std::os::raw::c_int,
        stridey: hipblasStride,
        batchCount: ::std::os::raw::c_int,
        result: *mut ::std::os::raw::c_void,
        resultType: hipblasDatatype_t,
        executionType: hipblasDatatype_t,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = "! @}"]
    pub fn hipblasDotStridedBatchedEx_v2(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        x: *const ::std::os::raw::c_void,
        xType: hipDataType,
        incx: ::std::os::raw::c_int,
        stridex: hipblasStride,
        y: *const ::std::os::raw::c_void,
        yType: hipDataType,
        incy: ::std::os::raw::c_int,
        stridey: hipblasStride,
        batchCount: ::std::os::raw::c_int,
        result: *mut ::std::os::raw::c_void,
        resultType: hipDataType,
        executionType: hipDataType,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDotcStridedBatchedEx_v2(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        x: *const ::std::os::raw::c_void,
        xType: hipDataType,
        incx: ::std::os::raw::c_int,
        stridex: hipblasStride,
        y: *const ::std::os::raw::c_void,
        yType: hipDataType,
        incy: ::std::os::raw::c_int,
        stridey: hipblasStride,
        batchCount: ::std::os::raw::c_int,
        result: *mut ::std::os::raw::c_void,
        resultType: hipDataType,
        executionType: hipDataType,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " \\brief BLAS_EX API\n\n\\details\nnrm2Ex computes the euclidean norm of a real or complex vector\n\nresult := sqrt( x'*x ) for real vectors\nresult := sqrt( x**H*x ) for complex vectors\n\n- Supported types are determined by the backend. See rocBLAS/cuBLAS documentation.\n\nWith HIPBLAS_V2 define, hipblasNrm2Ex accepts hipDataType for xType, resultType,\nand executionType rather than hipblasDatatype_t. hipblasNrm2Ex will only accept\nhipDataType in a future release.\n\n#ifdef HIPBLAS_V2 // available in hipBLAS version 2.0.0 and later with -DHIPBLAS_V2\n\nhipblasStatus_t hipblasNrm2Ex(hipblasHandle_t handle,\nint             n,\nconst void*     x,\nhipDataType     xType,\nint             incx,\nvoid*           result,\nhipDataType     resultType,\nhipDataType     executionType)\n\n#else // [DEPRECATED]\n\nhipblasStatus_t hipblasNrm2Ex(hipblasHandle_t   handle,\nint               n,\nconst void*       x,\nhipblasDatatype_t xType,\nint               incx,\nvoid*             result,\nhipblasDatatype_t resultType,\nhipblasDatatype_t executionType)\n\n#endif\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n@param[in]\nn         [int]\nthe number of elements in x.\n@param[in]\nx         device pointer storing vector x.\n@param[in]\nxType\n[hipblasDatatype_t] [DEPRECATED]\nspecifies the datatype of the vector x.\\n\n[hipDataType]\nspecifies the datatype of the vector x.\n@param[in]\nincx      [int]\nspecifies the increment for the elements of y.\n@param[inout]\nresult\ndevice pointer or host pointer to store the nrm2 product.\nreturn is 0.0 if n, incx<=0.\n@param[in]\nresultType\n[hipblasDatatype_t] [DEPRECATED]\nspecifies the datatype of the result.\\n\n[hipDataType]\nspecifies the datatype of the result.\n@param[in]\nexecutionType\n[hipblasDatatype_t] [DEPRECATED]\nspecifies the datatype of computation.\\n\n[hipDataType]\nspecifies the datatype of computation."]
    pub fn hipblasNrm2Ex(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        x: *const ::std::os::raw::c_void,
        xType: hipblasDatatype_t,
        incx: ::std::os::raw::c_int,
        result: *mut ::std::os::raw::c_void,
        resultType: hipblasDatatype_t,
        executionType: hipblasDatatype_t,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasNrm2Ex_v2(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        x: *const ::std::os::raw::c_void,
        xType: hipDataType,
        incx: ::std::os::raw::c_int,
        result: *mut ::std::os::raw::c_void,
        resultType: hipDataType,
        executionType: hipDataType,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " \\brief BLAS_EX API\n\n\\details\nnrm2BatchedEx computes the euclidean norm over a batch of real or complex vectors\n\nresult := sqrt( x_i'*x_i ) for real vectors x, for i = 1, ..., batchCount\nresult := sqrt( x_i**H*x_i ) for complex vectors x, for i = 1, ..., batchCount\n\n- Supported types are determined by the backend. See rocBLAS/cuBLAS documentation.\n\nWith HIPBLAS_V2 define, hipblasNrm2BatchedEx accepts hipDataType for xType, resultType,\nand executionType rather than hipblasDatatype_t. hipblasNrm2BatchedEx will only accept\nhipDataType in a future release.\n\n#ifdef HIPBLAS_V2 // available in hipBLAS version 2.0.0 and later with -DHIPBLAS_V2\n\nhipblasStatus_t hipblasNrm2BatchedEx(hipblasHandle_t handle,\nint             n,\nconst void*     x,\nhipDataType     xType,\nint             incx,\nint             batchCount,\nvoid*           result,\nhipDataType     resultType,\nhipDataType     executionType)\n\n#else // [DEPRECATED]\n\nhipblasStatus_t hipblasNrm2BatchedEx(hipblasHandle_t   handle,\nint               n,\nconst void*       x,\nhipblasDatatype_t xType,\nint               incx,\nint               batchCount,\nvoid*             result,\nhipblasDatatype_t resultType,\nhipblasDatatype_t executionType)\n\n#endif\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n@param[in]\nn         [int]\nnumber of elements in each x_i.\n@param[in]\nx         device array of device pointers storing each vector x_i.\n@param[in]\nxType\n[hipblasDatatype_t] [DEPRECATED]\nspecifies the datatype of each vector x_i.\\n\n[hipDataType]\nspecifies the datatype of each vector x_i.\n@param[in]\nincx      [int]\nspecifies the increment for the elements of each x_i. incx must be > 0.\n@param[in]\nbatchCount [int]\nnumber of instances in the batch\n@param[out]\nresult\ndevice pointer or host pointer to array of batchCount size for nrm2 results.\nreturn is 0.0 for each element if n <= 0, incx<=0.\n@param[in]\nresultType\n[hipblasDatatype_t] [DEPRECATED]\nspecifies the datatype of the result.\\n\n[hipDataType]\nspecifies the datatype of the result.\n@param[in]\nexecutionType\n[hipblasDatatype_t] [DEPRECATED]\nspecifies the datatype of computation.\\n\n[hipDataType]\nspecifies the datatype of computation.\n"]
    pub fn hipblasNrm2BatchedEx(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        x: *const ::std::os::raw::c_void,
        xType: hipblasDatatype_t,
        incx: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
        result: *mut ::std::os::raw::c_void,
        resultType: hipblasDatatype_t,
        executionType: hipblasDatatype_t,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasNrm2BatchedEx_v2(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        x: *const ::std::os::raw::c_void,
        xType: hipDataType,
        incx: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
        result: *mut ::std::os::raw::c_void,
        resultType: hipDataType,
        executionType: hipDataType,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " \\brief BLAS_EX API\n\n\\details\nnrm2StridedBatchedEx computes the euclidean norm over a batch of real or complex vectors\n\n:= sqrt( x_i'*x_i ) for real vectors x, for i = 1, ..., batchCount\n:= sqrt( x_i**H*x_i ) for complex vectors, for i = 1, ..., batchCount\n\n- Supported types are determined by the backend. See rocBLAS/cuBLAS documentation.\n\nWith HIPBLAS_V2 define, hipblasNrm2StridedBatchedEx accepts hipDataType for xType, resultType,\nand executionType rather than hipblasDatatype_t. hipblasNrm2StridedBatchedEx will only accept\nhipDataType in a future release.\n\n#ifdef HIPBLAS_V2 // available in hipBLAS version 2.0.0 and later with -DHIPBLAS_V2\n\nhipblasStatus_t hipblasNrm2StridedBatchedEx(hipblasHandle_t handle,\nint             n,\nconst void*     x,\nhipDataType     xType,\nint             incx,\nhipblasStride   stridex,\nint             batchCount,\nvoid*           result,\nhipDataType     resultType,\nhipDataType     executionType)\n\n#else // [DEPRECATED]\n\nhipblasStatus_t hipblasNrm2StridedBatchedEx(hipblasHandle_t   handle,\nint               n,\nconst void*       x,\nhipblasDatatype_t xType,\nint               incx,\nhipblasStride     stridex,\nint               batchCount,\nvoid*             result,\nhipblasDatatype_t resultType,\nhipblasDatatype_t executionType)\n\n#endif\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n@param[in]\nn         [int]\nnumber of elements in each x_i.\n@param[in]\nx         device pointer to the first vector x_1.\n@param[in]\nxType\n[hipblasDatatype_t] [DEPRECATED]\nspecifies the datatype of each vector x_i.\\n\n[hipDataType]\nspecifies the datatype of each vector x_i.\n@param[in]\nincx      [int]\nspecifies the increment for the elements of each x_i. incx must be > 0.\n@param[in]\nstridex   [hipblasStride]\nstride from the start of one vector (x_i) and the next one (x_i+1).\nThere are no restrictions placed on stride_x, however the user should\ntake care to ensure that stride_x is of appropriate size, for a typical\ncase this means stride_x >= n * incx.\n@param[in]\nbatchCount [int]\nnumber of instances in the batch\n@param[out]\nresult\ndevice pointer or host pointer to array for storing contiguous batchCount results.\nreturn is 0.0 for each element if n <= 0, incx<=0.\n@param[in]\nresultType\n[hipblasDatatype_t] [DEPRECATED]\nspecifies the datatype of the result.\\n\n[hipDataType]\nspecifies the datatype of the result.\n@param[in]\nexecutionType\n[hipblasDatatype_t] [DEPRECATED]\nspecifies the datatype of computation.\\n\n[hipDataType]\nspecifies the datatype of computation.\n"]
    pub fn hipblasNrm2StridedBatchedEx(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        x: *const ::std::os::raw::c_void,
        xType: hipblasDatatype_t,
        incx: ::std::os::raw::c_int,
        stridex: hipblasStride,
        batchCount: ::std::os::raw::c_int,
        result: *mut ::std::os::raw::c_void,
        resultType: hipblasDatatype_t,
        executionType: hipblasDatatype_t,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasNrm2StridedBatchedEx_v2(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        x: *const ::std::os::raw::c_void,
        xType: hipDataType,
        incx: ::std::os::raw::c_int,
        stridex: hipblasStride,
        batchCount: ::std::os::raw::c_int,
        result: *mut ::std::os::raw::c_void,
        resultType: hipDataType,
        executionType: hipDataType,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " \\brief BLAS EX API\n\n\\details\nrotEx applies the Givens rotation matrix defined by c=cos(alpha) and s=sin(alpha) to vectors x and y.\nScalars c and s may be stored in either host or device memory, location is specified by calling hipblasSetPointerMode.\n\nIn the case where cs_type is real:\nx := c * x + s * y\ny := c * y - s * x\n\nIn the case where cs_type is complex, the imaginary part of c is ignored:\nx := real(c) * x + s * y\ny := real(c) * y - conj(s) * x\n\n- Supported types are determined by the backend. See rocBLAS/cuBLAS documentation.\n\nWith HIPBLAS_V2 define, hipblasRotEx accepts hipDataType for xType, yType, csType,\nand executionType rather than hipblasDatatype_t. hipblasRotEx will only accept\nhipDataType in a future release.\n\n#ifdef HIPBLAS_V2 // available in hipBLAS version 2.0.0 and later with -DHIPBLAS_V2\n\nhipblasStatus_t hipblasRotEx(hipblasHandle_t handle,\nint             n,\nvoid*           x,\nhipDataType     xType,\nint             incx,\nvoid*           y,\nhipDataType     yType,\nint             incy,\nconst void*     c,\nconst void*     s,\nhipDataType     csType,\nhipDataType     executionType)\n\n#else // [DEPRECATED]\n\nhipblasStatus_t hipblasRotEx(hipblasHandle_t   handle,\nint               n,\nvoid*             x,\nhipblasDatatype_t xType,\nint               incx,\nvoid*             y,\nhipblasDatatype_t yType,\nint               incy,\nconst void*       c,\nconst void*       s,\nhipblasDatatype_t csType,\nhipblasDatatype_t executionType)\n\n#endif\n\n@param[in]\nhandle  [hipblasHandle_t]\nhandle to the hipblas library context queue.\n@param[in]\nn       [int]\nnumber of elements in the x and y vectors.\n@param[inout]\nx       device pointer storing vector x.\n@param[in]\nxType\n[hipblasDatatype_t] [DEPRECATED]\nspecifies the datatype of vector x.\\n\n[hipDataType]\nspecifies the datatype of vector x.\n@param[in]\nincx    [int]\nspecifies the increment between elements of x.\n@param[inout]\ny       device pointer storing vector y.\n@param[in]\nyType\n[hipblasDatatype_t] [DEPRECATED]\nspecifies the datatype of vector y.\\n\n[hipDataType]\nspecifies the datatype of vector y.\n@param[in]\nincy    [int]\nspecifies the increment between elements of y.\n@param[in]\nc       device pointer or host pointer storing scalar cosine component of the rotation matrix.\n@param[in]\ns       device pointer or host pointer storing scalar sine component of the rotation matrix.\n@param[in]\ncsType\n[hipblasDatatype_t] [DEPRECATED]\nspecifies the datatype of c and s.\\n\n[hipDataType]\nspecifies the datatype of c and s.\n@param[in]\nexecutionType\n[hipblasDatatype_t] [DEPRECATED]\nspecifies the datatype of computation.\\n\n[hipDataType]\nspecifies the datatype of computation.\n"]
    pub fn hipblasRotEx(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        x: *mut ::std::os::raw::c_void,
        xType: hipblasDatatype_t,
        incx: ::std::os::raw::c_int,
        y: *mut ::std::os::raw::c_void,
        yType: hipblasDatatype_t,
        incy: ::std::os::raw::c_int,
        c: *const ::std::os::raw::c_void,
        s: *const ::std::os::raw::c_void,
        csType: hipblasDatatype_t,
        executionType: hipblasDatatype_t,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasRotEx_v2(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        x: *mut ::std::os::raw::c_void,
        xType: hipDataType,
        incx: ::std::os::raw::c_int,
        y: *mut ::std::os::raw::c_void,
        yType: hipDataType,
        incy: ::std::os::raw::c_int,
        c: *const ::std::os::raw::c_void,
        s: *const ::std::os::raw::c_void,
        csType: hipDataType,
        executionType: hipDataType,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " \\brief BLAS EX API\n\n\\details\nrotBatchedEx applies the Givens rotation matrix defined by c=cos(alpha) and s=sin(alpha) to batched vectors x_i and y_i, for i = 1, ..., batchCount.\nScalars c and s may be stored in either host or device memory, location is specified by calling hipblasSetPointerMode.\n\nIn the case where cs_type is real:\nx := c * x + s * y\ny := c * y - s * x\n\nIn the case where cs_type is complex, the imaginary part of c is ignored:\nx := real(c) * x + s * y\ny := real(c) * y - conj(s) * x\n\n- Supported types are determined by the backend. See rocBLAS/cuBLAS documentation.\n\nWith HIPBLAS_V2 define, hipblasRotBatchedEx accepts hipDataType for xType, yType, csType,\nand executionType rather than hipblasDatatype_t. hipblasRotBatchedEx will only accept\nhipDataType in a future release.\n\n#ifdef HIPBLAS_V2 // available in hipBLAS version 2.0.0 and later with -DHIPBLAS_V2\n\nhipblasStatus_t hipblasRotBatchedEx(hipblasHandle_t handle,\nint             n,\nvoid*           x,\nhipDataType     xType,\nint             incx,\nvoid*           y,\nhipDataType     yType,\nint             incy,\nconst void*     c,\nconst void*     s,\nhipDataType     csType,\nint             batchCount,\nhipDataType     executionType)\n\n#else // [DEPRECATED]\n\nhipblasStatus_t hipblasRotBatchedEx(hipblasHandle_t   handle,\nint               n,\nvoid*             x,\nhipblasDatatype_t xType,\nint               incx,\nvoid*             y,\nhipblasDatatype_t yType,\nint               incy,\nconst void*       c,\nconst void*       s,\nhipblasDatatype_t csType,\nint               batchCount,\nhipblasDatatype_t executionType)\n\n#endif\n\n@param[in]\nhandle  [hipblasHandle_t]\nhandle to the hipblas library context queue.\n@param[in]\nn       [int]\nnumber of elements in each x_i and y_i vectors.\n@param[inout]\nx       device array of device pointers storing each vector x_i.\n@param[in]\nxType\n[hipblasDatatype_t] [DEPRECATED]\nspecifies the datatype of each vector x_i.\\n\n[hipDataType]\nspecifies the datatype of each vector x_i.\n@param[in]\nincx    [int]\nspecifies the increment between elements of each x_i.\n@param[inout]\ny       device array of device pointers storing each vector y_i.\n@param[in]\nyType\n[hipblasDatatype_t] [DEPRECATED]\nspecifies the datatype of each vector y_i.\\n\n[hipDataType]\nspecifies the datatype of each vector y_i.\n@param[in]\nincy    [int]\nspecifies the increment between elements of each y_i.\n@param[in]\nc       device pointer or host pointer to scalar cosine component of the rotation matrix.\n@param[in]\ns       device pointer or host pointer to scalar sine component of the rotation matrix.\n@param[in]\ncsType\n[hipblasDatatype_t] [DEPRECATED]\nspecifies the datatype of c and s.\\n\n[hipDataType]\nspecifies the datatype of c and s.\n@param[in]\nbatchCount [int]\nthe number of x and y arrays, i.e. the number of batches.\n@param[in]\nexecutionType\n[hipblasDatatype_t] [DEPRECATED]\nspecifies the datatype of computation.\\n\n[hipDataType]\nspecifies the datatype of computation.\n"]
    pub fn hipblasRotBatchedEx(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        x: *mut ::std::os::raw::c_void,
        xType: hipblasDatatype_t,
        incx: ::std::os::raw::c_int,
        y: *mut ::std::os::raw::c_void,
        yType: hipblasDatatype_t,
        incy: ::std::os::raw::c_int,
        c: *const ::std::os::raw::c_void,
        s: *const ::std::os::raw::c_void,
        csType: hipblasDatatype_t,
        batchCount: ::std::os::raw::c_int,
        executionType: hipblasDatatype_t,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasRotBatchedEx_v2(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        x: *mut ::std::os::raw::c_void,
        xType: hipDataType,
        incx: ::std::os::raw::c_int,
        y: *mut ::std::os::raw::c_void,
        yType: hipDataType,
        incy: ::std::os::raw::c_int,
        c: *const ::std::os::raw::c_void,
        s: *const ::std::os::raw::c_void,
        csType: hipDataType,
        batchCount: ::std::os::raw::c_int,
        executionType: hipDataType,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " \\brief BLAS Level 1 API\n\n\\details\nrotStridedBatchedEx applies the Givens rotation matrix defined by c=cos(alpha) and s=sin(alpha) to strided batched vectors x_i and y_i, for i = 1, ..., batchCount.\nScalars c and s may be stored in either host or device memory, location is specified by calling hipblasSetPointerMode.\n\nIn the case where cs_type is real:\nx := c * x + s * y\ny := c * y - s * x\n\nIn the case where cs_type is complex, the imaginary part of c is ignored:\nx := real(c) * x + s * y\ny := real(c) * y - conj(s) * x\n\n- Supported types are determined by the backend. See rocBLAS/cuBLAS documentation.\n\nWith HIPBLAS_V2 define, hipblasRotStridedBatchedEx accepts hipDataType for xType, yType, csType,\nand executionType rather than hipblasDatatype_t. hipblasRotStridedBatchedEx will only accept\nhipDataType in a future release.\n\n#ifdef HIPBLAS_V2 // available in hipBLAS version 2.0.0 and later with -DHIPBLAS_V2\n\nhipblasStatus_t hipblasRotStridedBatchedEx(hipblasHandle_t handle,\nint             n,\nvoid*           x,\nhipDataType     xType,\nint             incx,\nhipblasStride   stridex,\nvoid*           y,\nhipDataType     yType,\nint             incy,\nhipblasStride   stridey,\nconst void*     c,\nconst void*     s,\nhipDataType     csType,\nint             batchCount,\nhipDataType     executionType)\n\n#else // [DEPRECATED]\n\nhipblasStatus_t hipblasRotStridedBatchedEx(hipblasHandle_t   handle,\nint               n,\nvoid*             x,\nhipblasDatatype_t xType,\nint               incx,\nhipblasStride     stridex,\nvoid*             y,\nhipblasDatatype_t yType,\nint               incy,\nhipblasStride     stridey,\nconst void*       c,\nconst void*       s,\nhipblasDatatype_t csType,\nint               batchCount,\nhipblasDatatype_t executionType)\n\n#endif\n\n@param[in]\nhandle  [hipblasHandle_t]\nhandle to the hipblas library context queue.\n@param[in]\nn       [int]\nnumber of elements in each x_i and y_i vectors.\n@param[inout]\nx       device pointer to the first vector x_1.\n@param[in]\nxType\n[hipblasDatatype_t] [DEPRECATED]\nspecifies the datatype of each vector x_i.\\n\n[hipDataType]\nspecifies the datatype of each vector x_i.\n@param[in]\nincx    [int]\nspecifies the increment between elements of each x_i.\n@param[in]\nstridex [hipblasStride]\nspecifies the increment from the beginning of x_i to the beginning of x_(i+1)\n@param[inout]\ny       device pointer to the first vector y_1.\n@param[in]\nyType\n[hipblasDatatype_t] [DEPRECATED]\nspecifies the datatype of each vector y_i.\\n\n[hipDataType]\nspecifies the datatype of each vector y_i.\n@param[in]\nincy    [int]\nspecifies the increment between elements of each y_i.\n@param[in]\nstridey [hipblasStride]\nspecifies the increment from the beginning of y_i to the beginning of y_(i+1)\n@param[in]\nc       device pointer or host pointer to scalar cosine component of the rotation matrix.\n@param[in]\ns       device pointer or host pointer to scalar sine component of the rotation matrix.\n@param[in]\ncsType\n[hipblasDatatype_t] [DEPRECATED]\nspecifies the datatype of c and s.\\n\n[hipDataType]\nspecifies the datatype of c and s.\n@param[in]\nbatchCount [int]\nthe number of x and y arrays, i.e. the number of batches.\n@param[in]\nexecutionType\n[hipblasDatatype_t] [DEPRECATED]\nspecifies the datatype of computation.\\n\n[hipDataType]\nspecifies the datatype of computation.\n"]
    pub fn hipblasRotStridedBatchedEx(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        x: *mut ::std::os::raw::c_void,
        xType: hipblasDatatype_t,
        incx: ::std::os::raw::c_int,
        stridex: hipblasStride,
        y: *mut ::std::os::raw::c_void,
        yType: hipblasDatatype_t,
        incy: ::std::os::raw::c_int,
        stridey: hipblasStride,
        c: *const ::std::os::raw::c_void,
        s: *const ::std::os::raw::c_void,
        csType: hipblasDatatype_t,
        batchCount: ::std::os::raw::c_int,
        executionType: hipblasDatatype_t,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasRotStridedBatchedEx_v2(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        x: *mut ::std::os::raw::c_void,
        xType: hipDataType,
        incx: ::std::os::raw::c_int,
        stridex: hipblasStride,
        y: *mut ::std::os::raw::c_void,
        yType: hipDataType,
        incy: ::std::os::raw::c_int,
        stridey: hipblasStride,
        c: *const ::std::os::raw::c_void,
        s: *const ::std::os::raw::c_void,
        csType: hipDataType,
        batchCount: ::std::os::raw::c_int,
        executionType: hipDataType,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " \\brief BLAS EX API\n\n\\details\nscalEx  scales each element of vector x with scalar alpha.\n\nx := alpha * x\n\n- Supported types are determined by the backend. See rocBLAS/cuBLAS documentation.\n\nWith HIPBLAS_V2 define, hipblasScalEx accepts hipDataType for alphaType,\nxType, and executionType rather than hipblasDatatype_t. hipblasScalEx will only\naccept hipDataType in a future release.\n\n#ifdef HIPBLAS_V2 // available in hipBLAS version 2.0.0 and later with -DHIPBLAS_V2\n\nhipblasStatus_t hipblasScalEx(hipblasHandle_t handle,a\nint             n,\nconst void*     alpha,\nhipDataType     alphaType,\nvoid*           x,\nhipDataType     xType,\nint             incx,\nhipDataType     executionType)\n\n#else // [DEPRECATED]\n\nhipblasStatus_t hipblasScalEx(hipblasHandle_t   handle,\nint               n,\nconst void*       alpha,\nhipblasDatatype_t alphaType,\nvoid*             x,\nhipblasDatatype_t xType,\nint               incx,\nhipblasDatatype_t executionType)\n\n#endif\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n@param[in]\nn         [int]\nthe number of elements in x.\n@param[in]\nalpha     device pointer or host pointer for the scalar alpha.\n@param[in]\nalphaType\n[hipblasDatatype_t] [DEPRECATED]\nspecifies the datatype of alpha.\\n\n[hipDataType]\nspecifies the datatype of alpha.\n@param[inout]\nx         device pointer storing vector x.\n@param[in]\nxType\n[hipblasDatatype_t] [DEPRECATED]\nspecifies the datatype of vector x.\\n\n[hipDataType]\nspecifies the datatype of vector x.\n@param[in]\nincx      [int]\nspecifies the increment for the elements of x.\n@param[in]\nexecutionType\n[hipblasDatatype_t] [DEPRECATED]\nspecifies the datatype of computation.\\n\n[hipDataType]\nspecifies the datatype of computation.\n"]
    pub fn hipblasScalEx(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        alpha: *const ::std::os::raw::c_void,
        alphaType: hipblasDatatype_t,
        x: *mut ::std::os::raw::c_void,
        xType: hipblasDatatype_t,
        incx: ::std::os::raw::c_int,
        executionType: hipblasDatatype_t,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasScalEx_v2(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        alpha: *const ::std::os::raw::c_void,
        alphaType: hipDataType,
        x: *mut ::std::os::raw::c_void,
        xType: hipDataType,
        incx: ::std::os::raw::c_int,
        executionType: hipDataType,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " \\brief BLAS EX API\n\n\\details\nscalBatchedEx  scales each element of each vector x_i with scalar alpha.\n\nx_i := alpha * x_i\n\n- Supported types are determined by the backend. See rocBLAS/cuBLAS documentation.\n\nWith HIPBLAS_V2 define, hipblasScalBatchedEx accepts hipDataType for alphaType,\nxType, and executionType rather than hipblasDatatype_t. hipblasScalBatchedEx will only\naccept hipDataType in a future release.\n\\code{.cpp}\n#ifdef HIPBLAS_V2 // available in hipBLAS version 2.0.0 and later with -DHIPBLAS_V2\n\nhipblasStatus_t hipblasScalBatchedEx(hipblasHandle_t handle,\nint             n,\nconst void*     alpha,\nhipDataType     alphaType,\nvoid*           x,\nhipDataType     xType,\nint             incx,\nint             batchCount,\nhipDataType     executionType)\n\n#else // [DEPRECATED]\n\nhipblasStatus_t hipblasScalBatchedEx(hipblasHandle_t   handle,\nint               n,\nconst void*       alpha,\nhipblasDatatype_t alphaType,\nvoid*             x,\nhipblasDatatype_t xType,\nint               incx,\nint               batchCount,\nhipblasDatatype_t executionType)\n\n#endif\n\\endcode\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n@param[in]\nn         [int]\nthe number of elements in x.\n@param[in]\nalpha     device pointer or host pointer for the scalar alpha.\n@param[in]\nalphaType\n[hipblasDatatype_t] [DEPRECATED]\nspecifies the datatype of alpha.\\n\n[hipDataType]\nspecifies the datatype of alpha.\n@param[inout]\nx         device array of device pointers storing each vector x_i.\n@param[in]\nxType\n[hipblasDatatype_t] [DEPRECATED]\nspecifies the datatype of each vector x_i.\\n\n[hipDataType]\nspecifies the datatype of each vector x_i.\n@param[in]\nincx      [int]\nspecifies the increment for the elements of each x_i.\n@param[in]\nbatchCount [int]\nnumber of instances in the batch.\n@param[in]\nexecutionType\n[hipblasDatatype_t] [DEPRECATED]\nspecifies the datatype of computation.\\n\n[hipDataType]\nspecifies the datatype of computation.\n"]
    pub fn hipblasScalBatchedEx(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        alpha: *const ::std::os::raw::c_void,
        alphaType: hipblasDatatype_t,
        x: *mut ::std::os::raw::c_void,
        xType: hipblasDatatype_t,
        incx: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
        executionType: hipblasDatatype_t,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasScalBatchedEx_v2(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        alpha: *const ::std::os::raw::c_void,
        alphaType: hipDataType,
        x: *mut ::std::os::raw::c_void,
        xType: hipDataType,
        incx: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
        executionType: hipDataType,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " \\brief BLAS EX API\n\n\\details\nscalStridedBatchedEx  scales each element of vector x with scalar alpha over a set\nof strided batched vectors.\n\nx := alpha * x\n\n- Supported types are determined by the backend. See rocBLAS/cuBLAS documentation.\n\nWith HIPBLAS_V2 define, hipblasScalStridedBatchedEx accepts hipDataType for alphaType,\nxType, and executionType rather than hipblasDatatype_t. hipblasScalStridedBatchedEx will only\naccept hipDataType in a future release.\n\\code{.cpp}\n#ifdef HIPBLAS_V2 // available in hipBLAS version 2.0.0 and later with -DHIPBLAS_V2\n\nhipblasStatus_t hipblasScalStridedBatchedEx(hipblasHandle_t handle,\nint             n,\nconst void*     alpha,\nhipDataType     alphaType,\nvoid*           x,\nhipDataType     xType,\nint             incx,\nhipblasStride   stridex,\nint             batchCount,\nhipDataType     executionType)\n\n#else // [DEPRECATED]\n\nhipblasStatus_t hipblasScalStridedBatchedEx(hipblasHandle_t   handle,\nint               n,\nconst void*       alpha,\nhipblasDatatype_t alphaType,\nvoid*             x,\nhipblasDatatype_t xType,\nint               incx,\nhipblasStride     stridex,\nint               batchCount,\nhipblasDatatype_t executionType)\n\n#endif\n\\endcode\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n@param[in]\nn         [int]\nthe number of elements in x.\n@param[in]\nalpha     device pointer or host pointer for the scalar alpha.\n@param[in]\nalphaType\n[hipblasDatatype_t] [DEPRECATED]\nspecifies the datatype of alpha.\\n\n[hipDataType]\nspecifies the datatype of alpha.\n@param[inout]\nx         device pointer to the first vector x_1.\n@param[in]\nxType\n[hipblasDatatype_t] [DEPRECATED]\nspecifies the datatype of each vector x_i.\\n\n[hipDataType]\nspecifies the datatype of each vector x_i.\n@param[in]\nincx      [int]\nspecifies the increment for the elements of each x_i.\n@param[in]\nstridex   [hipblasStride]\nstride from the start of one vector (x_i) to the next one (x_i+1).\nThere are no restrictions placed on stridex, however the user should\ntake care to ensure that stridex is of appropriate size, for a typical\ncase this means stridex >= n * incx.\n@param[in]\nbatchCount [int]\nnumber of instances in the batch.\n@param[in]\nexecutionType\n[hipblasDatatype_t] [DEPRECATED]\nspecifies the datatype of computation.\\n\n[hipDataType]\nspecifies the datatype of computation.\n"]
    pub fn hipblasScalStridedBatchedEx(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        alpha: *const ::std::os::raw::c_void,
        alphaType: hipblasDatatype_t,
        x: *mut ::std::os::raw::c_void,
        xType: hipblasDatatype_t,
        incx: ::std::os::raw::c_int,
        stridex: hipblasStride,
        batchCount: ::std::os::raw::c_int,
        executionType: hipblasDatatype_t,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasScalStridedBatchedEx_v2(
        handle: hipblasHandle_t,
        n: ::std::os::raw::c_int,
        alpha: *const ::std::os::raw::c_void,
        alphaType: hipDataType,
        x: *mut ::std::os::raw::c_void,
        xType: hipDataType,
        incx: ::std::os::raw::c_int,
        stridex: hipblasStride,
        batchCount: ::std::os::raw::c_int,
        executionType: hipDataType,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " HIPBLAS Auxiliary API\n\n\\details\nhipblasStatusToString\n\nReturns string representing hipblasStatus_t value\n\n@param[in]\nstatus  [hipblasStatus_t]\nhipBLAS status to convert to string"]
    pub fn hipblasStatusToString(status: hipblasStatus_t) -> *const ::std::os::raw::c_char;
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __va_list_tag {
    pub gp_offset: ::std::os::raw::c_uint,
    pub fp_offset: ::std::os::raw::c_uint,
    pub overflow_arg_area: *mut ::std::os::raw::c_void,
    pub reg_save_area: *mut ::std::os::raw::c_void,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_data {
    pub _address: u8,
}
